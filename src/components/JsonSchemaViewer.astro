---
import { Tabs, TabItem } from '@astrojs/starlight/components';

interface Props {
  schema: any;
  class?: string;
  /** Set of known asset type IDs for linking $ref badges */
  knownAssetIds?: Set<string>;
}

const { schema, class: className, knownAssetIds } = Astro.props;

// --- Helpers ---

function escapeHtml(str: string): string {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function getRefName(ref: string): string {
  // For local refs like #/$defs/SomeName, return the last path segment
  if (ref.startsWith('#')) {
    const parts = ref.split('/');
    return parts[parts.length - 1];
  }
  // For external refs like ItemReticleConfig.json# or common.schema.json#/$defs/Foo
  const [filePart, fragment] = ref.split('#');
  if (fragment) {
    const fragParts = fragment.split('/').filter(Boolean);
    if (fragParts.length > 0) {
      return fragParts[fragParts.length - 1];
    }
  }
  return filePart.replace(/\.schema\.json$/, '').replace(/\.json$/, '');
}

function resolveRef(ref: string, rootSchema: any): any {
  if (!ref.startsWith('#/')) return null;
  const path = ref.slice(2).split('/');
  let current = rootSchema;
  for (const segment of path) {
    if (current && typeof current === 'object' && segment in current) {
      current = current[segment];
    } else {
      return null;
    }
  }
  return current;
}

function typeBadge(type: string | string[] | undefined): string {
  const types = Array.isArray(type) ? type : [type || 'unknown'];
  return types
    .map((t) => `<span class="sv-type sv-type--${t}">${escapeHtml(t)}</span>`)
    .join('');
}

function getRefAssetId(ref: string): string | null {
  if (ref.startsWith('#')) return null;
  const filePart = ref.split('#')[0];
  // Strip .schema.json or .json extension
  return filePart.replace(/\.schema\.json$/, '').replace(/\.json$/, '') || null;
}

function refBadge(ref: string): string {
  const name = getRefName(ref);
  const assetId = getRefAssetId(ref);
  if (assetId && knownAssetIds?.has(assetId)) {
    return `<a href="/database/asset-types/${encodeURIComponent(assetId)}" class="sv-ref sv-ref--link">${escapeHtml(name)}</a>`;
  }
  return `<span class="sv-ref">${escapeHtml(name)}</span>`;
}

function renderMeta(prop: any): string {
  let html = '';

  if (prop.description) {
    html += `<p class="sv-desc">${escapeHtml(prop.description)}</p>`;
  }

  if (prop.enum) {
    html += `<div class="sv-meta"><span class="sv-meta-label">Enum:</span>${prop.enum.map((v: any) => `<code>${escapeHtml(JSON.stringify(v))}</code>`).join('')}</div>`;
  }

  if (prop.default !== undefined) {
    html += `<div class="sv-meta"><span class="sv-meta-label">Default:</span><code>${escapeHtml(JSON.stringify(prop.default))}</code></div>`;
  }

  if (prop.format) {
    html += `<div class="sv-meta"><span class="sv-meta-label">Format:</span><code>${escapeHtml(prop.format)}</code></div>`;
  }

  const rangeParts: string[] = [];
  if (prop.minimum !== undefined) rangeParts.push(`Min: ${prop.minimum}`);
  if (prop.exclusiveMinimum !== undefined) rangeParts.push(`Min (exclusive): ${prop.exclusiveMinimum}`);
  if (prop.maximum !== undefined) rangeParts.push(`Max: ${prop.maximum}`);
  if (prop.exclusiveMaximum !== undefined) rangeParts.push(`Max (exclusive): ${prop.exclusiveMaximum}`);
  if (rangeParts.length) {
    html += `<div class="sv-meta">${rangeParts.map((r) => `<code>${escapeHtml(r)}</code>`).join('')}</div>`;
  }

  if (prop.pattern) {
    html += `<div class="sv-meta"><span class="sv-meta-label">Pattern:</span><code>${escapeHtml(prop.pattern)}</code></div>`;
  }

  return html;
}

function renderComposition(prop: any, depth: number, rootSchema: any): string {
  let html = '';
  for (const keyword of ['oneOf', 'anyOf', 'allOf'] as const) {
    const schemas = prop[keyword];
    if (!schemas) continue;
    const label = keyword === 'oneOf' ? 'One of' : keyword === 'anyOf' ? 'Any of' : 'All of';
    html += `<div class="sv-composition">
      <span class="sv-composition-label">${label}</span>
      <div class="sv-composition-options">
        ${(schemas as any[]).map((s: any) => {
          let inner = '';
          if (s.$ref) {
            inner += refBadge(s.$ref);
          } else {
            inner += typeBadge(s.type);
          }
          if (s.title) {
            inner += `<span class="sv-desc">${escapeHtml(s.title)}</span>`;
          }
          if (s.properties) {
            inner += renderProperties(s.properties, s.required, depth + 1, rootSchema);
          }
          return `<div class="sv-composition-option">${inner}</div>`;
        }).join('')}
      </div>
    </div>`;
  }
  return html;
}

function renderChildren(prop: any, depth: number, rootSchema: any): string {
  let html = '';

  if (prop.properties) {
    html += renderProperties(prop.properties, prop.required, depth + 1, rootSchema);
  }

  const isArray = Array.isArray(prop.type) ? prop.type.includes('array') : prop.type === 'array';
  if (prop.items && isArray) {
    const items = prop.items;
    if (items.properties) {
      html += `<div class="sv-array-label">Array items</div>`;
      html += renderProperties(items.properties, items.required, depth + 1, rootSchema);
    } else if (items.$ref) {
      html += `<div class="sv-array-label">Array items: ${refBadge(items.$ref)}</div>`;
    } else {
      html += `<div class="sv-array-label">Array items: ${typeBadge(items.type)}</div>`;
    }
  }

  // Handle additionalProperties (when it's a schema object, not a boolean)
  if (prop.additionalProperties && typeof prop.additionalProperties === 'object') {
    const ap = prop.additionalProperties;
    if (ap.$ref) {
      html += `<div class="sv-array-label">Additional properties: ${refBadge(ap.$ref)}</div>`;
    } else if (ap.properties) {
      html += `<div class="sv-array-label">Additional properties</div>`;
      html += renderProperties(ap.properties, ap.required, depth + 1, rootSchema);
    } else if (ap.anyOf || ap.oneOf || ap.allOf) {
      html += `<div class="sv-array-label">Additional properties</div>`;
      html += renderComposition(ap, depth, rootSchema);
    } else if (ap.type) {
      html += `<div class="sv-array-label">Additional properties: ${typeBadge(ap.type)}</div>`;
    }
  }

  html += renderComposition(prop, depth, rootSchema);

  return html;
}

function renderProperty(name: string, prop: any, isRequired: boolean, depth: number, rootSchema: any): string {
  let effectiveProp = prop;
  if (prop.$ref) {
    const resolved = resolveRef(prop.$ref, rootSchema);
    if (resolved) {
      effectiveProp = { ...resolved, ...prop, $ref: prop.$ref };
    }
  }

  const hasAdditionalProps = effectiveProp.additionalProperties && typeof effectiveProp.additionalProperties === 'object';
  const hasChildren =
    effectiveProp.properties ||
    effectiveProp.items ||
    effectiveProp.oneOf ||
    effectiveProp.anyOf ||
    effectiveProp.allOf ||
    hasAdditionalProps;

  const badge = prop.$ref ? refBadge(prop.$ref) : typeBadge(effectiveProp.type);
  const reqHtml = isRequired ? '<span class="sv-required">required</span>' : '';
  const meta = renderMeta(effectiveProp);

  if (hasChildren) {
    const open = depth < 1 ? ' open' : '';
    return `<details class="sv-prop"${open}>
      <summary class="sv-prop-header">
        <span class="sv-prop-left"><span class="sv-prop-name">${escapeHtml(name)}</span>${reqHtml}</span>
        <span class="sv-prop-right">${badge}</span>
      </summary>
      <div class="sv-prop-body">
        ${meta}
        ${renderChildren(effectiveProp, depth, rootSchema)}
      </div>
    </details>`;
  }

  return `<div class="sv-prop sv-prop--leaf">
    <div class="sv-prop-header">
      <span class="sv-prop-left"><span class="sv-prop-name">${escapeHtml(name)}</span>${reqHtml}</span>
      <span class="sv-prop-right">${badge}</span>
    </div>
    ${meta ? `<div class="sv-prop-body">${meta}</div>` : ''}
  </div>`;
}

function renderProperties(properties: Record<string, any>, required: string[] | undefined, depth: number, rootSchema: any): string {
  const req = required || [];
  return Object.entries(properties)
    .map(([name, prop]) => renderProperty(name, prop, req.includes(name), depth, rootSchema))
    .join('');
}

// --- Build the tree HTML ---
const treeHtml = (() => {
  let html = '';

  if (schema.properties) {
    html += renderProperties(schema.properties, schema.required, 0, schema);
  }

  if (schema.items && schema.type === 'array') {
    const items = schema.items;
    if (items.properties) {
      html += `<div class="sv-array-label">Array items</div>`;
      html += renderProperties(items.properties, items.required, 0, schema);
    }
  }

  html += renderComposition(schema, 0, schema);

  // Definitions section
  const defs = schema.$defs || schema.definitions;
  if (defs) {
    const title = schema.$defs ? '$defs' : 'definitions';
    const count = Object.keys(defs).length;
    html += `<details class="sv-defs">
      <summary class="sv-defs-header">
        <span>${title}</span>
        <span class="sv-defs-count">${count} definition${count !== 1 ? 's' : ''}</span>
      </summary>
      <div class="sv-defs-body">
        ${Object.entries(defs).map(([name, def]) => renderProperty(name, def as any, false, 1, schema)).join('')}
      </div>
    </details>`;
  }

  return html;
})();

const rawJson = JSON.stringify(schema, null, 2);
---

<div class:list={['schema-viewer not-content', className]}>
  <Tabs>
    <TabItem label="Tree">
      <div class="sv-tree" set:html={treeHtml} />
    </TabItem>
    <TabItem label="Raw JSON">
      <div class="sv-raw">
        <button class="sv-copy-btn" aria-label="Copy to clipboard">Copy</button>
        <pre><code>{rawJson}</code></pre>
      </div>
    </TabItem>
  </Tabs>
</div>

<script>
  document.querySelectorAll('.sv-copy-btn').forEach((btn) => {
    btn.addEventListener('click', async () => {
      const pre = btn.parentElement?.querySelector('pre');
      if (!pre) return;
      await navigator.clipboard.writeText(pre.textContent || '');
      const original = btn.textContent;
      btn.textContent = 'Copied!';
      setTimeout(() => (btn.textContent = original), 1500);
    });
  });
</script>

<style>
  /* --- Layout --- */
  .schema-viewer {
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 0.5rem;
    overflow: hidden;
    margin-top: 1rem;
    padding: 1rem;
  }

  /* --- Tree --- */
  .sv-tree {
    font-size: 0.875rem;
  }

  /* --- Property rows --- */
  .sv-prop {
    border-bottom: 1px solid var(--sl-color-gray-6);
  }

  .sv-prop:last-child {
    border-bottom: none;
  }

  .sv-prop-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
    padding: 0.5rem 1rem;
    cursor: default;
    list-style: none;
  }

  .sv-prop-header::-webkit-details-marker {
    display: none;
  }

  details.sv-prop > .sv-prop-header {
    cursor: pointer;
  }

  details.sv-prop > .sv-prop-header:hover {
    background: var(--sl-color-gray-6);
  }

  .sv-prop-left {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-width: 0;
  }

  .sv-prop-right {
    display: flex;
    align-items: center;
    gap: 0.375rem;
    flex-shrink: 0;
  }

  /* Arrow indicator for expandable properties */
  details.sv-prop > summary.sv-prop-header::before {
    content: '▶';
    font-size: 0.625rem;
    color: var(--sl-color-gray-3);
    transition: transform 0.15s ease;
    flex-shrink: 0;
  }

  details.sv-prop[open] > summary.sv-prop-header::before {
    transform: rotate(90deg);
  }

  .sv-prop-name {
    font-family: var(--sl-font-mono, monospace);
    font-weight: 500;
    color: var(--sl-color-text);
    font-size: 0.8125rem;
  }

  .sv-required {
    font-size: 0.625rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--sl-color-red, #ef4444);
  }

  /* --- Property body (description, meta, children) --- */
  .sv-prop-body {
    padding-left: 1.25rem;
    border-left: 2px solid var(--sl-color-gray-5);
    margin-left: 1rem;
  }

  .sv-desc {
    margin: 0;
    padding: 0.25rem 1rem 0.5rem;
    font-size: 0.8125rem;
    color: var(--sl-color-gray-2);
  }

  .sv-meta {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.375rem;
    padding: 0.125rem 1rem 0.375rem;
    font-size: 0.75rem;
  }

  .sv-meta-label {
    color: var(--sl-color-gray-3);
    font-weight: 500;
  }

  .sv-meta code {
    font-size: 0.75rem;
    background: var(--sl-color-gray-6);
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    color: var(--sl-color-text);
    font-family: var(--sl-font-mono, monospace);
  }

  /* --- Type badges --- */
  :global(.sv-type) {
    display: inline-block;
    font-size: 0.6875rem;
    font-weight: 500;
    padding: 0.125rem 0.5rem;
    border-radius: 1rem;
    border: 1px solid;
    font-family: var(--sl-font-mono, monospace);
  }

  :global(.sv-type--string)  { background: rgba(16,185,129,0.1);  color: #34d399; border-color: rgba(16,185,129,0.3); }
  :global(.sv-type--number),
  :global(.sv-type--integer) { background: rgba(245,158,11,0.1);  color: #fbbf24; border-color: rgba(245,158,11,0.3); }
  :global(.sv-type--boolean) { background: rgba(14,165,233,0.1);  color: #38bdf8; border-color: rgba(14,165,233,0.3); }
  :global(.sv-type--array)   { background: rgba(139,92,246,0.1);  color: #a78bfa; border-color: rgba(139,92,246,0.3); }
  :global(.sv-type--object)  { background: rgba(244,63,94,0.1);   color: #fb7185; border-color: rgba(244,63,94,0.3); }
  :global(.sv-type--null)    { background: rgba(148,163,184,0.1); color: #94a3b8; border-color: rgba(148,163,184,0.3); }
  :global(.sv-type--unknown) { background: rgba(148,163,184,0.1); color: #94a3b8; border-color: rgba(148,163,184,0.3); }

  /* --- Ref badges --- */
  :global(.sv-ref) {
    display: inline-block;
    font-size: 0.6875rem;
    font-weight: 500;
    padding: 0.125rem 0.5rem;
    border-radius: 1rem;
    border: 1px solid rgba(6,182,212,0.3);
    background: rgba(6,182,212,0.1);
    color: #22d3ee;
    font-family: var(--sl-font-mono, monospace);
  }

  :global(a.sv-ref--link) {
    text-decoration: none;
    cursor: pointer;
    transition: background 0.15s ease, border-color 0.15s ease;
  }

  :global(a.sv-ref--link:hover) {
    background: rgba(6,182,212,0.2);
    border-color: rgba(6,182,212,0.5);
  }

  /* --- Composition (oneOf / anyOf / allOf) --- */
  :global(.sv-composition) {
    padding: 0.375rem 1rem;
  }

  :global(.sv-composition-label) {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--sl-color-gray-3);
    margin-bottom: 0.375rem;
  }

  :global(.sv-composition-options) {
    border-left: 2px solid var(--sl-color-gray-5);
    padding-left: 0.75rem;
  }

  :global(.sv-composition-option) {
    padding: 0.25rem 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  /* --- Array items label --- */
  :global(.sv-array-label) {
    padding: 0.375rem 1rem;
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--sl-color-gray-3);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  /* --- Definitions section --- */
  .sv-defs {
    border-top: 1px solid var(--sl-color-gray-5);
  }

  .sv-defs-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.625rem 1rem;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--sl-color-gray-3);
    cursor: pointer;
    list-style: none;
  }

  .sv-defs-header::-webkit-details-marker {
    display: none;
  }

  .sv-defs-header::before {
    content: '▶';
    font-size: 0.5rem;
    transition: transform 0.15s ease;
  }

  .sv-defs[open] > .sv-defs-header::before {
    transform: rotate(90deg);
  }

  .sv-defs-header:hover {
    background: var(--sl-color-gray-6);
  }

  .sv-defs-count {
    font-weight: 400;
    color: var(--sl-color-gray-3);
  }

  .sv-defs-body {
    border-top: 1px solid var(--sl-color-gray-5);
  }

  /* --- Raw JSON view --- */
  .sv-raw {
    position: relative;
  }

  .sv-raw pre {
    margin: 0;
    padding: 1rem;
    overflow: auto;
    max-height: 600px;
    font-size: 0.8125rem;
    line-height: 1.5;
    background: var(--sl-color-gray-6);
  }

  .sv-raw code {
    font-family: var(--sl-font-mono, monospace);
    color: var(--sl-color-text);
    background: none;
    padding: 0;
    font-size: inherit;
  }

  .sv-copy-btn {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    padding: 0.25rem 0.625rem;
    font-size: 0.75rem;
    font-weight: 500;
    background: var(--sl-color-gray-5);
    color: var(--sl-color-text);
    border: 1px solid var(--sl-color-gray-4, var(--sl-color-gray-5));
    border-radius: 0.25rem;
    cursor: pointer;
    z-index: 1;
  }

  .sv-copy-btn:hover {
    background: var(--sl-color-gray-4, var(--sl-color-gray-3));
  }
</style>
