{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "common.schema.json",
  "title": "Common Definitions",
  "description": "Shared type definitions used across Hytale asset schemas",
  "$defs": {
    "AmbienceFXConditions": {
      "type": "object",
      "title": "AmbienceFXConditions",
      "properties": {
        "Never": {
          "type": "boolean",
          "description": "If true, this Ambience will never conditionally trigger (but can be set server-side, for example).",
          "default": false
        },
        "EnvironmentIds": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "EnvironmentTagPattern": {
          "description": "A tag pattern to use for matching environments.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to TagPattern"
            },
            {
              "$ref": "TagPattern.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "WeatherTagPattern": {
          "description": "A tag pattern to use for matching weathers.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to TagPattern"
            },
            {
              "$ref": "TagPattern.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "WeatherIds": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "FluidFXIds": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "SurroundingBlockSoundSets": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/AmbienceFXBlockSoundSet"
          }
        },
        "Altitude": {
          "anyOf": [
            {
              "default": {
                "Min": 0,
                "Max": 512
              },
              "$ref": "common.schema.json#/$defs/Range"
            },
            {
              "type": "null"
            }
          ]
        },
        "Walls": {
          "anyOf": [
            {
              "default": {
                "Min": 0,
                "Max": 4
              },
              "$ref": "common.schema.json#/$defs/Rangeb"
            },
            {
              "type": "null"
            }
          ]
        },
        "Roof": {
          "type": "boolean",
          "default": false
        },
        "RoofMaterialTagPattern": {
          "description": "A tag pattern to use for matching roof material. If Roof is not required, will only be matched if a roof is present.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to TagPattern"
            },
            {
              "$ref": "TagPattern.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Floor": {
          "type": "boolean",
          "default": false
        },
        "SunLightLevel": {
          "anyOf": [
            {
              "default": {
                "Min": 0,
                "Max": 15
              },
              "$ref": "common.schema.json#/$defs/Rangeb"
            },
            {
              "type": "null"
            }
          ]
        },
        "TorchLightLevel": {
          "anyOf": [
            {
              "default": {
                "Min": 0,
                "Max": 15
              },
              "$ref": "common.schema.json#/$defs/Rangeb"
            },
            {
              "type": "null"
            }
          ]
        },
        "GlobalLightLevel": {
          "anyOf": [
            {
              "default": {
                "Min": 0,
                "Max": 15
              },
              "$ref": "common.schema.json#/$defs/Rangeb"
            },
            {
              "type": "null"
            }
          ]
        },
        "DayTime": {
          "anyOf": [
            {
              "default": {
                "Min": 0,
                "Max": 24
              },
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AmbienceFXBlockSoundSet": {
      "type": "object",
      "title": "AmbienceFXBlockSoundSet",
      "properties": {
        "BlockSoundSetId": {
          "type": "string"
        },
        "Percent": {
          "anyOf": [
            {
              "default": {
                "Min": 0,
                "Max": 0
              },
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Rangef": {
      "type": "object",
      "title": "Rangef",
      "properties": {
        "Min": {
          "type": "number",
          "default": 0
        },
        "Max": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "Range": {
      "type": "object",
      "title": "Range",
      "properties": {
        "Min": {
          "type": "integer",
          "default": 0
        },
        "Max": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "Rangeb": {
      "type": "object",
      "title": "Rangeb",
      "properties": {
        "Min": {
          "type": "integer",
          "default": 0
        },
        "Max": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "AmbienceFXSound": {
      "type": "object",
      "title": "AmbienceFXSound",
      "properties": {
        "SoundEventId": {
          "type": "string"
        },
        "Play3D": {
          "type": [
            "string",
            "null"
          ],
          "title": "AmbienceFXSoundPlay3D",
          "enum": [
            "Random",
            "LocationName",
            "No"
          ],
          "default": "Random"
        },
        "BlockSoundSetId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Altitude": {
          "type": [
            "string",
            "null"
          ],
          "title": "AmbienceFXAltitude",
          "enum": [
            "Normal",
            "Lowest",
            "Highest",
            "Random"
          ],
          "default": "Normal"
        },
        "Frequency": {
          "anyOf": [
            {
              "default": {
                "Min": 1,
                "Max": 10
              },
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "Radius": {
          "anyOf": [
            {
              "default": {
                "Min": 0,
                "Max": 24
              },
              "$ref": "common.schema.json#/$defs/Range"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AmbienceFXMusic": {
      "type": "object",
      "title": "AmbienceFXMusic",
      "properties": {
        "Tracks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "Volume": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "AmbienceFXAmbientBed": {
      "type": "object",
      "title": "AmbienceFXAmbientBed",
      "properties": {
        "Track": {
          "type": "string"
        },
        "Volume": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "TransitionSpeed": {
          "type": [
            "string",
            "null"
          ],
          "title": "AmbienceTransitionSpeed",
          "description": "How quickly to transition to this ambient bed and fade out any ambient beds that are stopping. For fading out stopping ambient beds, faster transitions take priority. Fade-ins are already fast by default.",
          "enum": [
            "Default",
            "Fast",
            "Instant"
          ],
          "default": "Default"
        }
      },
      "additionalProperties": false
    },
    "AmbienceFXSoundEffect": {
      "type": "object",
      "title": "AmbienceFXSoundEffect",
      "properties": {
        "ReverbEffectId": {
          "type": [
            "string",
            "null"
          ]
        },
        "EqualizerEffectId": {
          "type": [
            "string",
            "null"
          ]
        },
        "IsInstant": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "ConstantAssignmentsAsset": {
      "type": "object",
      "title": "ConstantAssignmentsAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Constant\" to function as this type.",
          "const": "Constant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantAssignmentsAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantAssignmentsAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "AssignmentsAsset",
            "mapKey": "Type",
            "mapKeyValue": "Constant"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Prop": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BoxPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClusterPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PondFillerPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PrefabPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueuePropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedPropAsset@1"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BoxPropAsset": {
      "type": "object",
      "title": "BoxPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Box\" to function as this type.",
          "const": "Box"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BoxPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BoxPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Box"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Range": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "Material": {
          "anyOf": [
            {
              "default": {
                "Solid": "",
                "Fluid": ""
              },
              "$ref": "common.schema.json#/$defs/MaterialAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Pattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scanner": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AreaScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnLinearScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnRandomScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OriginScannerAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Vector3i": {
      "type": "object",
      "title": "Vector3i",
      "properties": {
        "X": {
          "type": "integer",
          "default": 0
        },
        "Y": {
          "type": "integer",
          "default": 0
        },
        "Z": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "MaterialAsset": {
      "type": "object",
      "title": "MaterialAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MaterialAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MaterialAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Solid": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Fluid": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        }
      },
      "additionalProperties": false
    },
    "AndPatternAsset": {
      "type": "object",
      "title": "AndPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"And\" to function as this type.",
          "const": "And"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AndPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AndPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "And"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Patterns": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/AndPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DensityPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/FloorPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/GapPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/NotPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OrPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/WallPatternAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BlockSetPatternAsset": {
      "type": "object",
      "title": "BlockSetPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BlockSet\" to function as this type.",
          "const": "BlockSet"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BlockSetPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BlockSetPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "BlockSet"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "BlockSet": {
          "anyOf": [
            {
              "default": {
                "Inclusive": true,
                "Materials": []
              },
              "$ref": "common.schema.json#/$defs/MaterialSetAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MaterialSetAsset": {
      "type": "object",
      "title": "MaterialSetAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MaterialSetAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MaterialSetAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialSetAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Inclusive": {
          "type": "boolean",
          "default": true
        },
        "Materials": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/MaterialAsset"
          }
        }
      },
      "additionalProperties": false
    },
    "MaterialPatternAsset": {
      "type": "object",
      "title": "MaterialPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BlockType\" to function as this type.",
          "const": "BlockType"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MaterialPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MaterialPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "BlockType"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Material": {
          "anyOf": [
            {
              "default": {
                "Solid": "",
                "Fluid": ""
              },
              "$ref": "common.schema.json#/$defs/MaterialAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CeilingPatternAsset": {
      "type": "object",
      "title": "CeilingPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Ceiling\" to function as this type.",
          "const": "Ceiling"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CeilingPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CeilingPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Ceiling"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Ceiling": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Origin": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConstantPatternAsset": {
      "type": "object",
      "title": "ConstantPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Constant\" to function as this type.",
          "const": "Constant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Constant"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CuboidPatternAsset": {
      "type": "object",
      "title": "CuboidPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cuboid\" to function as this type.",
          "const": "Cuboid"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CuboidPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CuboidPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cuboid"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "SubPattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Min": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "Max": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DensityPatternAsset": {
      "type": "object",
      "title": "DensityPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FieldFunction\" to function as this type.",
          "const": "FieldFunction"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DensityPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DensityPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "FieldFunction"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset"
          }
        },
        "FieldFunction": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Min": {
          "type": "number",
          "default": 0
        },
        "Max": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "FloorPatternAsset": {
      "type": "object",
      "title": "FloorPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Floor\" to function as this type.",
          "const": "Floor"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FloorPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FloorPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Floor"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Floor": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Origin": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "GapPatternAsset": {
      "type": "object",
      "title": "GapPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Gap\" to function as this type.",
          "const": "Gap"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another GapPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **GapPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Gap"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "GapPattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "AnchorPattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "GapSize": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "AnchorSize": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "AnchorRoughness": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "DepthDown": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "DepthUp": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "Angles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "base.schema.json#/$defs/NumberOrSpecial"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ImportedPatternAsset": {
      "type": "object",
      "title": "ImportedPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "NotPatternAsset": {
      "type": "object",
      "title": "NotPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Not\" to function as this type.",
          "const": "Not"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another NotPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **NotPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Not"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Pattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OffsetPatternAsset": {
      "type": "object",
      "title": "OffsetPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Offset\" to function as this type.",
          "const": "Offset"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OffsetPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OffsetPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Offset"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Pattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Offset": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OrPatternAsset": {
      "type": "object",
      "title": "OrPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Or\" to function as this type.",
          "const": "Or"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OrPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OrPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Or"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Patterns": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/AndPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DensityPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/FloorPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/GapPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/NotPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OrPatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/WallPatternAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SurfacePatternAsset": {
      "type": "object",
      "title": "SurfacePatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Surface\" to function as this type.",
          "const": "Surface"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SurfacePatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SurfacePatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Surface"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Surface": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Medium": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "SurfaceRadius": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "MediumRadius": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "SurfaceGap": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "MediumGap": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "RequireAllFacings": {
          "type": "boolean",
          "default": false
        },
        "Facings": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string",
            "title": "Facing",
            "enum": [
              "U",
              "D",
              "E",
              "W",
              "S",
              "N"
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WallPatternAsset": {
      "type": "object",
      "title": "WallPatternAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Wall\" to function as this type.",
          "const": "Wall"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WallPatternAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WallPatternAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PatternAsset",
            "mapKey": "Type",
            "mapKeyValue": "Wall"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Wall": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Origin": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "RequireAllDirections": {
          "type": "boolean",
          "default": false
        },
        "Directions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string",
            "title": "WallDirection",
            "enum": [
              "N",
              "S",
              "E",
              "W"
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AreaScannerAsset": {
      "type": "object",
      "title": "AreaScannerAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Area\" to function as this type.",
          "const": "Area"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AreaScannerAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AreaScannerAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ScannerAsset",
            "mapKey": "Type",
            "mapKeyValue": "Area"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "ResultCap": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "ScanShape": {
          "type": [
            "string",
            "null"
          ],
          "title": "ScanShape",
          "enum": [
            "Circle",
            "Square"
          ],
          "default": "Circle"
        },
        "ScanRange": {
          "type": "integer",
          "exclusiveMinimum": -1,
          "default": 0
        },
        "ChildScanner": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AreaScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnLinearScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnRandomScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OriginScannerAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ColumnLinearScannerAsset": {
      "type": "object",
      "title": "ColumnLinearScannerAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ColumnLinear\" to function as this type.",
          "const": "ColumnLinear"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ColumnLinearScannerAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ColumnLinearScannerAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ScannerAsset",
            "mapKey": "Type",
            "mapKeyValue": "ColumnLinear"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "MinY": {
          "type": "integer",
          "default": 0
        },
        "MaxY": {
          "type": "integer",
          "default": 1
        },
        "ResultCap": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "TopDownOrder": {
          "type": "boolean",
          "default": true
        },
        "RelativeToPosition": {
          "type": "boolean",
          "default": false
        },
        "BaseHeightName": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ColumnRandomScannerAsset": {
      "type": "object",
      "title": "ColumnRandomScannerAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ColumnRandom\" to function as this type.",
          "const": "ColumnRandom"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ColumnRandomScannerAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ColumnRandomScannerAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ScannerAsset",
            "mapKey": "Type",
            "mapKeyValue": "ColumnRandom"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "MinY": {
          "type": "integer",
          "default": 0
        },
        "MaxY": {
          "type": "integer",
          "default": 1
        },
        "ResultCap": {
          "type": "integer",
          "minimum": 0,
          "default": 1
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "Strategy": {
          "type": [
            "string",
            "null"
          ],
          "default": "DART_THROW"
        },
        "RelativeToPosition": {
          "type": "boolean",
          "default": false
        },
        "BaseHeightName": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ImportedScannerAsset": {
      "type": "object",
      "title": "ImportedScannerAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedScannerAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedScannerAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ScannerAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OriginScannerAsset": {
      "type": "object",
      "title": "OriginScannerAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Origin\" to function as this type.",
          "const": "Origin"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OriginScannerAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OriginScannerAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ScannerAsset",
            "mapKey": "Type",
            "mapKeyValue": "Origin"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ClusterPropAsset": {
      "type": "object",
      "title": "ClusterPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cluster\" to function as this type.",
          "const": "Cluster"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ClusterPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ClusterPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cluster"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Range": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "DistanceCurve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "WeightedProps": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/WeightedPropAsset"
          }
        },
        "Pattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scanner": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AreaScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnLinearScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnRandomScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OriginScannerAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CeilingCurveAsset": {
      "type": "object",
      "title": "CeilingCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Ceiling\" to function as this type.",
          "const": "Ceiling"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CeilingCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CeilingCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Ceiling"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Ceiling": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ClampCurveAsset": {
      "type": "object",
      "title": "ClampCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Clamp\" to function as this type.",
          "const": "Clamp"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ClampCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ClampCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Clamp"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "WallA": {
          "type": "number",
          "default": 1
        },
        "WallB": {
          "type": "number",
          "default": -1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConstantCurveAsset": {
      "type": "object",
      "title": "ConstantCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Constant\" to function as this type.",
          "const": "Constant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Constant"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DistanceExponentialCurveAsset": {
      "type": "object",
      "title": "DistanceExponentialCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DistanceExponential\" to function as this type.",
          "const": "DistanceExponential"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DistanceExponentialCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DistanceExponentialCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "DistanceExponential"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Exponent": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DistanceSCurveAsset": {
      "type": "object",
      "title": "DistanceSCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DistanceS\" to function as this type.",
          "const": "DistanceS"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DistanceSCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DistanceSCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "DistanceS"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "ExponentA": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "ExponentB": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Transition": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "default": 1
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "TransitionSmooth": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FloorCurveAsset": {
      "type": "object",
      "title": "FloorCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Floor\" to function as this type.",
          "const": "Floor"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FloorCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FloorCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Floor"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Floor": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ImportedCurveAsset": {
      "type": "object",
      "title": "ImportedCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "InverterCurveAsset": {
      "type": "object",
      "title": "InverterCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Inverter\" to function as this type.",
          "const": "Inverter"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another InverterCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **InverterCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Inverter"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ManualCurveAsset": {
      "type": "object",
      "title": "ManualCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Manual\" to function as this type.",
          "const": "Manual"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ManualCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ManualCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Manual"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Points": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/PointInOutAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PointInOutAsset": {
      "type": "object",
      "title": "PointInOutAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PointInOutAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PointInOutAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PointInOutAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "In": {
          "type": "number",
          "default": 0
        },
        "Out": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "MinCurveAsset": {
      "type": "object",
      "title": "MinCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Min\" to function as this type.",
          "const": "Min"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MinCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MinCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Min"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curves": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ClampCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/FloorCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/InverterCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ManualCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/NotCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SumCurveAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MultiplierCurveAsset": {
      "type": "object",
      "title": "MultiplierCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Multiplier\" to function as this type.",
          "const": "Multiplier"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MultiplierCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MultiplierCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Multiplier"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curves": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ClampCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/FloorCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/InverterCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ManualCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/NotCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SumCurveAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "NotCurveAsset": {
      "type": "object",
      "title": "NotCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Not\" to function as this type.",
          "const": "Not"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another NotCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **NotCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Not"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothCeilingCurveAsset": {
      "type": "object",
      "title": "SmoothCeilingCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothCeiling\" to function as this type.",
          "const": "SmoothCeiling"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothCeilingCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothCeilingCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothCeiling"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "Ceiling": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothClampCurveAsset": {
      "type": "object",
      "title": "SmoothClampCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothClamp\" to function as this type.",
          "const": "SmoothClamp"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothClampCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothClampCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothClamp"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "WallA": {
          "type": "number",
          "default": 1
        },
        "WallB": {
          "type": "number",
          "default": -1
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothFloorCurveAsset": {
      "type": "object",
      "title": "SmoothFloorCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothFloor\" to function as this type.",
          "const": "SmoothFloor"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothFloorCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothFloorCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothFloor"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "Floor": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothMaxCurveAsset": {
      "type": "object",
      "title": "SmoothMaxCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothMax\" to function as this type.",
          "const": "SmoothMax"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothMaxCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothMaxCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothMax"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "CurveA": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "CurveB": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothMinCurveAsset": {
      "type": "object",
      "title": "SmoothMinCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothMin\" to function as this type.",
          "const": "SmoothMin"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothMinCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothMinCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothMin"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "CurveA": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "CurveB": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SumCurveAsset": {
      "type": "object",
      "title": "SumCurveAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Sum\" to function as this type.",
          "const": "Sum"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SumCurveAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SumCurveAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CurveAsset",
            "mapKey": "Type",
            "mapKeyValue": "Sum"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curves": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ClampCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/FloorCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/InverterCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ManualCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/NotCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SumCurveAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedPropAsset": {
      "type": "object",
      "title": "WeightedPropAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "WeightedPropAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Weight": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ColumnProp": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BoxPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClusterPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PondFillerPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PrefabPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueuePropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedPropAsset@1"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ColumnPropAsset": {
      "type": "object",
      "title": "ColumnPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Column\" to function as this type.",
          "const": "Column"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ColumnPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ColumnPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Column"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "ColumnBlocks": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ColumnBlock"
          }
        },
        "BlockMask": {
          "anyOf": [
            {
              "$ref": "BlockMaskAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Directionality": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ImportedDirectionalityAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PatternDirectionalityAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/RandomDirectionalityAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StaticDirectionalityAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scanner": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AreaScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnLinearScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnRandomScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OriginScannerAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ColumnBlock": {
      "type": "object",
      "title": "ColumnBlock",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ColumnBlock most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ColumnBlock** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ColumnBlock"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Y": {
          "type": "integer",
          "default": 1
        },
        "Material": {
          "anyOf": [
            {
              "default": {
                "Solid": "Empty",
                "Fluid": "Empty"
              },
              "$ref": "common.schema.json#/$defs/MaterialAsset"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ImportedDirectionalityAsset": {
      "type": "object",
      "title": "ImportedDirectionalityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedDirectionalityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedDirectionalityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DirectionalityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PatternDirectionalityAsset": {
      "type": "object",
      "title": "PatternDirectionalityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Pattern\" to function as this type.",
          "const": "Pattern"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PatternDirectionalityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PatternDirectionalityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DirectionalityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Pattern"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "InitialDirection": {
          "type": [
            "string",
            "null"
          ],
          "title": "OrthogonalDirection",
          "enum": [
            "N",
            "S",
            "E",
            "W",
            "U",
            "D"
          ],
          "default": "N"
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "NorthPattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "SouthPattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "EastPattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "WestPattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RandomDirectionalityAsset": {
      "type": "object",
      "title": "RandomDirectionalityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Random\" to function as this type.",
          "const": "Random"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RandomDirectionalityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RandomDirectionalityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DirectionalityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Random"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "Pattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "StaticDirectionalityAsset": {
      "type": "object",
      "title": "StaticDirectionalityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Static\" to function as this type.",
          "const": "Static"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another StaticDirectionalityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **StaticDirectionalityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DirectionalityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Static"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Rotation": {
          "type": "integer",
          "default": 0
        },
        "Pattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DensityPropAsset": {
      "type": "object",
      "title": "DensityPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Density\" to function as this type.",
          "const": "Density"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DensityPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DensityPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Density"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Range": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "PlacementMask": {
          "anyOf": [
            {
              "$ref": "BlockMaskAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Pattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scanner": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AreaScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnLinearScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnRandomScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OriginScannerAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConstantMaterialProviderAsset": {
      "type": "object",
      "title": "ConstantMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Constant\" to function as this type.",
          "const": "Constant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Constant"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Material": {
          "anyOf": [
            {
              "default": {
                "Solid": "",
                "Fluid": ""
              },
              "$ref": "common.schema.json#/$defs/MaterialAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DownwardDepthMaterialProviderAsset": {
      "type": "object",
      "title": "DownwardDepthMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DownwardDepth\" to function as this type.",
          "const": "DownwardDepth"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DownwardDepthMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DownwardDepthMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "DownwardDepth"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Depth": {
          "type": "integer",
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DownwardSpaceMaterialProviderAsset": {
      "type": "object",
      "title": "DownwardSpaceMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DownwardSpace\" to function as this type.",
          "const": "DownwardSpace"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DownwardSpaceMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DownwardSpaceMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "DownwardSpace"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Space": {
          "type": "integer",
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FieldFunctionMaterialProviderAsset": {
      "type": "object",
      "title": "FieldFunctionMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FieldFunction\" to function as this type.",
          "const": "FieldFunction"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FieldFunctionMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FieldFunctionMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "FieldFunction"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "FieldFunction": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset@1"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset@1": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "From": {
          "type": "number",
          "default": 0
        },
        "To": {
          "type": "number",
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ImportedMaterialProviderAsset": {
      "type": "object",
      "title": "ImportedMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "QueueMaterialProviderAsset": {
      "type": "object",
      "title": "QueueMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Queue\" to function as this type.",
          "const": "Queue"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another QueueMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **QueueMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Queue"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Queue": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SimpleHorizontalMaterialProviderAsset": {
      "type": "object",
      "title": "SimpleHorizontalMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SimpleHorizontal\" to function as this type.",
          "const": "SimpleHorizontal"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SimpleHorizontalMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SimpleHorizontalMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "SimpleHorizontal"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "TopY": {
          "type": "integer",
          "default": 0
        },
        "BottomY": {
          "type": "integer",
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "TopBaseHeight": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "BottomBaseHeight": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SolidityMaterialProviderAsset": {
      "type": "object",
      "title": "SolidityMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Solidity\" to function as this type.",
          "const": "Solidity"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SolidityMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SolidityMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Solidity"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Solid": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Empty": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SpaceAndDepthMaterialProviderAsset": {
      "type": "object",
      "title": "SpaceAndDepthMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SpaceAndDepth\" to function as this type.",
          "const": "SpaceAndDepth"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SpaceAndDepthMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SpaceAndDepthMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "SpaceAndDepth"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "LayerContext": {
          "type": [
            "string",
            "null"
          ],
          "title": "LayerContextType",
          "enum": [
            "DepthIntoFloor",
            "DepthIntoCeiling"
          ],
          "default": "DepthIntoFloor"
        },
        "MaxExpectedDepth": {
          "type": "integer",
          "minimum": 0,
          "default": 16
        },
        "Condition": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AlwaysTrueConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/AndConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/EqualsConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GreaterThanConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmallerThanConditionAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Layers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/ConstantThicknessLayerAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/NoiseThicknessAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/RangeThicknessAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/WeightedThicknessLayerAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AlwaysTrueConditionAsset": {
      "type": "object",
      "title": "AlwaysTrueConditionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"AlwaysTrueCondition\" to function as this type.",
          "const": "AlwaysTrueCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AlwaysTrueConditionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AlwaysTrueConditionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ConditionAsset",
            "mapKey": "Type",
            "mapKeyValue": "AlwaysTrueCondition"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AndConditionAsset": {
      "type": "object",
      "title": "AndConditionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"AndCondition\" to function as this type.",
          "const": "AndCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AndConditionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AndConditionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ConditionAsset",
            "mapKey": "Type",
            "mapKeyValue": "AndCondition"
          }
        },
        "Conditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/AlwaysTrueConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/AndConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/EqualsConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/GreaterThanConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/NotConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OrConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmallerThanConditionAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EqualsConditionAsset": {
      "type": "object",
      "title": "EqualsConditionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"EqualsCondition\" to function as this type.",
          "const": "EqualsCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EqualsConditionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EqualsConditionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ConditionAsset",
            "mapKey": "Type",
            "mapKeyValue": "EqualsCondition"
          }
        },
        "ContextToCheck": {
          "type": [
            "string",
            "null"
          ],
          "title": "ConditionParameter",
          "enum": [
            "SpaceAboveFloor",
            "SpaceBelowCeiling"
          ],
          "default": "SpaceAboveFloor"
        },
        "Value": {
          "type": "integer",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "GreaterThanConditionAsset": {
      "type": "object",
      "title": "GreaterThanConditionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"GreaterThanCondition\" to function as this type.",
          "const": "GreaterThanCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another GreaterThanConditionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **GreaterThanConditionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ConditionAsset",
            "mapKey": "Type",
            "mapKeyValue": "GreaterThanCondition"
          }
        },
        "ContextToCheck": {
          "type": [
            "string",
            "null"
          ],
          "title": "ConditionParameter",
          "enum": [
            "SpaceAboveFloor",
            "SpaceBelowCeiling"
          ],
          "default": "SpaceAboveFloor"
        },
        "Threshold": {
          "type": "integer",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "NotConditionAsset": {
      "type": "object",
      "title": "NotConditionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"NotCondition\" to function as this type.",
          "const": "NotCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another NotConditionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **NotConditionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ConditionAsset",
            "mapKey": "Type",
            "mapKeyValue": "NotCondition"
          }
        },
        "Condition": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AlwaysTrueConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/AndConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/EqualsConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GreaterThanConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrConditionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmallerThanConditionAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OrConditionAsset": {
      "type": "object",
      "title": "OrConditionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OrCondition\" to function as this type.",
          "const": "OrCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OrConditionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OrConditionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ConditionAsset",
            "mapKey": "Type",
            "mapKeyValue": "OrCondition"
          }
        },
        "Conditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/AlwaysTrueConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/AndConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/EqualsConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/GreaterThanConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/NotConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OrConditionAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SmallerThanConditionAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmallerThanConditionAsset": {
      "type": "object",
      "title": "SmallerThanConditionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmallerThanCondition\" to function as this type.",
          "const": "SmallerThanCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmallerThanConditionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmallerThanConditionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ConditionAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmallerThanCondition"
          }
        },
        "ContextToCheck": {
          "type": [
            "string",
            "null"
          ],
          "title": "ConditionParameter",
          "enum": [
            "SpaceAboveFloor",
            "SpaceBelowCeiling"
          ],
          "default": "SpaceAboveFloor"
        },
        "Threshold": {
          "type": "integer",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConstantThicknessLayerAsset": {
      "type": "object",
      "title": "ConstantThicknessLayerAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ConstantThickness\" to function as this type.",
          "const": "ConstantThickness"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantThicknessLayerAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantThicknessLayerAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "LayerAsset",
            "mapKey": "Type",
            "mapKeyValue": "ConstantThickness"
          }
        },
        "Thickness": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "StripedMaterialProviderAsset": {
      "type": "object",
      "title": "StripedMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Striped\" to function as this type.",
          "const": "Striped"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another StripedMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **StripedMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Striped"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Stripes": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/StripeAsset"
          }
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "StripeAsset": {
      "type": "object",
      "title": "StripeAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another StripeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **StripeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "StripeAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "TopY": {
          "type": "integer",
          "default": 0
        },
        "BottomY": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "TerrainDensityMaterialProviderAsset": {
      "type": "object",
      "title": "TerrainDensityMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TerrainDensity\" to function as this type.",
          "const": "TerrainDensity"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TerrainDensityMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TerrainDensityMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "TerrainDensity"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset@2"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset@2": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "From": {
          "type": "number",
          "default": 0
        },
        "To": {
          "type": "number",
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "UpwardDepthMaterialProviderAsset": {
      "type": "object",
      "title": "UpwardDepthMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UpwardDepth\" to function as this type.",
          "const": "UpwardDepth"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UpwardDepthMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UpwardDepthMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "UpwardDepth"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Depth": {
          "type": "integer",
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UpwardSpaceMaterialProviderAsset": {
      "type": "object",
      "title": "UpwardSpaceMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UpwardSpace\" to function as this type.",
          "const": "UpwardSpace"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UpwardSpaceMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UpwardSpaceMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "UpwardSpace"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Space": {
          "type": "integer",
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedMaterialProviderAsset": {
      "type": "object",
      "title": "WeightedMaterialProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Weighted\" to function as this type.",
          "const": "Weighted"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedMaterialProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedMaterialProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "MaterialProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Weighted"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "WeightedMaterials": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/WeightedMaterialAsset"
          }
        },
        "SkipChance": {
          "type": "number",
          "default": 0
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedMaterialAsset": {
      "type": "object",
      "title": "WeightedMaterialAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedMaterialAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedMaterialAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "WeightedMaterialAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Weight": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "NoiseThicknessAsset": {
      "type": "object",
      "title": "NoiseThicknessAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"NoiseThickness\" to function as this type.",
          "const": "NoiseThickness"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another NoiseThicknessAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **NoiseThicknessAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "LayerAsset",
            "mapKey": "Type",
            "mapKeyValue": "NoiseThickness"
          }
        },
        "ThicknessFunctionXZ": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RangeThicknessAsset": {
      "type": "object",
      "title": "RangeThicknessAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"RangeThickness\" to function as this type.",
          "const": "RangeThickness"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RangeThicknessAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RangeThicknessAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "LayerAsset",
            "mapKey": "Type",
            "mapKeyValue": "RangeThickness"
          }
        },
        "RangeMin": {
          "type": "integer",
          "default": 0
        },
        "RangeMax": {
          "type": "integer",
          "default": 0
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedThicknessLayerAsset": {
      "type": "object",
      "title": "WeightedThicknessLayerAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"WeightedThickness\" to function as this type.",
          "const": "WeightedThickness"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedThicknessLayerAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedThicknessLayerAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "LayerAsset",
            "mapKey": "Type",
            "mapKeyValue": "WeightedThickness"
          }
        },
        "PossibleThicknesses": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/WeightedThicknessAsset"
          }
        },
        "Material": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedThicknessAsset": {
      "type": "object",
      "title": "WeightedThicknessAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedThicknessAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedThicknessAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "WeightedThicknessAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Weight": {
          "type": "number",
          "default": 0
        },
        "Thickness": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ImportedPropAsset": {
      "type": "object",
      "title": "ImportedPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OffsetPropAsset": {
      "type": "object",
      "title": "OffsetPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Offset\" to function as this type.",
          "const": "Offset"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OffsetPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OffsetPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Offset"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Offset": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "Prop": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BoxPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClusterPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PondFillerPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PrefabPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueuePropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedPropAsset@1"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PondFillerPropAsset": {
      "type": "object",
      "title": "PondFillerPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PondFiller\" to function as this type.",
          "const": "PondFiller"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PondFillerPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PondFillerPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "PondFiller"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "BoundingMin": {
          "anyOf": [
            {
              "default": {
                "X": -10,
                "Y": -10,
                "Z": -10
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "BoundingMax": {
          "anyOf": [
            {
              "default": {
                "X": 10,
                "Y": 10,
                "Z": 10
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "FillMaterial": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DownwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueueMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SolidityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpaceAndDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StripedMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/TerrainDensityMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardDepthMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UpwardSpaceMaterialProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedMaterialProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "BarrierBlockSet": {
          "anyOf": [
            {
              "default": {
                "Inclusive": true,
                "Materials": []
              },
              "$ref": "common.schema.json#/$defs/MaterialSetAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Pattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scanner": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AreaScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnLinearScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnRandomScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OriginScannerAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PrefabPropAsset": {
      "type": "object",
      "title": "PrefabPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Prefab\" to function as this type.",
          "const": "Prefab"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PrefabPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PrefabPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Prefab"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "WeightedPrefabPaths": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/WeightedPathAsset"
          }
        },
        "LegacyPath": {
          "type": "boolean",
          "default": false
        },
        "Directionality": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ImportedDirectionalityAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PatternDirectionalityAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/RandomDirectionalityAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/StaticDirectionalityAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scanner": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AreaScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnLinearScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnRandomScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OriginScannerAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "BlockMask": {
          "anyOf": [
            {
              "$ref": "BlockMaskAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "MoldingDirection": {
          "type": [
            "string",
            "null"
          ],
          "title": "MoldingDirection",
          "enum": [
            "None",
            "Up",
            "Down",
            "North",
            "South",
            "East",
            "West"
          ],
          "default": "None"
        },
        "MoldingPattern": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AndPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BlockSetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MaterialPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CeilingPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CuboidPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/GapPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OrPatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SurfacePatternAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WallPatternAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "MoldingScanner": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AreaScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnLinearScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnRandomScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedScannerAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OriginScannerAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "MoldingChildren": {
          "type": "boolean",
          "default": false
        },
        "LoadEntities": {
          "type": "boolean",
          "default": true
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedPathAsset": {
      "type": "object",
      "title": "WeightedPathAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedPathAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedPathAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "WeightedPathAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Weight": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Path": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "QueuePropAsset": {
      "type": "object",
      "title": "QueuePropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Queue\" to function as this type.",
          "const": "Queue"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another QueuePropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **QueuePropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Queue"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Queue": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/BoxPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ClusterPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ColumnPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DensityPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OffsetPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/PondFillerPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/PrefabPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/QueuePropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/UnionPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/WeightedPropAsset@1"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UnionPropAsset": {
      "type": "object",
      "title": "UnionPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Union\" to function as this type.",
          "const": "Union"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UnionPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UnionPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Union"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Props": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/BoxPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ClusterPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ColumnPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/DensityPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OffsetPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/PondFillerPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/PrefabPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/QueuePropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/UnionPropAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/WeightedPropAsset@1"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedPropAsset@1": {
      "type": "object",
      "title": "WeightedPropAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Weighted\" to function as this type.",
          "const": "Weighted"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedPropAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedPropAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropAsset",
            "mapKey": "Type",
            "mapKeyValue": "Weighted"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Entries": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/EntryAsset"
          }
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EntryAsset": {
      "type": "object",
      "title": "EntryAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EntryAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EntryAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "EntryAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Weight": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Prop": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BoxPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClusterPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ColumnPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PondFillerPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/PrefabPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/QueuePropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPropAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/WeightedPropAsset@1"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "FieldFunctionAssignmentsAsset": {
      "type": "object",
      "title": "FieldFunctionAssignmentsAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FieldFunction\" to function as this type.",
          "const": "FieldFunction"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FieldFunctionAssignmentsAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FieldFunctionAssignmentsAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "AssignmentsAsset",
            "mapKey": "Type",
            "mapKeyValue": "FieldFunction"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset@3"
          }
        },
        "FieldFunction": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset@3": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Assignments": {
          "anyOf": [
            {
              "$ref": "AssignmentsAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Min": {
          "type": "number",
          "default": 0
        },
        "Max": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ImportedAssignmentsAsset": {
      "type": "object",
      "title": "ImportedAssignmentsAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedAssignmentsAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedAssignmentsAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "AssignmentsAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SandwichAssignmentsAsset": {
      "type": "object",
      "title": "SandwichAssignmentsAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Sandwich\" to function as this type.",
          "const": "Sandwich"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SandwichAssignmentsAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SandwichAssignmentsAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "AssignmentsAsset",
            "mapKey": "Type",
            "mapKeyValue": "Sandwich"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset@4"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset@4": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Assignments": {
          "anyOf": [
            {
              "$ref": "AssignmentsAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "MinY": {
          "type": "number",
          "default": 0
        },
        "MaxY": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "WeightedAssignmentsAsset": {
      "type": "object",
      "title": "WeightedAssignmentsAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Weighted\" to function as this type.",
          "const": "Weighted"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedAssignmentsAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedAssignmentsAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "AssignmentsAsset",
            "mapKey": "Type",
            "mapKeyValue": "Weighted"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "SkipChance": {
          "type": "number",
          "default": 0
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "WeightedAssignments": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/WeightedAssets"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedAssets": {
      "type": "object",
      "title": "WeightedAssets",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedAssets most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedAssets** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "WeightedAssets"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Weight": {
          "type": "number",
          "default": 1
        },
        "Assignments": {
          "anyOf": [
            {
              "$ref": "AssignmentsAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "CombatBalanceAsset": {
      "type": "object",
      "title": "CombatBalanceAsset",
      "description": "A balance asset which also configures a combat action evaluator.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CombatActionEvaluator\" to function as this type.",
          "const": "CombatActionEvaluator"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CombatBalanceAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CombatBalanceAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "BalanceAsset",
            "mapKey": "Type",
            "mapKeyValue": "CombatActionEvaluator"
          }
        },
        "EntityEffect": {
          "description": "An entity effect to apply to the NPC at spawn time.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to EntityEffect"
            },
            {
              "$ref": "EntityEffect.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "TargetMemoryDuration": {
          "description": "How long the target should remain in the NPCs list of potential targets after last being spotted",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CombatActionEvaluator": {
          "description": "The combat action evaluator complete with combat action definitions and conditions.",
          "$ref": "common.schema.json#/$defs/CombatActionEvaluatorConfig"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CombatActionEvaluatorConfig": {
      "type": "object",
      "title": "CombatActionEvaluatorConfig",
      "properties": {
        "AvailableActions": {
          "type": "object",
          "description": "A map of all available combat actions this NPC can take.",
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to CombatActionOption"
              },
              {
                "$ref": "CombatActionOption.json#"
              }
            ]
          }
        },
        "ActionSets": {
          "type": "object",
          "description": "A mapping of all combat substate names to the basic attacks and abilities that should be used in them.",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/ActionSet"
          }
        },
        "RunConditions": {
          "type": "array",
          "description": "The list of conditions that determine whether or not the combat action evaluator should run.",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Condition"
              },
              {
                "$ref": "Condition.json#"
              }
            ]
          },
          "minItems": 1
        },
        "MinRunUtility": {
          "type": "number",
          "description": "The minimum utility score required to be returned from the RunConditions to trigger a new run of the combat action evaluator.",
          "minimum": 0.5,
          "maximum": 1,
          "default": 0.8
        },
        "MinActionUtility": {
          "type": "number",
          "description": "The minimum utility score required for any individual combat action to be run.",
          "minimum": 0,
          "maximum": 1,
          "default": 0.1
        },
        "PredictabilityRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "A random range from which to pick the NPC's predictability factor.",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        }
      },
      "additionalProperties": false
    },
    "ActionSet": {
      "type": "object",
      "title": "ActionSet",
      "properties": {
        "BasicAttacks": {
          "description": "The basic attacks to be used in this combat substate.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BasicAttacks"
            },
            {
              "type": "null"
            }
          ]
        },
        "Actions": {
          "type": "array",
          "description": "A list of available actions that should be used in this combat substate, mapped from AvailableActions.",
          "items": {
            "type": "string"
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "BasicAttacks": {
      "type": "object",
      "title": "BasicAttacks",
      "properties": {
        "Attacks": {
          "type": "array",
          "description": "The sequence of basic attacks to be used.",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to RootInteraction"
              },
              {
                "$ref": "RootInteraction.json#"
              }
            ]
          },
          "minItems": 1
        },
        "Randomise": {
          "type": "boolean",
          "description": "Whether or not the basic attacks should be executed randomly, or run in the order they were defined in.",
          "default": false
        },
        "MaxRange": {
          "type": "number",
          "description": "How close a target needs to be to use a basic attack against them.",
          "exclusiveMinimum": 0,
          "default": 0
        },
        "Timeout": {
          "description": "How long before giving up if a target moves out of range while preparing to execute a basic attack.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CooldownRange": {
          "type": "array",
          "description": "A random range to pick a cooldown between basic attacks from.",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        },
        "InteractionVars": {
          "type": [
            "object",
            "null"
          ],
          "description": "Interaction vars to modify the values in the interaction itself.",
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to RootInteraction"
              },
              {
                "$ref": "RootInteraction.json#"
              }
            ]
          }
        },
        "DamageFriendlies": {
          "type": "boolean",
          "description": "Whether or not basic attacks should be able to damage friendly targets.",
          "default": false
        },
        "UseProjectedDistance": {
          "type": "boolean",
          "description": "Whether to use projected distance instead of 3D distance for checking if in range of basic attacks.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "BalanceAsset": {
      "type": "object",
      "title": "BalanceAsset",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"Default\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "CombatActionEvaluator"
                ]
              }
            }
          ]
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BalanceAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BalanceAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "BalanceAsset"
          }
        },
        "EntityEffect": {
          "description": "An entity effect to apply to the NPC at spawn time.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to EntityEffect"
            },
            {
              "$ref": "EntityEffect.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RefreshInterval": {
      "type": "object",
      "title": "RefreshInterval",
      "properties": {
        "Days": {
          "type": "integer",
          "minimum": 1,
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "BarterTrade": {
      "type": "object",
      "title": "BarterTrade",
      "properties": {
        "Output": {
          "$ref": "common.schema.json#/$defs/BarterItemStack"
        },
        "Input": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/BarterItemStack"
          }
        },
        "Stock": {
          "type": "integer",
          "minimum": 1,
          "default": 10
        }
      },
      "additionalProperties": false
    },
    "BarterItemStack": {
      "type": "object",
      "title": "BarterItemStack",
      "properties": {
        "ItemId": {
          "type": "string"
        },
        "Quantity": {
          "type": "integer",
          "minimum": 1,
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "FixedTradeSlot": {
      "type": "object",
      "title": "FixedTradeSlot",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Fixed\" to function as this type.",
          "const": "Fixed"
        },
        "Trade": {
          "$ref": "common.schema.json#/$defs/BarterTrade"
        }
      },
      "additionalProperties": false
    },
    "PoolTradeSlot": {
      "type": "object",
      "title": "PoolTradeSlot",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Pool\" to function as this type.",
          "const": "Pool"
        },
        "SlotCount": {
          "type": "integer",
          "minimum": 1,
          "default": 1
        },
        "Trades": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/WeightedTrade"
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedTrade": {
      "type": "object",
      "title": "WeightedTrade",
      "properties": {
        "Weight": {
          "type": "number",
          "default": 100
        },
        "Output": {
          "$ref": "common.schema.json#/$defs/BarterItemStack"
        },
        "Input": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/BarterItemStack"
          }
        },
        "Stock": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "integer"
          }
        }
      },
      "additionalProperties": false
    },
    "RoleSpawnParameters": {
      "type": "object",
      "title": "RoleSpawnParameters",
      "description": "A set of parameters that configure spawning for a single NPC type.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "The Role ID of the NPC to spawn."
        },
        "Weight": {
          "type": "number",
          "description": "The relative weight of this NPC (chance of being spawned is this value relative to the sum of all weights).",
          "exclusiveMinimum": 0,
          "default": 0
        },
        "SpawnBlockSet": {
          "type": [
            "string",
            "null"
          ],
          "description": "An optional BlockSet reference that defines which blocks this NPC can spawn on."
        },
        "SpawnFluidTag": {
          "type": [
            "string",
            "null"
          ],
          "description": "An optional tag reference that defines which fluids this NPC can spawn on."
        },
        "Flock": {
          "description": "The optional flock definition to spawn around this NPC.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to FlockAsset"
            },
            {
              "$ref": "FlockAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "DespawnParameters": {
      "type": "object",
      "title": "DespawnParameters",
      "description": "A set of parameters that determine if NPCs should despawn.",
      "properties": {
        "DayTimeRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "An optional hour range within which the NPCs will despawn (between 0 and 24). For Spawn Beacons, this refers to the beacon itself.",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        },
        "MoonPhaseRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "An optional moon phase range during which the NPCs will despawn (must be greater than or equal to 0). For Spawn Beacons, this refers to the beacon itself.",
          "items": {
            "type": "integer"
          },
          "minItems": 2,
          "maxItems": 2
        }
      },
      "additionalProperties": false
    },
    "ScaledXYResponseCurve": {
      "type": "object",
      "title": "ScaledXYResponseCurve",
      "description": "A response curve that is scaled on both the x and y axes.",
      "properties": {
        "ResponseCurve": {
          "type": "string",
          "description": "The response curve to scale"
        },
        "XRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "The range to map the x axis to. e.g. [ 0, 10 ]",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        },
        "YRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "The range to map the y axis to. e.g. [ 0, 10 ]",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        }
      },
      "additionalProperties": false
    },
    "DensityTerrainAsset": {
      "type": "object",
      "title": "DensityTerrainAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DAOTerrain\" to function as this type.",
          "const": "DAOTerrain"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DensityTerrainAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DensityTerrainAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "TerrainAsset",
            "mapKey": "Type",
            "mapKeyValue": "DAOTerrain"
          }
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PropRuntimeAsset": {
      "type": "object",
      "title": "PropRuntimeAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PropRuntimeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PropRuntimeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PropRuntimeAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Runtime": {
          "type": "integer",
          "default": 0
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Assignments": {
          "anyOf": [
            {
              "$ref": "AssignmentsAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Skip": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "AnchorPositionProviderAsset": {
      "type": "object",
      "title": "AnchorPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Anchor\" to function as this type.",
          "const": "Anchor"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AnchorPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AnchorPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Anchor"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Reversed": {
          "type": "boolean",
          "default": false
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BaseHeightPositionProviderAsset": {
      "type": "object",
      "title": "BaseHeightPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BaseHeight\" to function as this type.",
          "const": "BaseHeight"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BaseHeightPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BaseHeightPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "BaseHeight"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "MinYRead": {
          "type": "number",
          "default": -1
        },
        "MaxYRead": {
          "type": "number",
          "default": 1
        },
        "BedName": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CachedPositionProviderAsset": {
      "type": "object",
      "title": "CachedPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cache\" to function as this type.",
          "const": "Cache"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CachedPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CachedPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cache"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "SectionSize": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 32
        },
        "CacheSize": {
          "type": "integer",
          "exclusiveMinimum": -1,
          "default": 100
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FieldFunctionPositionProviderAsset": {
      "type": "object",
      "title": "FieldFunctionPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FieldFunction\" to function as this type.",
          "const": "FieldFunction"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FieldFunctionPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FieldFunctionPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "FieldFunction"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset@5"
          }
        },
        "FieldFunction": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset@5": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Min": {
          "type": "number",
          "default": 0
        },
        "Max": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ImportedPositionProviderAsset": {
      "type": "object",
      "title": "ImportedPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ListPositionProviderAsset": {
      "type": "object",
      "title": "ListPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"List\" to function as this type.",
          "const": "List"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ListPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ListPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "List"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Positions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/PositionAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PositionAsset": {
      "type": "object",
      "title": "PositionAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PositionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PositionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "X": {
          "type": "integer",
          "default": 0
        },
        "Y": {
          "type": "integer",
          "default": 0
        },
        "Z": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "Mesh2DPositionProviderAsset": {
      "type": "object",
      "title": "Mesh2DPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Mesh2D\" to function as this type.",
          "const": "Mesh2D"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Mesh2DPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Mesh2DPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Mesh2D"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "PointGenerator": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/MeshPointGeneratorAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "PointsY": {
          "type": "integer",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MeshPointGeneratorAsset": {
      "type": "object",
      "title": "MeshPointGeneratorAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Mesh\" to function as this type.",
          "const": "Mesh"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MeshPointGeneratorAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MeshPointGeneratorAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PointGeneratorAsset",
            "mapKey": "Type",
            "mapKeyValue": "Mesh"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Jitter": {
          "type": "number",
          "minimum": 0,
          "maximum": 0.5,
          "default": 0.35
        },
        "ScaleX": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ScaleY": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ScaleZ": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Mesh3DPositionProviderAsset": {
      "type": "object",
      "title": "Mesh3DPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Mesh3D\" to function as this type.",
          "const": "Mesh3D"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Mesh3DPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Mesh3DPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Mesh3D"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "PointGenerator": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/MeshPointGeneratorAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FieldFunctionOccurrencePositionProviderAsset": {
      "type": "object",
      "title": "FieldFunctionOccurrencePositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Occurrence\" to function as this type.",
          "const": "Occurrence"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FieldFunctionOccurrencePositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FieldFunctionOccurrencePositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Occurrence"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "FieldFunction": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OffsetPositionProviderAsset": {
      "type": "object",
      "title": "OffsetPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Offset\" to function as this type.",
          "const": "Offset"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OffsetPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OffsetPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Offset"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "OffsetX": {
          "type": "integer",
          "default": 0
        },
        "OffsetY": {
          "type": "integer",
          "default": 0
        },
        "OffsetZ": {
          "type": "integer",
          "default": 0
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SimpleHorizontalPositionProviderAsset": {
      "type": "object",
      "title": "SimpleHorizontalPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SimpleHorizontal\" to function as this type.",
          "const": "SimpleHorizontal"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SimpleHorizontalPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SimpleHorizontalPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "SimpleHorizontal"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "RangeY": {
          "anyOf": [
            {
              "default": {
                "MinInclusive": 0,
                "MaxExclusive": 0
              },
              "$ref": "common.schema.json#/$defs/RangeDoubleAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RangeDoubleAsset": {
      "type": "object",
      "title": "RangeDoubleAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RangeDoubleAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RangeDoubleAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "RangeDoubleAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "MinInclusive": {
          "type": "number",
          "default": 0
        },
        "MaxExclusive": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "SpherePositionProviderAsset": {
      "type": "object",
      "title": "SpherePositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Sphere\" to function as this type.",
          "const": "Sphere"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SpherePositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SpherePositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Sphere"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Range": {
          "type": "number",
          "default": 0
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UnionPositionProviderAsset": {
      "type": "object",
      "title": "UnionPositionProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Union\" to function as this type.",
          "const": "Union"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UnionPositionProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UnionPositionProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PositionProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Union"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Positions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConstantEnvironmentProviderAsset": {
      "type": "object",
      "title": "ConstantEnvironmentProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Constant\" to function as this type.",
          "const": "Constant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantEnvironmentProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantEnvironmentProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "EnvironmentProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Constant"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Environment": {
          "type": [
            "string",
            "null"
          ],
          "default": "Unknown"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DensityDelimitedEnvironmentProviderAsset": {
      "type": "object",
      "title": "DensityDelimitedEnvironmentProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DensityDelimited\" to function as this type.",
          "const": "DensityDelimited"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DensityDelimitedEnvironmentProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DensityDelimitedEnvironmentProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "EnvironmentProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "DensityDelimited"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset@6"
          }
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset@6": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Range": {
          "anyOf": [
            {
              "default": {
                "MinInclusive": 0,
                "MaxExclusive": 0
              },
              "$ref": "common.schema.json#/$defs/RangeDoubleAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Environment": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantEnvironmentProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityDelimitedEnvironmentProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ConstantTintProviderAsset": {
      "type": "object",
      "title": "ConstantTintProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Constant\" to function as this type.",
          "const": "Constant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantTintProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantTintProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "TintProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Constant"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Color": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DensityDelimitedTintProviderAsset": {
      "type": "object",
      "title": "DensityDelimitedTintProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DensityDelimited\" to function as this type.",
          "const": "DensityDelimited"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DensityDelimitedTintProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DensityDelimitedTintProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "TintProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "DensityDelimited"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset@7"
          }
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset@7": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Range": {
          "anyOf": [
            {
              "default": {
                "MinInclusive": 0,
                "MaxExclusive": 0
              },
              "$ref": "common.schema.json#/$defs/RangeDoubleAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tint": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConstantTintProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityDelimitedTintProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Box": {
      "type": "object",
      "title": "Box",
      "properties": {
        "Min": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Max": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Vector3d": {
      "type": "object",
      "title": "Vector3d",
      "properties": {
        "X": {
          "type": "number",
          "default": 0
        },
        "Y": {
          "type": "number",
          "default": 0
        },
        "Z": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "BlockMaskEntryAsset": {
      "type": "object",
      "title": "BlockMaskEntryAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BlockMaskEntryAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BlockMaskEntryAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "BlockMaskEntryAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Source": {
          "anyOf": [
            {
              "default": {
                "Inclusive": true,
                "Materials": []
              },
              "$ref": "common.schema.json#/$defs/MaterialSetAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "CanReplace": {
          "anyOf": [
            {
              "default": {
                "Inclusive": true,
                "Materials": []
              },
              "$ref": "common.schema.json#/$defs/MaterialSetAsset"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Vector3f": {
      "type": "object",
      "title": "Vector3f",
      "properties": {
        "X": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Y": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Z": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "Direction": {
      "type": "object",
      "title": "Direction",
      "properties": {
        "Yaw": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Pitch": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Roll": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "BlockSpawnerEntry": {
      "type": "object",
      "title": "BlockSpawnerEntry",
      "properties": {
        "Name": {
          "type": [
            "string",
            "null"
          ]
        },
        "RotationMode": {
          "type": [
            "string",
            "null"
          ],
          "title": "RotationMode",
          "enum": [
            "None",
            "Random",
            "Inherit"
          ],
          "default": "Inherit"
        },
        "Weight": {
          "type": "number",
          "default": 0
        },
        "State": {
          "type": [
            "object",
            "null"
          ]
        },
        "Components": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Holder"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Holder": {
      "type": "object",
      "title": "Holder",
      "properties": {
        "Components": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "Block": {
              "type": "object",
              "title": "BlockSection",
              "properties": {
                "Version": {
                  "type": "integer"
                },
                "Data": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$"
                }
              },
              "additionalProperties": false
            },
            "BlockChunk": {
              "type": "object",
              "title": "BlockChunk",
              "properties": {
                "Version": {
                  "type": "integer"
                },
                "Data": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$"
                }
              },
              "additionalProperties": false
            },
            "BlockComponentChunk": {
              "type": "object",
              "title": "BlockComponentChunk",
              "properties": {
                "BlockComponents": {
                  "type": [
                    "object",
                    "null"
                  ],
                  "additionalProperties": {
                    "$ref": "common.schema.json#/$defs/Holder"
                  },
                  "propertyNames": {
                    "description": "A string that contains any integer",
                    "pattern": "^[0-9]+$"
                  }
                }
              },
              "additionalProperties": false
            },
            "BlockHealthChunk": {
              "type": "object",
              "title": "BlockHealthChunk",
              "properties": {
                "Data": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "Binary",
                  "description": "Binary data representing the state of this BlockHealthChunk",
                  "pattern": "^[0-9a-zA-Z+/]+$"
                },
                "LastRepairGameTime": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "The last tick of the world this BlockHealthChunk processed."
                }
              },
              "additionalProperties": false
            },
            "BlockMapMarker": {
              "type": "object",
              "title": "BlockMapMarker",
              "properties": {
                "Name": {
                  "type": "string"
                },
                "Icon": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            "BlockPhysics": {
              "type": "object",
              "title": "BlockPhysics",
              "properties": {
                "Version": {
                  "type": "integer"
                },
                "Data": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$"
                }
              },
              "additionalProperties": false
            },
            "BlockSpawner": {
              "type": "object",
              "title": "BlockSpawner",
              "properties": {
                "BlockSpawnerId": {
                  "type": [
                    "string",
                    "null"
                  ]
                }
              },
              "additionalProperties": false
            },
            "BlockStateChunk": {
              "type": "object",
              "title": "LegacyBlockStateChunk",
              "properties": {},
              "additionalProperties": false
            },
            "ChunkColumn": {
              "type": "object",
              "title": "ChunkColumn",
              "properties": {
                "Sections": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "common.schema.json#/$defs/Holder"
                  }
                }
              },
              "additionalProperties": false
            },
            "ChunkSection": {
              "type": "object",
              "title": "ChunkSection",
              "properties": {},
              "additionalProperties": false
            },
            "ChunkSpawnedNPCData": {
              "type": "object",
              "title": "ChunkSpawnedNPCData",
              "properties": {
                "EnvironmentSpawnCounts": {
                  "type": [
                    "object",
                    "null"
                  ],
                  "title": "Map of string to double",
                  "additionalProperties": {
                    "type": "number"
                  }
                }
              },
              "additionalProperties": false
            },
            "Coop": {
              "type": "object",
              "title": "CoopBlock",
              "properties": {
                "FarmingCoopId": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "Residents": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "common.schema.json#/$defs/CoopResident"
                  }
                },
                "Storage": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/EmptyItemContainer"
                    },
                    {
                      "$ref": "common.schema.json#/$defs/SimpleItemContainer"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              },
              "additionalProperties": false
            },
            "EntityChunk": {
              "type": "object",
              "title": "EntityChunk",
              "properties": {
                "Entities": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "common.schema.json#/$defs/Holder"
                  }
                }
              },
              "additionalProperties": false
            },
            "EnvironmentChunk": {
              "type": "object",
              "title": "EnvironmentChunk",
              "properties": {
                "Data": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$"
                }
              },
              "additionalProperties": false
            },
            "Farming": {
              "type": "object",
              "title": "FarmingBlockState",
              "properties": {
                "BaseCrop": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "StageStart": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "CurrentFarmingStageIndex": {
                  "type": "integer",
                  "default": 0
                },
                "CurrentFarmingStageSetName": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "SpreadRate": {
                  "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
                }
              },
              "additionalProperties": false
            },
            "FarmingBlock": {
              "type": "object",
              "title": "FarmingBlock",
              "properties": {
                "CurrentStageSet": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "GrowthProgress": {
                  "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
                },
                "LastTickGameTime": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "Generation": {
                  "type": "integer"
                },
                "PreviousBlockType": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "SpreadRate": {
                  "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
                },
                "Executions": {
                  "type": "integer"
                }
              },
              "additionalProperties": false
            },
            "Fluid": {
              "type": "object",
              "title": "FluidSection",
              "properties": {
                "Version": {
                  "type": "integer"
                },
                "Data": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$"
                }
              },
              "additionalProperties": false
            },
            "Instance": {
              "type": "object",
              "title": "InstanceBlock",
              "properties": {
                "WorldName": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "UUID Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$",
                  "minLength": 24,
                  "maxLength": 24
                },
                "CloseOnBlockRemove": {
                  "type": "boolean",
                  "default": true
                }
              },
              "additionalProperties": false
            },
            "InstanceConfig": {
              "type": "object",
              "title": "ConfigurableInstanceBlock",
              "properties": {
                "WorldName": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "UUID Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$",
                  "minLength": 24,
                  "maxLength": 24
                },
                "CloseOnBlockRemove": {
                  "type": "boolean",
                  "default": true
                },
                "InstanceName": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "InstanceKey": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "PositionOffset": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Vector3d"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "Rotation": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Vector3f@1"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "PersonalReturnPoint": {
                  "type": "boolean",
                  "default": false
                },
                "RemoveBlockAfter": {
                  "type": "number",
                  "default": -1
                }
              },
              "additionalProperties": false
            },
            "LaunchPad": {
              "type": "object",
              "title": "LaunchPad",
              "properties": {
                "VelocityX": {
                  "type": "number",
                  "description": "The X velocity of the launch pad.",
                  "default": 0
                },
                "VelocityY": {
                  "type": "number",
                  "description": "The Y velocity of the launch pad.",
                  "default": 0
                },
                "VelocityZ": {
                  "type": "number",
                  "description": "The Z velocity of the launch pad.",
                  "default": 0
                },
                "PlayersOnly": {
                  "type": "boolean",
                  "description": "Determines whether only players can use this launch pad.",
                  "default": false
                }
              },
              "additionalProperties": false
            },
            "PlacedByInteraction": {
              "type": "object",
              "title": "PlacedByInteractionComponent",
              "properties": {
                "WhoPlacedUuid": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "UUID Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$",
                  "minLength": 24,
                  "maxLength": 24
                }
              },
              "additionalProperties": false
            },
            "Portal": {
              "type": "object",
              "title": "PortalDevice",
              "properties": {
                "Config": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/PortalDeviceConfig"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "BaseBlockType": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "DestinationWorld": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "UUID Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$",
                  "minLength": 24,
                  "maxLength": 24
                }
              },
              "additionalProperties": false
            },
            "RespawnBlock": {
              "type": "object",
              "title": "RespawnBlock",
              "properties": {
                "OwnerUUID": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "UUID Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$",
                  "minLength": 24,
                  "maxLength": 24
                }
              },
              "additionalProperties": false
            },
            "SpawnMarkerBlock": {
              "type": "object",
              "title": "SpawnMarkerBlockState",
              "properties": {
                "Position": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Vector3i"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "MarkerReference": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/PersistentRef"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              },
              "additionalProperties": false
            },
            "Teleporter": {
              "type": "object",
              "title": "Teleporter",
              "properties": {
                "World": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "UUID Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$",
                  "minLength": 24,
                  "maxLength": 24
                },
                "Transform": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Transform"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "Relative": {
                  "type": "integer",
                  "default": 0
                },
                "Warp": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "OwnedWarp": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "IsCustomName": {
                  "type": "boolean",
                  "default": false
                },
                "WarpNameWordList": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "The ID of the Word list to select default warp names from"
                }
              },
              "additionalProperties": false
            },
            "TilledSoil": {
              "type": "object",
              "title": "TilledSoilBlock",
              "properties": {
                "Version": {
                  "type": "integer"
                },
                "Planted": {
                  "type": "boolean"
                },
                "ModifierTimes": {
                  "type": [
                    "object",
                    "null"
                  ],
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "Flags": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "type": "string"
                  }
                },
                "Fertilized": {
                  "type": "boolean"
                },
                "ExternalWater": {
                  "type": "boolean"
                },
                "WateredUntil": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "DecayTime": {
                  "type": [
                    "string",
                    "null"
                  ]
                }
              },
              "additionalProperties": false
            },
            "TrackedPlacement": {
              "type": "object",
              "title": "TrackedPlacement",
              "properties": {
                "BlockName": {
                  "type": [
                    "string",
                    "null"
                  ]
                }
              },
              "additionalProperties": false
            },
            "TreasureChest": {
              "type": "object",
              "title": "TreasureChestState",
              "properties": {
                "Position": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Vector3i"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "ObjectiveUUID": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "UUID Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$",
                  "minLength": 24,
                  "maxLength": 24
                },
                "ChestUUID": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "title": "UUID Binary",
                  "pattern": "^[0-9a-zA-Z+/]+$",
                  "minLength": 24,
                  "maxLength": 24
                },
                "Opened": {
                  "type": "boolean",
                  "default": false
                }
              },
              "additionalProperties": false
            },
            "Unknown": {
              "type": "object",
              "title": "UnknownComponents",
              "properties": {
                "Components": {
                  "type": [
                    "object",
                    "null"
                  ],
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              },
              "additionalProperties": false
            },
            "WorldChunk": {
              "type": "object",
              "title": "WorldChunk",
              "properties": {},
              "additionalProperties": false
            },
            "container": {
              "type": "object",
              "title": "ItemContainerState",
              "properties": {
                "Position": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Vector3i"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "Custom": {
                  "type": "boolean",
                  "default": false
                },
                "AllowViewing": {
                  "type": "boolean",
                  "default": true
                },
                "Droplist": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "Marker": {
                  "type": [
                    "object",
                    "null"
                  ],
                  "additionalProperties": false
                },
                "ItemContainer": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/SimpleItemContainer"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              },
              "additionalProperties": false
            },
            "crafting": {
              "type": "object",
              "title": "BenchState",
              "properties": {
                "Position": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Vector3i"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "TierLevel": {
                  "type": "integer",
                  "default": 1
                },
                "UpgradeItems": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "common.schema.json#/$defs/ItemStack"
                  }
                }
              },
              "additionalProperties": false
            },
            "prefabspawner": {
              "type": "object",
              "title": "PrefabSpawnerState",
              "properties": {
                "Position": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Vector3i"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "PrefabPath": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "The prefab path where the prefab is located. This uses the dot-notation. 'folder.folder.folder.filename'"
                },
                "FitHeightmap": {
                  "type": "boolean",
                  "description": "Determines if the child prefab should follow the heightmap during generation in worldgen.",
                  "default": false
                },
                "InheritSeed": {
                  "type": "boolean",
                  "description": "Determines if the child prefab should inherit the worldgen-id from the parent. This allows child prefabs to have independent markers.",
                  "default": true
                },
                "InheritHeightCondition": {
                  "type": "boolean",
                  "description": "Determines if the child prefab should inherit the HeightCondition from the parent. Setting to false allows child prefabs to bypass the height condition check.",
                  "default": true
                },
                "PrefabWeights": {
                  "description": "Determines the probability of each individual prefab file being selected to generate when the PrefabPath points to a folder containing multiple prefabs.",
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/PrefabWeights"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              },
              "additionalProperties": false
            },
            "processingBench": {
              "type": "object",
              "title": "ProcessingBenchState",
              "properties": {
                "Position": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/Vector3i"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "TierLevel": {
                  "type": "integer",
                  "default": 1
                },
                "UpgradeItems": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "$ref": "common.schema.json#/$defs/ItemStack"
                  }
                },
                "InputContainer": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/EmptyItemContainer"
                    },
                    {
                      "$ref": "common.schema.json#/$defs/SimpleItemContainer"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "FuelContainer": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/EmptyItemContainer"
                    },
                    {
                      "$ref": "common.schema.json#/$defs/SimpleItemContainer"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "OutputContainer": {
                  "anyOf": [
                    {
                      "$ref": "common.schema.json#/$defs/EmptyItemContainer"
                    },
                    {
                      "$ref": "common.schema.json#/$defs/SimpleItemContainer"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "Progress": {
                  "type": "number",
                  "default": 0
                },
                "FuelTime": {
                  "type": "number",
                  "default": 0
                },
                "Active": {
                  "type": "boolean",
                  "default": false
                },
                "NextExtra": {
                  "type": "integer",
                  "default": -1
                },
                "Marker": {
                  "type": [
                    "object",
                    "null"
                  ],
                  "additionalProperties": false
                },
                "RecipeId": {
                  "type": [
                    "string",
                    "null"
                  ]
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "PrefabWeights": {
      "type": "object",
      "title": "PrefabWeights",
      "properties": {
        "Default": {
          "type": "number",
          "description": "The default weight to use for entries that are not specifically mapped to a weight value.",
          "minimum": 0,
          "default": 1
        },
        "Weights": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of string to double",
          "description": "The mapping of prefab names to weight values.",
          "additionalProperties": {
            "type": "number"
          }
        }
      },
      "additionalProperties": false
    },
    "ItemStack": {
      "type": "object",
      "title": "ItemStack",
      "properties": {
        "Id": {
          "type": "string"
        },
        "Quantity": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Durability": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "MaxDurability": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "Metadata": {
          "type": [
            "object",
            "null"
          ]
        },
        "OverrideDroppedItemAnimation": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "PortalDeviceConfig": {
      "type": "object",
      "title": "PortalDeviceConfig",
      "properties": {
        "SpawningState": {
          "type": [
            "string",
            "null"
          ],
          "description": "The StateData for the short transition from off to on, when the instance is being created",
          "default": "Spawning"
        },
        "OnState": {
          "type": [
            "string",
            "null"
          ],
          "description": "The StateData when the portal is summoned and active.",
          "default": "Active"
        },
        "OffState": {
          "type": [
            "string",
            "null"
          ],
          "description": "The StateData when there is no portal and the device is inactive.",
          "default": "default"
        },
        "ReturnBlockType": {
          "type": [
            "string",
            "null"
          ],
          "description": "This block type will be placed (once) on the spawn point of the portal world."
        }
      },
      "additionalProperties": false
    },
    "PersistentRef": {
      "type": "object",
      "title": "PersistentRef",
      "properties": {
        "UUID": {
          "type": [
            "string",
            "null"
          ],
          "title": "UUID Binary",
          "pattern": "^[0-9a-zA-Z+/]+$",
          "minLength": 24,
          "maxLength": 24
        }
      },
      "additionalProperties": false
    },
    "Transform": {
      "type": "object",
      "title": "Transform",
      "properties": {
        "X": {
          "type": "number",
          "default": 0
        },
        "Y": {
          "type": "number",
          "default": 0
        },
        "Z": {
          "type": "number",
          "default": 0
        },
        "Pitch": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Yaw": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Roll": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "SimpleItemContainer": {
      "type": "object",
      "title": "SimpleItemContainer",
      "properties": {
        "Id": {
          "description": "This field controls the type, it must be set to the constant value \"Simple\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "Empty"
                ]
              }
            }
          ]
        },
        "Capacity": {
          "type": "integer",
          "minimum": 0
        },
        "Items": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/ItemStack"
          },
          "propertyNames": {
            "description": "A string that contains any integer",
            "pattern": "^[0-9]+$"
          }
        }
      },
      "additionalProperties": false
    },
    "CoopResident": {
      "type": "object",
      "title": "CoopResident",
      "properties": {
        "Metadata": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CapturedNPCMetadata"
            },
            {
              "type": "null"
            }
          ]
        },
        "PersistentRef": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/PersistentRef"
            },
            {
              "type": "null"
            }
          ]
        },
        "DeployedToWorld": {
          "type": "boolean",
          "default": false
        },
        "LastHarvested": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "CapturedNPCMetadata": {
      "type": "object",
      "title": "CapturedNPCMetadata",
      "properties": {
        "IconPath": {
          "type": [
            "string",
            "null"
          ]
        },
        "RoleIndex": {
          "type": "integer",
          "default": 0
        },
        "NpcNameKey": {
          "type": [
            "string",
            "null"
          ]
        },
        "FullItemIcon": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "EmptyItemContainer": {
      "type": "object",
      "title": "EmptyItemContainer",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Empty\" to function as this type.",
          "const": "Empty"
        }
      },
      "additionalProperties": false
    },
    "Vector3f@1": {
      "type": "object",
      "title": "Vector3f",
      "properties": {
        "Pitch": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Yaw": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Roll": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "BlockTypeTextures": {
      "type": "object",
      "title": "BlockTypeTextures",
      "properties": {
        "All": {
          "type": [
            "string",
            "null"
          ]
        },
        "Sides": {
          "type": [
            "string",
            "null"
          ]
        },
        "UpDown": {
          "type": [
            "string",
            "null"
          ]
        },
        "Up": {
          "type": [
            "string",
            "null"
          ],
          "default": "BlockTextures/Unknown.png"
        },
        "Down": {
          "type": [
            "string",
            "null"
          ],
          "default": "BlockTextures/Unknown.png"
        },
        "North": {
          "type": [
            "string",
            "null"
          ],
          "default": "BlockTextures/Unknown.png"
        },
        "South": {
          "type": [
            "string",
            "null"
          ],
          "default": "BlockTextures/Unknown.png"
        },
        "West": {
          "type": [
            "string",
            "null"
          ],
          "default": "BlockTextures/Unknown.png"
        },
        "East": {
          "type": [
            "string",
            "null"
          ],
          "default": "BlockTextures/Unknown.png"
        },
        "Weight": {
          "type": "integer",
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "CustomModelTexture": {
      "type": "object",
      "title": "CustomModelTexture",
      "properties": {
        "Texture": {
          "type": [
            "string",
            "null"
          ]
        },
        "Weight": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ColorLight": {
      "type": "object",
      "title": "ColorLight",
      "properties": {
        "Color": {
          "type": [
            "string",
            "null"
          ],
          "default": "#000000"
        },
        "Radius": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "BasicChanceBlockGrowthProcedure": {
      "type": "object",
      "title": "BasicChanceBlockGrowthProcedure",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BasicChance\" to function as this type.",
          "const": "BasicChance"
        },
        "NextId": {
          "type": [
            "string",
            "null"
          ]
        },
        "ChanceMin": {
          "type": "integer",
          "default": 0
        },
        "Chance": {
          "type": "integer",
          "default": 0
        },
        "NextTicking": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "SplitChanceBlockGrowthProcedure": {
      "type": "object",
      "title": "SplitChanceBlockGrowthProcedure",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SplitChance\" to function as this type.",
          "const": "SplitChance"
        },
        "NextIds": {
          "type": "object"
        },
        "ChanceMin": {
          "type": "integer",
          "default": 0
        },
        "Data": {
          "type": "integer",
          "default": 0
        },
        "NextTicking": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "CustomTemplateConnectedBlockRuleSet": {
      "type": "object",
      "title": "CustomTemplateConnectedBlockRuleSet",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CustomTemplate\" to function as this type.",
          "const": "CustomTemplate"
        },
        "TemplateShapeAssetId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of a ConnectedBlockTemplateAsset asset"
        },
        "TemplateShapeBlockPatterns": {
          "type": [
            "object",
            "null"
          ],
          "description": "You must specify all shapes as a BlockPattern. The shapes are as outlined in the keys of the ShapeTemplateAsset's map.",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "RoofConnectedBlockRuleSet": {
      "type": "object",
      "title": "RoofConnectedBlockRuleSet",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Roof\" to function as this type.",
          "const": "Roof"
        },
        "Regular": {
          "$ref": "common.schema.json#/$defs/StairConnectedBlockRuleSet"
        },
        "Hollow": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/StairConnectedBlockRuleSet"
            },
            {
              "type": "null"
            }
          ]
        },
        "Topper": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConnectedBlockOutput"
            },
            {
              "type": "null"
            }
          ]
        },
        "Width": {
          "type": "integer",
          "default": 1
        },
        "MaterialName": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "StairConnectedBlockRuleSet": {
      "type": "object",
      "title": "StairConnectedBlockRuleSet",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Stair\" to function as this type.",
          "const": "Stair"
        },
        "Straight": {
          "$ref": "common.schema.json#/$defs/ConnectedBlockOutput"
        },
        "Corner_Left": {
          "$ref": "common.schema.json#/$defs/ConnectedBlockOutput"
        },
        "Corner_Right": {
          "$ref": "common.schema.json#/$defs/ConnectedBlockOutput"
        },
        "Inverted_Corner_Left": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConnectedBlockOutput"
            },
            {
              "type": "null"
            }
          ]
        },
        "Inverted_Corner_Right": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConnectedBlockOutput"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaterialName": {
          "type": [
            "string",
            "null"
          ],
          "default": "Stair"
        }
      },
      "additionalProperties": false
    },
    "ConnectedBlockOutput": {
      "type": "object",
      "title": "ConnectedBlockOutput",
      "properties": {
        "State": {
          "type": [
            "string",
            "null"
          ],
          "description": "An optional state definition to apply to the base block type"
        },
        "Block": {
          "type": [
            "string",
            "null"
          ],
          "description": "An optional block ID to use instead of the base block type"
        }
      },
      "additionalProperties": false
    },
    "ModelParticle": {
      "type": "object",
      "title": "ModelParticle",
      "properties": {
        "SystemId": {
          "type": "string"
        },
        "TargetEntityPart": {
          "type": "string",
          "title": "EntityPart",
          "enum": [
            "Self",
            "Entity",
            "PrimaryItem",
            "SecondaryItem"
          ],
          "default": "Self"
        },
        "TargetNodeName": {
          "type": [
            "string",
            "null"
          ]
        },
        "Color": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scale": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "PositionOffset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "RotationOffset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Direction"
            },
            {
              "type": "null"
            }
          ]
        },
        "DetachedFromModel": {
          "type": "boolean",
          "description": "To indicate if the spawned particle should be attached to the model and follow it, or spawn in world space.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "BlockMountPoint": {
      "type": "object",
      "title": "BlockMountPoint",
      "properties": {
        "Offset": {
          "description": "Relative offset from the block center (the point at .5,.5,.5 in world). Forward on a chair is 0,0,0.3",
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3f@1"
            },
            {
              "type": "null"
            }
          ]
        },
        "Yaw": {
          "type": "number",
          "description": "Offset for the model sitting on this seat in DEGREES",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "BlockMovementSettings": {
      "type": "object",
      "title": "BlockMovementSettings",
      "properties": {
        "IsClimbable": {
          "type": "boolean",
          "default": false
        },
        "IsBouncy": {
          "type": "boolean",
          "default": false
        },
        "BounceVelocity": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ClimbUpSpeedMultiplier": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ClimbDownSpeedMultiplier": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ClimbLateralSpeedMultiplier": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Drag": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Friction": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "TerminalVelocityModifier": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "HorizontalSpeedMultiplier": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "JumpForceMultiplier": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "BlockFlags": {
      "type": "object",
      "title": "BlockFlags",
      "properties": {
        "IsUsable": {
          "type": "boolean",
          "default": false
        },
        "IsStackable": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "CraftingBench": {
      "type": "object",
      "title": "CraftingBench",
      "properties": {
        "Type": {
          "type": "string",
          "title": "BenchType",
          "description": "This field controls the type, it must be set to the constant value \"Crafting\" to function as this type.",
          "enum": [
            "Crafting",
            "Processing",
            "DiagramCrafting",
            "StructuralCrafting"
          ],
          "const": "Crafting"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ]
        },
        "DescriptiveLabel": {
          "type": [
            "string",
            "null"
          ]
        },
        "TierLevels": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/BenchTierLevel"
          }
        },
        "LocalOpenSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "LocalCloseSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "CompletedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "FailedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BenchUpgradeSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BenchUpgradeCompletedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Categories": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/BenchCategory"
          }
        }
      },
      "additionalProperties": false
    },
    "BenchTierLevel": {
      "type": "object",
      "title": "BenchTierLevel",
      "properties": {
        "UpgradeRequirement": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BenchUpgradeRequirement"
            },
            {
              "type": "null"
            }
          ]
        },
        "CraftingTimeReductionModifier": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "ExtraInputSlot": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "ExtraOutputSlot": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "BenchUpgradeRequirement": {
      "type": "object",
      "title": "BenchUpgradeRequirement",
      "properties": {
        "Material": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/MaterialQuantity"
          }
        },
        "TimeSeconds": {
          "type": "number",
          "minimum": 0,
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "MaterialQuantity": {
      "type": "object",
      "title": "MaterialQuantity",
      "properties": {
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "ResourceTypeId": {
          "type": [
            "string",
            "null"
          ]
        },
        "ItemTag": {
          "type": [
            "string",
            "null"
          ]
        },
        "Quantity": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Metadata": {
          "type": [
            "object",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "BenchCategory": {
      "type": "object",
      "title": "BenchCategory",
      "properties": {
        "Id": {
          "type": [
            "string",
            "null"
          ]
        },
        "Name": {
          "type": [
            "string",
            "null"
          ]
        },
        "Icon": {
          "type": [
            "string",
            "null"
          ]
        },
        "ItemCategories": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/BenchItemCategory"
          }
        }
      },
      "additionalProperties": false
    },
    "BenchItemCategory": {
      "type": "object",
      "title": "BenchItemCategory",
      "properties": {
        "Id": {
          "type": [
            "string",
            "null"
          ]
        },
        "Name": {
          "type": [
            "string",
            "null"
          ]
        },
        "Icon": {
          "type": [
            "string",
            "null"
          ]
        },
        "Diagram": {
          "type": [
            "string",
            "null"
          ]
        },
        "Slots": {
          "type": "integer",
          "default": 1
        },
        "SpecialSlot": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "ProcessingBench": {
      "type": "object",
      "title": "ProcessingBench",
      "properties": {
        "Type": {
          "type": "string",
          "title": "BenchType",
          "description": "This field controls the type, it must be set to the constant value \"Processing\" to function as this type.",
          "enum": [
            "Crafting",
            "Processing",
            "DiagramCrafting",
            "StructuralCrafting"
          ],
          "const": "Processing"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ]
        },
        "DescriptiveLabel": {
          "type": [
            "string",
            "null"
          ]
        },
        "TierLevels": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/BenchTierLevel"
          }
        },
        "LocalOpenSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "LocalCloseSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "CompletedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "FailedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BenchUpgradeSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BenchUpgradeCompletedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Input": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/ProcessingSlot"
          }
        },
        "Fuel": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ProcessingSlot"
          }
        },
        "MaxFuel": {
          "type": "integer",
          "default": -1
        },
        "FuelDropItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "OutputSlotsCount": {
          "type": "integer",
          "minimum": 1,
          "default": 1
        },
        "ExtraOutput": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ExtraOutput"
            },
            {
              "type": "null"
            }
          ]
        },
        "AllowNoInputProcessing": {
          "type": "boolean",
          "default": false
        },
        "IconItem": {
          "type": [
            "string",
            "null"
          ]
        },
        "Icon": {
          "type": [
            "string",
            "null"
          ]
        },
        "IconName": {
          "type": [
            "string",
            "null"
          ]
        },
        "IconId": {
          "type": [
            "string",
            "null"
          ]
        },
        "EndSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "ProcessingSlot": {
      "type": "object",
      "title": "ProcessingSlot",
      "properties": {
        "Icon": {
          "type": [
            "string",
            "null"
          ]
        },
        "ResourceTypeId": {
          "type": [
            "string",
            "null"
          ]
        },
        "FilterValidIngredients": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "ExtraOutput": {
      "type": "object",
      "title": "ExtraOutput",
      "properties": {
        "Outputs": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/MaterialQuantity"
          }
        },
        "PerFuelItemsConsumed": {
          "type": "integer",
          "minimum": 1,
          "default": 1
        },
        "IgnoredFuelSources": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/MaterialQuantity"
          }
        }
      },
      "additionalProperties": false
    },
    "DiagramCraftingBench": {
      "type": "object",
      "title": "DiagramCraftingBench",
      "properties": {
        "Type": {
          "type": "string",
          "title": "BenchType",
          "description": "This field controls the type, it must be set to the constant value \"DiagramCrafting\" to function as this type.",
          "enum": [
            "Crafting",
            "Processing",
            "DiagramCrafting",
            "StructuralCrafting"
          ],
          "const": "DiagramCrafting"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ]
        },
        "DescriptiveLabel": {
          "type": [
            "string",
            "null"
          ]
        },
        "TierLevels": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/BenchTierLevel"
          }
        },
        "LocalOpenSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "LocalCloseSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "CompletedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "FailedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BenchUpgradeSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BenchUpgradeCompletedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Categories": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/BenchCategory"
          }
        }
      },
      "additionalProperties": false
    },
    "StructuralCraftingBench": {
      "type": "object",
      "title": "StructuralCraftingBench",
      "properties": {
        "Type": {
          "type": "string",
          "title": "BenchType",
          "description": "This field controls the type, it must be set to the constant value \"StructuralCrafting\" to function as this type.",
          "enum": [
            "Crafting",
            "Processing",
            "DiagramCrafting",
            "StructuralCrafting"
          ],
          "const": "StructuralCrafting"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ]
        },
        "DescriptiveLabel": {
          "type": [
            "string",
            "null"
          ]
        },
        "TierLevels": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/BenchTierLevel"
          }
        },
        "LocalOpenSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "LocalCloseSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "CompletedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "FailedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BenchUpgradeSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BenchUpgradeCompletedSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Categories": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "HeaderCategories": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "AlwaysShowInventoryHints": {
          "type": "boolean",
          "default": false
        },
        "AllowBlockGroupCycling": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "BlockGathering": {
      "type": "object",
      "title": "BlockGathering",
      "properties": {
        "Breaking": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BlockBreakingDropType"
            },
            {
              "type": "null"
            }
          ]
        },
        "Harvest": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/HarvestingDropType"
            },
            {
              "type": "null"
            }
          ]
        },
        "Soft": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/SoftBlockDropType"
            },
            {
              "type": "null"
            }
          ]
        },
        "Physics": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/PhysicsDropType"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tools": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/BlockToolData"
          }
        },
        "UseDefaultDropWhenPlaced": {
          "type": "boolean",
          "description": "If this is set then player placed blocks will use the default drop behaviour instead of using the droplists.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "BlockBreakingDropType": {
      "type": "object",
      "title": "BlockBreakingDropType",
      "properties": {
        "GatherType": {
          "type": [
            "string",
            "null"
          ]
        },
        "Quality": {
          "type": "integer",
          "default": 0
        },
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Quantity": {
          "type": "integer",
          "default": 1
        },
        "DropList": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to ItemDropList"
            },
            {
              "$ref": "ItemDropList.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "HarvestingDropType": {
      "type": "object",
      "title": "HarvestingDropType",
      "properties": {
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "DropList": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to ItemDropList"
            },
            {
              "$ref": "ItemDropList.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "SoftBlockDropType": {
      "type": "object",
      "title": "SoftBlockDropType",
      "properties": {
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "DropList": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to ItemDropList"
            },
            {
              "$ref": "ItemDropList.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "IsWeaponBreakable": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "PhysicsDropType": {
      "type": "object",
      "title": "PhysicsDropType",
      "properties": {
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "DropList": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to ItemDropList"
            },
            {
              "$ref": "ItemDropList.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BlockToolData": {
      "type": "object",
      "title": "BlockToolData",
      "properties": {
        "Type": {
          "type": [
            "string",
            "null"
          ]
        },
        "State": {
          "type": [
            "string",
            "null"
          ]
        },
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "DropList": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to ItemDropList"
            },
            {
              "$ref": "ItemDropList.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BlockPlacementSettings": {
      "type": "object",
      "title": "BlockPlacementSettings",
      "properties": {
        "AllowRotationKey": {
          "type": "boolean",
          "default": true
        },
        "PlaceInEmptyBlocks": {
          "type": "boolean",
          "description": "If this block is allowed to be placed inside other blocks with an Empty Material (destroying them).",
          "default": false
        },
        "RotationMode": {
          "type": [
            "string",
            "null"
          ],
          "title": "RotationMode",
          "description": "The mode determining the rotation of this block when placed.",
          "enum": [
            "FacingPlayer",
            "BlockNormal",
            "StairFacingPlayer",
            "Default"
          ],
          "default": "Default"
        },
        "BlockPreviewVisibility": {
          "type": [
            "string",
            "null"
          ],
          "title": "BlockPreviewVisibility",
          "description": "An override for the block preview visibility",
          "enum": [
            "AlwaysVisible",
            "AlwaysHidden",
            "Default"
          ],
          "default": "Default"
        },
        "WallPlacementOverrideBlockId": {
          "type": [
            "string",
            "null"
          ]
        },
        "FloorPlacementOverrideBlockId": {
          "type": [
            "string",
            "null"
          ]
        },
        "CeilingPlacementOverrideBlockId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "FarmingData": {
      "type": "object",
      "title": "FarmingData",
      "properties": {
        "Stages": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "array",
            "items": {
              "title": "Type Selector",
              "anyOf": [
                {
                  "$ref": "common.schema.json#/$defs/BlockStateFarmingStageData"
                },
                {
                  "$ref": "common.schema.json#/$defs/BlockTypeFarmingStageData"
                },
                {
                  "$ref": "common.schema.json#/$defs/PrefabFarmingStageData"
                },
                {
                  "$ref": "common.schema.json#/$defs/SpreadFarmingStageData"
                }
              ]
            }
          }
        },
        "StartingStageSet": {
          "type": [
            "string",
            "null"
          ],
          "default": "Default"
        },
        "StageSetAfterHarvest": {
          "type": [
            "string",
            "null"
          ]
        },
        "ActiveGrowthModifiers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to GrowthModifierAsset"
              },
              {
                "$ref": "GrowthModifierAsset.json#"
              }
            ]
          }
        },
        "SoilConfig": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/SoilConfig"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BlockStateFarmingStageData": {
      "type": "object",
      "title": "BlockStateFarmingStageData",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BlockState\" to function as this type.",
          "const": "BlockState"
        },
        "Duration": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "SoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "State": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "BlockTypeFarmingStageData": {
      "type": "object",
      "title": "BlockTypeFarmingStageData",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BlockType\" to function as this type.",
          "const": "BlockType"
        },
        "Duration": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "SoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Block": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "PrefabFarmingStageData": {
      "type": "object",
      "title": "PrefabFarmingStageData",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Prefab\" to function as this type.",
          "const": "Prefab"
        },
        "Duration": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "SoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Prefabs": {
          "type": [
            "array",
            "null"
          ],
          "title": "WeightedMap",
          "items": {
            "$ref": "common.schema.json#/$defs/PrefabStage"
          }
        },
        "ReplaceMaskTags": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "PrefabStage": {
      "type": "object",
      "title": "PrefabStage",
      "properties": {
        "Weight": {
          "type": "integer",
          "minimum": 1,
          "default": 1
        },
        "Path": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "SpreadFarmingStageData": {
      "type": "object",
      "title": "SpreadFarmingStageData",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Spread\" to function as this type.",
          "const": "Spread"
        },
        "Duration": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "SoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Executions": {
          "type": "array",
          "title": "IntRange",
          "description": "Defines the number of times the stage will be repeated. Range must be positive, min value must be >= 1.",
          "items": [
            {
              "type": "integer"
            },
            {
              "type": "integer"
            }
          ],
          "minItems": 2,
          "maxItems": 2
        },
        "SpreadDecayPercent": {
          "type": "array",
          "title": "IntRange",
          "description": "The amount to reduce (linear decay) the spread rate (chance to spread) for any spawned blocks that also have a spread stage. Range must be positive.",
          "items": [
            {
              "type": "integer"
            },
            {
              "type": "integer"
            }
          ],
          "minItems": 2,
          "maxItems": 2
        },
        "GrowthBehaviours": {
          "type": "array",
          "description": "Defines an array of the different growth behaviours that'll be run for each execution.",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/DirectionalGrowthBehaviour"
              }
            ]
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "DirectionalGrowthBehaviour": {
      "type": "object",
      "title": "DirectionalGrowthBehaviour",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Directional\" to function as this type.",
          "const": "Directional"
        },
        "LocationConditions": {
          "type": [
            "array",
            "null"
          ],
          "description": "Defines the possible location conditions a position has to fulfill to be considered as valid.",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/NeighbourBlockTagsLocationCondition"
              }
            ]
          }
        },
        "GrowthBlockTypes": {
          "type": "array",
          "title": "WeightedMap",
          "description": "Defines a map of the possible BlockType to spread.",
          "items": {
            "$ref": "common.schema.json#/$defs/BlockTypeWeight"
          }
        },
        "Horizontal": {
          "type": [
            "array",
            "null"
          ],
          "title": "IntRange",
          "description": "Defines if the spread can happen horizontally. The range must be set with positive integers.",
          "items": [
            {
              "type": "integer"
            },
            {
              "type": "integer"
            }
          ],
          "minItems": 2,
          "maxItems": 2
        },
        "Vertical": {
          "type": [
            "array",
            "null"
          ],
          "title": "IntRange",
          "description": "Defines if the spread can happen vertically. The range must be set with positive integers.",
          "items": [
            {
              "type": "integer"
            },
            {
              "type": "integer"
            }
          ],
          "minItems": 2,
          "maxItems": 2
        },
        "VerticalDirection": {
          "type": "string",
          "title": "VerticalDirection",
          "description": "Defines in which direction the vertical spread should happen. Possible values are: 'Upwards' and 'Downwards', default value: 'Upwards'.",
          "enum": [
            "Downwards",
            "Both",
            "Upwards"
          ],
          "default": "Both"
        }
      },
      "additionalProperties": false
    },
    "NeighbourBlockTagsLocationCondition": {
      "type": "object",
      "title": "NeighbourBlockTagsLocationCondition",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"NeighbourBlockTags\" to function as this type.",
          "const": "NeighbourBlockTags"
        },
        "TagPattern": {
          "type": "string",
          "description": "A TagPattern can be used if the block at the chosen location needs to fulfill specific conditions."
        },
        "NeighbourBlock": {
          "type": "string",
          "title": "NeighbourDirection",
          "description": "Defines which block has to be checked related to original location. Possible values: Above, Below, Sideways.",
          "enum": [
            "Above",
            "Below",
            "Sideways"
          ]
        },
        "Support": {
          "type": [
            "array",
            "null"
          ],
          "title": "IntRange",
          "description": "Additional field used if NeighbourBlock is set to Sideways.",
          "items": [
            {
              "type": "integer"
            },
            {
              "type": "integer"
            }
          ],
          "minItems": 2,
          "maxItems": 2
        }
      },
      "additionalProperties": false
    },
    "BlockTypeWeight": {
      "type": "object",
      "title": "BlockTypeWeight",
      "properties": {
        "Weight": {
          "type": "number",
          "description": "Defines the probability to have this entry.",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "BlockType": {
          "type": "string",
          "description": "Defines the BlockType that'll be spread"
        }
      },
      "additionalProperties": false
    },
    "SoilConfig": {
      "type": "object",
      "title": "SoilConfig",
      "properties": {
        "TargetBlock": {
          "type": "string"
        },
        "Lifetime": {
          "$ref": "common.schema.json#/$defs/Rangef"
        }
      },
      "additionalProperties": false
    },
    "RequiredBlockFaceSupport": {
      "type": "object",
      "title": "RequiredBlockFaceSupport",
      "properties": {
        "FaceType": {
          "type": [
            "string",
            "null"
          ],
          "description": "Can be any string. Compared with FaceType in \"Supporting\" of other blocks. A LOT of blocks use 'Full'."
        },
        "SelfFaceType": {
          "type": [
            "string",
            "null"
          ]
        },
        "BlockSetId": {
          "type": [
            "string",
            "null"
          ]
        },
        "BlockTypeId": {
          "type": [
            "string",
            "null"
          ]
        },
        "FluidId": {
          "type": [
            "string",
            "null"
          ]
        },
        "MatchSelf": {
          "type": [
            "string",
            "null"
          ],
          "title": "Match",
          "enum": [
            "Ignored",
            "Required",
            "Disallowed"
          ],
          "default": "Ignored"
        },
        "Support": {
          "type": [
            "string",
            "null"
          ],
          "title": "Match",
          "enum": [
            "Ignored",
            "Required",
            "Disallowed"
          ],
          "default": "Required"
        },
        "AllowSupportPropagation": {
          "type": "boolean",
          "default": true
        },
        "Rotate": {
          "type": "boolean",
          "default": true
        },
        "Filler": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "TagId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "BlockFaceSupport": {
      "type": "object",
      "title": "BlockFaceSupport",
      "description": "Can be any string. Compared with FaceType in \"Support\". A LOT of blocks use 'Full'.",
      "properties": {
        "FaceType": {
          "type": [
            "string",
            "null"
          ],
          "default": "Full"
        },
        "Filler": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        }
      },
      "additionalProperties": false
    },
    "Data": {
      "type": "object",
      "title": "Data",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SpawnMarkerBlock\" to function as this type.",
          "const": "SpawnMarkerBlock"
        },
        "Definitions": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to BlockType"
              },
              {
                "$ref": "BlockType.json#"
              }
            ]
          }
        },
        "SpawnMarker": {
          "type": "string",
          "description": "The spawn marker to use."
        },
        "MarkerOffset": {
          "description": "An offset from the block at which the marker entity should be spawned.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "StateData": {
      "type": "object",
      "title": "StateData",
      "properties": {
        "Id": {
          "description": "This field controls the type, it must be set to the constant value \"StateData\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "container",
                  "SpawnMarkerBlock"
                ]
              }
            }
          ]
        },
        "Definitions": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to BlockType"
              },
              {
                "$ref": "BlockType.json#"
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "ItemContainerStateData": {
      "type": "object",
      "title": "ItemContainerStateData",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"container\" to function as this type.",
          "const": "container"
        },
        "Definitions": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to BlockType"
              },
              {
                "$ref": "BlockType.json#"
              }
            ]
          }
        },
        "Capacity": {
          "type": "integer",
          "default": 20
        }
      },
      "additionalProperties": false
    },
    "RailConfig": {
      "type": "object",
      "title": "RailConfig",
      "properties": {
        "Points": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/RailPoint"
          },
          "minItems": 2,
          "maxItems": 16
        }
      },
      "additionalProperties": false
    },
    "RailPoint": {
      "type": "object",
      "title": "RailPoint",
      "properties": {
        "Point": {
          "$ref": "common.schema.json#/$defs/Vector3f"
        },
        "Normal": {
          "$ref": "common.schema.json#/$defs/Vector3f"
        }
      },
      "additionalProperties": false
    },
    "CameraShakeEffect": {
      "type": "object",
      "title": "CameraShakeEffect",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CameraShake\" to function as this type.",
          "const": "CameraShake"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CameraShakeEffect most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CameraShakeEffect** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CameraShakeEffect",
            "mapKey": "Type",
            "mapKeyValue": "CameraShake"
          }
        },
        "CameraShake": {
          "description": "The type of camera shake to apply for this effect.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to CameraShake"
            },
            {
              "$ref": "CameraShake.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Intensity": {
          "description": "Controls how intensity-context (such as damage) is interpreted as shake intensity.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ShakeIntensity"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ShakeIntensity": {
      "type": "object",
      "title": "ShakeIntensity",
      "properties": {
        "Value": {
          "description": "The intensity used when no contextual value (such as damage) is present.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "AccumulationMode": {
          "type": "string",
          "title": "AccumulationMode",
          "description": "The method by which intensity is combined when multiple instances of the same camera effect overlap.",
          "enumDescriptions": [
            "Set the current value to the new one",
            "Add the new value to the current one",
            "Average the new value with current one"
          ],
          "markdownEnumDescriptions": [
            "Set the current value to the new one",
            "Add the new value to the current one",
            "Average the new value with current one"
          ],
          "enum": [
            "Set",
            "Sum",
            "Average"
          ],
          "default": "Set"
        },
        "Modifier": {
          "description": "Converts a contextual-intensity value (such as damage) to a camera shake intensity value.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Modifier"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Modifier": {
      "type": "object",
      "title": "Modifier",
      "properties": {
        "Input": {
          "type": "array",
          "items": {
            "type": "number"
          },
          "minItems": 1
        },
        "Output": {
          "type": "array",
          "items": {
            "type": "number"
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "CameraShakeConfig": {
      "type": "object",
      "title": "CameraShakeConfig",
      "properties": {
        "Duration": {
          "description": "The time period that the camera will shake at full intensity for",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "StartTime": {
          "description": "The initial time value that the Offset and Rotation noises are sampled from when the camera-shake starts. If absent, the camera-shake uses a continuously incremented time value.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "EaseIn": {
          "description": "The fade-in time and intensity curve for the camera shake",
          "default": {
            "Time": 0,
            "Type": "Linear"
          },
          "$ref": "common.schema.json#/$defs/EasingConfig"
        },
        "EaseOut": {
          "description": "The fade-out time and intensity curve for the camera shake",
          "default": {
            "Time": 0,
            "Type": "Linear"
          },
          "$ref": "common.schema.json#/$defs/EasingConfig"
        },
        "Offset": {
          "description": "The translational offset motion",
          "anyOf": [
            {
              "default": {},
              "$ref": "common.schema.json#/$defs/OffsetNoise"
            },
            {
              "type": "null"
            }
          ]
        },
        "Rotation": {
          "description": "The rotational motion",
          "anyOf": [
            {
              "default": {},
              "$ref": "common.schema.json#/$defs/RotationNoise"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "EasingConfig": {
      "type": "object",
      "title": "EasingConfig",
      "properties": {
        "Time": {
          "description": "The duration time of the easing",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Type": {
          "type": "string",
          "title": "EasingType",
          "description": "The curve type of the easing",
          "enum": [
            "Linear",
            "QuadIn",
            "QuadOut",
            "QuadInOut",
            "CubicIn",
            "CubicOut",
            "CubicInOut",
            "QuartIn",
            "QuartOut",
            "QuartInOut",
            "QuintIn",
            "QuintOut",
            "QuintInOut",
            "SineIn",
            "SineOut",
            "SineInOut",
            "ExpoIn",
            "ExpoOut",
            "ExpoInOut",
            "CircIn",
            "CircOut",
            "CircInOut",
            "ElasticIn",
            "ElasticOut",
            "ElasticInOut",
            "BackIn",
            "BackOut",
            "BackInOut",
            "BounceIn",
            "BounceOut",
            "BounceInOut"
          ],
          "default": "Linear"
        }
      },
      "additionalProperties": false
    },
    "OffsetNoise": {
      "type": "object",
      "title": "OffsetNoise",
      "description": "The translational offset noise sources. Each component's list of noise configurations are summed together to calculate the output value for that component",
      "properties": {
        "X": {
          "type": [
            "array",
            "null"
          ],
          "description": "The noise used to vary the camera x-offset",
          "items": {
            "$ref": "common.schema.json#/$defs/NoiseConfig"
          }
        },
        "Y": {
          "type": [
            "array",
            "null"
          ],
          "description": "The noise used to vary the camera y-offset",
          "items": {
            "$ref": "common.schema.json#/$defs/NoiseConfig"
          }
        },
        "Z": {
          "type": [
            "array",
            "null"
          ],
          "description": "The noise used to vary the camera z-offset",
          "items": {
            "$ref": "common.schema.json#/$defs/NoiseConfig"
          }
        }
      },
      "additionalProperties": false
    },
    "NoiseConfig": {
      "type": "object",
      "title": "NoiseConfig",
      "properties": {
        "Seed": {
          "type": "integer",
          "description": "The value used to seed the noise source",
          "default": 0
        },
        "Type": {
          "type": "string",
          "title": "NoiseType",
          "description": "The type of noise used to move the camera",
          "enum": [
            "Sin",
            "Cos",
            "Perlin_Linear",
            "Perlin_Hermite",
            "Perlin_Quintic",
            "Random"
          ],
          "default": "Sin"
        },
        "Frequency": {
          "description": "The frequency at which the noise source is sampled",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Amplitude": {
          "description": "The maximum extent of the noise source output",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Clamp": {
          "description": "Restricts the range of values that the noise source can output",
          "anyOf": [
            {
              "default": {
                "Min": -1,
                "Max": 1,
                "Normalize": true
              },
              "$ref": "common.schema.json#/$defs/ClampConfig"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ClampConfig": {
      "type": "object",
      "title": "ClampConfig",
      "properties": {
        "Min": {
          "description": "The inclusive minimum value of the clamp range",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Max": {
          "description": "The inclusive maximum value of the clamp range",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Normalize": {
          "type": "boolean",
          "description": "Rescales the clamped output value back to the range -1 to 1",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "RotationNoise": {
      "type": "object",
      "title": "RotationNoise",
      "description": "The rotational noise sources. Each component's list of noise configurations are summed together to calculate the output value for that component",
      "properties": {
        "Pitch": {
          "type": [
            "array",
            "null"
          ],
          "description": "The noise used to vary the camera pitch",
          "items": {
            "$ref": "common.schema.json#/$defs/NoiseConfig"
          }
        },
        "Yaw": {
          "type": [
            "array",
            "null"
          ],
          "description": "The noise used to vary the camera yaw",
          "items": {
            "$ref": "common.schema.json#/$defs/NoiseConfig"
          }
        },
        "Roll": {
          "type": [
            "array",
            "null"
          ],
          "description": "The noise used to vary the camera roll",
          "items": {
            "$ref": "common.schema.json#/$defs/NoiseConfig"
          }
        }
      },
      "additionalProperties": false
    },
    "AbilityCombatAction": {
      "type": "object",
      "title": "AbilityCombatAction",
      "description": "A combat action which executes an attack or ability by triggering an Interaction.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Ability\" to function as this type.",
          "const": "Ability"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AbilityCombatAction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AbilityCombatAction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Option",
            "mapKey": "Type",
            "mapKeyValue": "Ability"
          }
        },
        "Description": {
          "type": [
            "string",
            "null"
          ],
          "description": "A friendly description of this option's outcome."
        },
        "Conditions": {
          "type": "array",
          "description": "The list of conditions for evaluating this option's utility.",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Condition"
              },
              {
                "$ref": "Condition.json#"
              }
            ]
          },
          "minItems": 1
        },
        "WeightCoefficient": {
          "type": "number",
          "description": "An additional weighted ranking that can be used to greatly increase the utility of this option.",
          "minimum": 1,
          "default": 1
        },
        "Target": {
          "type": "string",
          "title": "Target",
          "description": "The target type this action applies to.",
          "enumDescriptions": [
            "Action targets self.",
            "Action targets any hostile target.",
            "Action targets any friendly target."
          ],
          "markdownEnumDescriptions": [
            "Action targets self.",
            "Action targets any hostile target.",
            "Action targets any friendly target."
          ],
          "enum": [
            "Self",
            "Hostile",
            "Friendly"
          ]
        },
        "PostExecuteDistanceRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "An optional range the NPC will try to maintain from the target after executing the combat action.",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        },
        "Ability": {
          "description": "The interaction (ability) to use.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            }
          ]
        },
        "AbilityType": {
          "type": [
            "string",
            "null"
          ],
          "title": "AbilityType",
          "description": "The ability type.",
          "enumDescriptions": [
            "Use primary attack.",
            "Use secondary attack."
          ],
          "markdownEnumDescriptions": [
            "Use primary attack.",
            "Use secondary attack."
          ],
          "enum": [
            "Primary",
            "Secondary"
          ],
          "default": "Primary"
        },
        "ChargeFor": {
          "description": "How long to charge the ability for before using it.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "AttackDistanceRange": {
          "type": "array",
          "description": "The range at which the NPC needs to be from the target to execute the attack.",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        },
        "WeaponSlot": {
          "type": "integer",
          "description": "The weapon (hotbar) slot to switch to for this attack.",
          "default": 0
        },
        "OffhandSlot": {
          "type": "integer",
          "description": "The off-hand slot to switch to for this attack. -1 set to no off-hand equipped.",
          "default": -1
        },
        "FailureTimeout": {
          "description": "How long to try and run the action before giving up if it can't be completed in time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SubState": {
          "type": [
            "string",
            "null"
          ],
          "description": "An optional substate to switch to when selecting this combat action to modify motion or other available actions.",
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "InteractionVars": {
          "type": [
            "object",
            "null"
          ],
          "description": "Interaction vars to modify the values in the interaction itself.",
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to RootInteraction"
              },
              {
                "$ref": "RootInteraction.json#"
              }
            ]
          }
        },
        "DamageFriendlies": {
          "type": "boolean",
          "description": "Whether or not this ability should be able to damage friendly targets.",
          "default": false
        },
        "RequireAiming": {
          "type": "boolean",
          "description": "Whether or not this ability needs to be aimed at the target.",
          "default": true
        },
        "Positioning": {
          "type": [
            "string",
            "null"
          ],
          "title": "Positioning",
          "description": "Where the NPC should try to position itself relative to the target's facing direction.",
          "enumDescriptions": [
            "Don't care about positioning.",
            "Try to be in front of the target.",
            "Try to be behind the target.",
            "Try to be on the target's flank."
          ],
          "markdownEnumDescriptions": [
            "Don't care about positioning.",
            "Try to be in front of the target.",
            "Try to be behind the target.",
            "Try to be on the target's flank."
          ],
          "enum": [
            "Any",
            "Front",
            "Behind",
            "Flank"
          ],
          "default": "Any"
        },
        "PositionFirst": {
          "type": "boolean",
          "description": "Whether the NPC should try to reach the correct positioning before executing the ability.",
          "default": false
        },
        "ChargeDistance": {
          "type": "number",
          "description": "If this is a charge attack, the distance the charge will cover.",
          "minimum": 0,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BasicAttackTargetCombatAction": {
      "type": "object",
      "title": "BasicAttackTargetCombatAction",
      "description": "A combat action which simply selects a target and sets up distances for use with substates that only contain basic attacks.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SelectBasicAttackTarget\" to function as this type.",
          "const": "SelectBasicAttackTarget"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BasicAttackTargetCombatAction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BasicAttackTargetCombatAction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Option",
            "mapKey": "Type",
            "mapKeyValue": "SelectBasicAttackTarget"
          }
        },
        "Description": {
          "type": [
            "string",
            "null"
          ],
          "description": "A friendly description of this option's outcome."
        },
        "Conditions": {
          "type": "array",
          "description": "The list of conditions for evaluating this option's utility.",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Condition"
              },
              {
                "$ref": "Condition.json#"
              }
            ]
          },
          "minItems": 1
        },
        "WeightCoefficient": {
          "type": "number",
          "description": "An additional weighted ranking that can be used to greatly increase the utility of this option.",
          "minimum": 1,
          "default": 1
        },
        "WeaponSlot": {
          "type": "integer",
          "description": "The weapon (hotbar) slot to switch to for basic attacks.",
          "default": 0
        },
        "OffhandSlot": {
          "type": "integer",
          "description": "The off-hand slot to switch to for basic attacks. -1 set to no off-hand equipped.",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "StateCombatAction": {
      "type": "object",
      "title": "StateCombatAction",
      "description": "A combat action which switches the NPCs state. Using substate only will switch between combat substates, whereas including the main state can be used to transition out of combat.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"State\" to function as this type.",
          "const": "State"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another StateCombatAction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **StateCombatAction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Option",
            "mapKey": "Type",
            "mapKeyValue": "State"
          }
        },
        "Description": {
          "type": [
            "string",
            "null"
          ],
          "description": "A friendly description of this option's outcome."
        },
        "Conditions": {
          "type": "array",
          "description": "The list of conditions for evaluating this option's utility.",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Condition"
              },
              {
                "$ref": "Condition.json#"
              }
            ]
          },
          "minItems": 1
        },
        "WeightCoefficient": {
          "type": "number",
          "description": "An additional weighted ranking that can be used to greatly increase the utility of this option.",
          "minimum": 1,
          "default": 1
        },
        "Target": {
          "type": "string",
          "title": "Target",
          "description": "The target type this action applies to.",
          "enumDescriptions": [
            "Action targets self.",
            "Action targets any hostile target.",
            "Action targets any friendly target."
          ],
          "markdownEnumDescriptions": [
            "Action targets self.",
            "Action targets any hostile target.",
            "Action targets any friendly target."
          ],
          "enum": [
            "Self",
            "Hostile",
            "Friendly"
          ]
        },
        "PostExecuteDistanceRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "An optional range the NPC will try to maintain from the target after executing the combat action.",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        },
        "State": {
          "type": "string",
          "description": "The main state name.",
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "SubState": {
          "type": [
            "string",
            "null"
          ],
          "description": "The substate name."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FlockSizeCondition": {
      "type": "object",
      "title": "FlockSizeCondition",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FlockSize\" to function as this type.",
          "const": "FlockSize"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FlockSizeCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FlockSizeCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "FlockSize"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ScaledXResponseCurve": {
      "type": "object",
      "title": "ScaledXResponseCurve",
      "description": "A response curve scaled only on the x axis.",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"Default\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "Switch"
                ]
              }
            }
          ]
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ScaledXResponseCurve most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ScaledXResponseCurve** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ScaledXResponseCurve"
          }
        },
        "ResponseCurve": {
          "type": "string",
          "description": "The response curve to scale"
        },
        "XRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "The range to map the x axis to. e.g. [ 0, 10 ]",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ScaledSwitchResponseCurve": {
      "type": "object",
      "title": "ScaledSwitchResponseCurve",
      "description": "A special type of scaled response curve which returns the initial state value before the defined switch point and the final state value after reaching it.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Switch\" to function as this type.",
          "const": "Switch"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ScaledSwitchResponseCurve most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ScaledSwitchResponseCurve** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ScaledSwitchResponseCurve",
            "mapKey": "Type",
            "mapKeyValue": "Switch"
          }
        },
        "InitialState": {
          "type": "number",
          "description": "The y value to return before the switch point.",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "FinalState": {
          "type": "number",
          "description": "The y value to return at and beyond the switch point.",
          "minimum": 0,
          "maximum": 1,
          "default": 1
        },
        "SwitchPoint": {
          "type": "number",
          "description": "The value at which to switch from the initial state to the final state.",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "HasTargetCondition": {
      "type": "object",
      "title": "HasTargetCondition",
      "description": "A simple boolean condition that returns whether the NPC has a target locked in the given slot.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"HasTarget\" to function as this type.",
          "const": "HasTarget"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another HasTargetCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **HasTargetCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "HasTarget"
          }
        },
        "FalseValue": {
          "type": "number",
          "description": "The utility value to use when the condition evaluates false.",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "TrueValue": {
          "type": "number",
          "description": "The utility value to use when the condition evaluates true.",
          "minimum": 0,
          "maximum": 1,
          "default": 1
        },
        "TargetSlot": {
          "type": "string",
          "description": "The target slot to check.",
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "IsInStateCondition": {
      "type": "object",
      "title": "IsInStateCondition",
      "description": "A simple boolean condition that returns whether the NPC is in a given state.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"IsInState\" to function as this type.",
          "const": "IsInState"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another IsInStateCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **IsInStateCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "IsInState"
          }
        },
        "FalseValue": {
          "type": "number",
          "description": "The utility value to use when the condition evaluates false.",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "TrueValue": {
          "type": "number",
          "description": "The utility value to use when the condition evaluates true.",
          "minimum": 0,
          "maximum": 1,
          "default": 1
        },
        "State": {
          "type": "string",
          "description": "The main state to evaluate.",
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "SubState": {
          "type": [
            "string",
            "null"
          ],
          "description": "The optional substate to evaluate."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TargetMemoryCountCondition": {
      "type": "object",
      "title": "TargetMemoryCountCondition",
      "description": "A scaled curve condition that returns a utility value based on the number of known targets in the memory.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"KnownTargetCount\" to function as this type.",
          "const": "KnownTargetCount"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TargetMemoryCountCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TargetMemoryCountCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "KnownTargetCount"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "TargetType": {
          "type": [
            "string",
            "null"
          ],
          "title": "TargetType",
          "description": "The type of targets to count.",
          "enumDescriptions": [
            "Known hostile targets.",
            "Known friendly targets.",
            "All known targets."
          ],
          "markdownEnumDescriptions": [
            "Known hostile targets.",
            "Known friendly targets.",
            "All known targets."
          ],
          "enum": [
            "Hostile",
            "Friendly",
            "All"
          ],
          "default": "Hostile"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "LineOfSightCondition": {
      "type": "object",
      "title": "LineOfSightCondition",
      "description": "A simple boolean condition that returns whether or not there is a line of sight to the target.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LineOfSight\" to function as this type.",
          "const": "LineOfSight"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another LineOfSightCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **LineOfSightCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "LineOfSight"
          }
        },
        "FalseValue": {
          "type": "number",
          "description": "The utility value to use when the condition evaluates false.",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "TrueValue": {
          "type": "number",
          "description": "The utility value to use when the condition evaluates true.",
          "minimum": 0,
          "maximum": 1,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "NearbyCountCondition": {
      "type": "object",
      "title": "NearbyCountCondition",
      "description": "A scaled curve condition that returns a utility value based on the number of NPCs nearby belonging to a specific NPCGroup.",
      "markdownDescription": "A scaled curve condition that returns a utility value based on the number of NPCs nearby belonging to a specific **NPCGroup**.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"NearbyCount\" to function as this type.",
          "const": "NearbyCount"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another NearbyCountCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **NearbyCountCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "NearbyCount"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Range": {
          "type": "number",
          "description": "The range within which to count NPCs.",
          "exclusiveMinimum": 0,
          "default": 0
        },
        "NPCGroup": {
          "type": "string",
          "description": "The NPCGroup to count NPCs from."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SelfStatAbsoluteCondition": {
      "type": "object",
      "title": "SelfStatAbsoluteCondition",
      "description": "A scaled curve condition that returns a utility value based on the absolute value of one of this NPC's stats.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OwnStatAbsolute\" to function as this type.",
          "const": "OwnStatAbsolute"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SelfStatAbsoluteCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SelfStatAbsoluteCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "OwnStatAbsolute"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Stat": {
          "type": "string",
          "description": "The stat to check."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SelfStatPercentageCondition": {
      "type": "object",
      "title": "SelfStatPercentageCondition",
      "description": "A curve condition that returns a utility value based on the percentage value of one of this NPC's stats.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OwnStatPercent\" to function as this type.",
          "const": "OwnStatPercent"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SelfStatPercentageCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SelfStatPercentageCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "OwnStatPercent"
          }
        },
        "Curve": {
          "type": "string",
          "description": "The response curve used to evaluate the condition."
        },
        "Stat": {
          "type": "string",
          "description": "The stat to check."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RandomiserCondition": {
      "type": "object",
      "title": "RandomiserCondition",
      "description": "A condition that jitters between two defined values to add a small amount of randomness to the final utility value.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Randomiser\" to function as this type.",
          "const": "Randomiser"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RandomiserCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RandomiserCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "Randomiser"
          }
        },
        "MinValue": {
          "type": "number",
          "description": "The minimum bound of the jitter.",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "MaxValue": {
          "type": "number",
          "description": "The maximum bound of the jitter.",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RecentSustainedDamageCondition": {
      "type": "object",
      "title": "RecentSustainedDamageCondition",
      "description": "A scaled curve condition that returns a utility value based on damage taken since the combat action evaluator was last run.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"RecentSustainedDamage\" to function as this type.",
          "const": "RecentSustainedDamage"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RecentSustainedDamageCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RecentSustainedDamageCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "RecentSustainedDamage"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TargetDistanceCondition": {
      "type": "object",
      "title": "TargetDistanceCondition",
      "description": "A scaled curve condition that returns a utility value based on the distance between the NPC and the target.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TargetDistance\" to function as this type.",
          "const": "TargetDistance"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TargetDistanceCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TargetDistanceCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "TargetDistance"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TargetMovementStateCondition": {
      "type": "object",
      "title": "TargetMovementStateCondition",
      "description": "A simple boolean condition that returns whether the target is in a given movement state.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TargetMovementState\" to function as this type.",
          "const": "TargetMovementState"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TargetMovementStateCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TargetMovementStateCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "TargetMovementState"
          }
        },
        "FalseValue": {
          "type": "number",
          "description": "The utility value to use when the condition evaluates false.",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "TrueValue": {
          "type": "number",
          "description": "The utility value to use when the condition evaluates true.",
          "minimum": 0,
          "maximum": 1,
          "default": 1
        },
        "State": {
          "type": "string",
          "title": "MovementState",
          "description": "The movement state to check for.",
          "enum": [
            "Jumping",
            "Flying",
            "Crouching",
            "Running",
            "Sprinting",
            "Falling",
            "Climbing",
            "Walking",
            "Idle",
            "Any"
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TargetStatAbsoluteCondition": {
      "type": "object",
      "title": "TargetStatAbsoluteCondition",
      "description": "A scaled curve condition that returns a utility value based on the absolute value of one of the target's stats.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TargetStatAbsolute\" to function as this type.",
          "const": "TargetStatAbsolute"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TargetStatAbsoluteCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TargetStatAbsoluteCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "TargetStatAbsolute"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Stat": {
          "type": "string",
          "description": "The stat to check."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TargetStatPercentageCondition": {
      "type": "object",
      "title": "TargetStatPercentageCondition",
      "description": "A curve condition that returns a utility value based on the percentage value of one of the target's stats.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TargetStatPercent\" to function as this type.",
          "const": "TargetStatPercent"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TargetStatPercentageCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TargetStatPercentageCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "TargetStatPercent"
          }
        },
        "Curve": {
          "type": "string",
          "description": "The response curve used to evaluate the condition."
        },
        "Stat": {
          "type": "string",
          "description": "The stat to check."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TimeOfDayCondition": {
      "type": "object",
      "title": "TimeOfDayCondition",
      "description": "A scaled curve condition that returns a utility value based on the current in-game time of day.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TimeOfDay\" to function as this type.",
          "const": "TimeOfDay"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TimeOfDayCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TimeOfDayCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "TimeOfDay"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TimeSinceLastUsedCondition": {
      "type": "object",
      "title": "TimeSinceLastUsedCondition",
      "description": "A scaled curve condition that returns a utility value based on how long it has been since the Option was last used.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TimeSinceLastUsed\" to function as this type.",
          "const": "TimeSinceLastUsed"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TimeSinceLastUsedCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TimeSinceLastUsedCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "TimeSinceLastUsed"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TotalSustainedDamageCondition": {
      "type": "object",
      "title": "TotalSustainedDamageCondition",
      "description": "A scaled curve condition that returns a utility value based on total damage taken during this bout of combat.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TotalSustainedDamage\" to function as this type.",
          "const": "TotalSustainedDamage"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TotalSustainedDamageCondition most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TotalSustainedDamageCondition** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Condition",
            "mapKey": "Type",
            "mapKeyValue": "TotalSustainedDamage"
          }
        },
        "Curve": {
          "title": "Type Selector",
          "description": "The scaled response curve used to evaluate the condition.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ScaledXResponseCurve"
            },
            {
              "$ref": "common.schema.json#/$defs/ScaledSwitchResponseCurve"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BenchRequirement": {
      "type": "object",
      "title": "BenchRequirement",
      "properties": {
        "Type": {
          "type": [
            "string",
            "null"
          ],
          "title": "BenchType",
          "enum": [
            "Crafting",
            "Processing",
            "DiagramCrafting",
            "StructuralCrafting"
          ],
          "default": "Crafting"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ]
        },
        "Categories": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "RequiredTierLevel": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ConnectedBlockShape": {
      "type": "object",
      "title": "ConnectedBlockShape",
      "properties": {
        "PatternsToMatchAnyOf": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/CustomConnectedBlockPattern"
              }
            ]
          }
        },
        "FaceTags": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConnectedBlockFaceTags"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "CustomConnectedBlockPattern": {
      "type": "object",
      "title": "CustomConnectedBlockPattern",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Custom\" to function as this type.",
          "const": "Custom"
        },
        "TransformRulesToOrientation": {
          "type": "boolean",
          "description": "If the rules should be transformed to the current orientation of the block.",
          "default": true
        },
        "YawToApplyAddReplacedBlockType": {
          "type": [
            "string",
            "null"
          ],
          "title": "Rotation",
          "description": "Apply an additional Yaw to the resulting BlockType represented by this shape. This allows your replacement to be offset from your original placement",
          "enum": [
            "None",
            "Ninety",
            "OneEighty",
            "TwoSeventy"
          ]
        },
        "RequireFaceTagsMatchingRoll": {
          "type": "boolean",
          "description": "Adds Roll comparison to face tag matching in patterns below",
          "default": false
        },
        "AllowedPatternTransformations": {
          "description": "Will create additional generated patterns that are variants of this pattern, but rotated/mirrored/flipped to achieve different results. A common example of this is the Fence, which should its resulting shape based on the rotation of its pattern (fence corner rotates depending on which two sides have the corner fence shape)",
          "anyOf": [
            {
              "default": {
                "IsCardinallyRotatable": false,
                "MirrorZ": false,
                "MirrorX": false
              },
              "$ref": "common.schema.json#/$defs/PatternRotationDefinition"
            },
            {
              "type": "null"
            }
          ]
        },
        "RulesToMatch": {
          "type": [
            "array",
            "null"
          ],
          "description": "All rules must match in order for the pattern to match",
          "items": {
            "$ref": "common.schema.json#/$defs/ConnectedBlockPatternRule"
          }
        },
        "OnlyOnPlacement": {
          "type": "boolean",
          "description": "If true, this pattern will only be checked when the block is first placed.",
          "default": false
        },
        "OnlyOnUpdate": {
          "type": "boolean",
          "description": "If true, this pattern will only be checked when the block is updated by neighboring block changes.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "PatternRotationDefinition": {
      "type": "object",
      "title": "PatternRotationDefinition",
      "properties": {
        "IsCardinallyRotatable": {
          "type": "boolean",
          "default": false
        },
        "MirrorZ": {
          "type": "boolean",
          "default": false
        },
        "MirrorX": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "ConnectedBlockPatternRule": {
      "type": "object",
      "title": "ConnectedBlockPatternRule",
      "description": "Queries the face the block was placed against",
      "properties": {
        "Position": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "IncludeOrExclude": {
          "type": [
            "string",
            "null"
          ],
          "title": "IncludeOrExclude",
          "enum": [
            "Include",
            "Exclude"
          ]
        },
        "PlacementNormals": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string",
            "title": "AdjacentSide",
            "enum": [
              "Up",
              "Down",
              "North",
              "East",
              "South",
              "West"
            ]
          }
        },
        "FaceTags": {
          "anyOf": [
            {
              "default": {
                "North": [],
                "East": [],
                "South": [],
                "West": [],
                "Up": [],
                "Down": []
              },
              "$ref": "common.schema.json#/$defs/ConnectedBlockFaceTags"
            },
            {
              "type": "null"
            }
          ]
        },
        "Shapes": {
          "type": [
            "array",
            "null"
          ],
          "title": "Set",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "BlockTypes": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "BlockTypeLists": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "ConnectedBlockFaceTags": {
      "type": "object",
      "title": "ConnectedBlockFaceTags",
      "properties": {
        "North": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "East": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "South": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "West": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "Up": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "Down": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "AbsDensityAsset": {
      "type": "object",
      "title": "AbsDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Abs\" to function as this type.",
          "const": "Abs"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AbsDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AbsDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Abs"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AmplitudeDensityAsset": {
      "type": "object",
      "title": "AmplitudeDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Amplitude\" to function as this type.",
          "const": "Amplitude"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AmplitudeDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AmplitudeDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Amplitude"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "FunctionForY": {
          "anyOf": [
            {
              "default": {
                "Points": []
              },
              "$ref": "common.schema.json#/$defs/NodeFunctionYOutAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "NodeFunctionYOutAsset": {
      "type": "object",
      "title": "NodeFunctionYOutAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another NodeFunctionYOutAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **NodeFunctionYOutAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "NodeFunctionYOutAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Points": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/PointYOutAsset"
          }
        }
      },
      "additionalProperties": false
    },
    "PointYOutAsset": {
      "type": "object",
      "title": "PointYOutAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PointYOutAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PointYOutAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "PointYOutAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Y": {
          "type": "number",
          "default": 0
        },
        "Out": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "AmplitudeConstantAsset": {
      "type": "object",
      "title": "AmplitudeConstantAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"AmplitudeConstant\" to function as this type.",
          "const": "AmplitudeConstant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AmplitudeConstantAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AmplitudeConstantAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "AmplitudeConstant"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AnchorDensityAsset": {
      "type": "object",
      "title": "AnchorDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Anchor\" to function as this type.",
          "const": "Anchor"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AnchorDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AnchorDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Anchor"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Reversed": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AngleDensityAsset": {
      "type": "object",
      "title": "AngleDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Angle\" to function as this type.",
          "const": "Angle"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AngleDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AngleDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Angle"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "VectorProvider": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CacheVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityGradientVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ExportedVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedVectorProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Vector": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "IsAxis": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CacheVectorProviderAsset": {
      "type": "object",
      "title": "CacheVectorProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cache\" to function as this type.",
          "const": "Cache"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CacheVectorProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CacheVectorProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "VectorProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cache"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "VectorProvider": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CacheVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityGradientVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ExportedVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedVectorProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConstantVectorProviderAsset": {
      "type": "object",
      "title": "ConstantVectorProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Constant\" to function as this type.",
          "const": "Constant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantVectorProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantVectorProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "VectorProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Constant"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DensityGradientVectorProviderAsset": {
      "type": "object",
      "title": "DensityGradientVectorProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DensityGradient\" to function as this type.",
          "const": "DensityGradient"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DensityGradientVectorProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DensityGradientVectorProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "VectorProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "DensityGradient"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "SampleDistance": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ExportedVectorProviderAsset": {
      "type": "object",
      "title": "ExportedVectorProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Exported\" to function as this type.",
          "const": "Exported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ExportedVectorProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ExportedVectorProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "VectorProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Exported"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "SingleInstance": {
          "type": "boolean",
          "default": false
        },
        "VectorProvider": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CacheVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityGradientVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ExportedVectorProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedVectorProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ImportedVectorProviderAsset": {
      "type": "object",
      "title": "ImportedVectorProviderAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedVectorProviderAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedVectorProviderAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "VectorProviderAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AxisDensityAsset": {
      "type": "object",
      "title": "AxisDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Axis\" to function as this type.",
          "const": "Axis"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AxisDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AxisDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Axis"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "IsAnchored": {
          "type": "boolean",
          "default": false
        },
        "Axis": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 1,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BaseHeightDensityAsset": {
      "type": "object",
      "title": "BaseHeightDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BaseHeight\" to function as this type.",
          "const": "BaseHeight"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BaseHeightDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BaseHeightDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "BaseHeight"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "BaseHeightName": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Distance": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CacheDensityAsset": {
      "type": "object",
      "title": "CacheDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cache\" to function as this type.",
          "const": "Cache"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CacheDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CacheDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cache"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Capacity": {
          "type": "integer",
          "minimum": 0,
          "default": 3
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Cache2dDensityAsset_Deprecated": {
      "type": "object",
      "title": "Cache2dDensityAsset_Deprecated",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cache2D\" to function as this type.",
          "const": "Cache2D"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Cache2dDensityAsset_Deprecated most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Cache2dDensityAsset_Deprecated** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cache2D"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Y": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CeilingDensityAsset": {
      "type": "object",
      "title": "CeilingDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Ceiling\" to function as this type.",
          "const": "Ceiling"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CeilingDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CeilingDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Ceiling"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Limit": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CellNoise2DDensityAsset": {
      "type": "object",
      "title": "CellNoise2DDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CellNoise2D\" to function as this type.",
          "const": "CellNoise2D"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CellNoise2DDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CellNoise2DDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "CellNoise2D"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "ScaleX": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ScaleZ": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Jitter": {
          "type": "number",
          "default": 1
        },
        "Octaves": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "CellType": {
          "type": [
            "string",
            "null"
          ],
          "title": "CellularReturnType",
          "enum": [
            "CellValue",
            "Distance",
            "Distance2",
            "Distance2Add",
            "Distance2Sub",
            "Distance2Mul",
            "Distance2Div"
          ],
          "default": "CellValue"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CellNoise3DDensityAsset": {
      "type": "object",
      "title": "CellNoise3DDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CellNoise3D\" to function as this type.",
          "const": "CellNoise3D"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CellNoise3DDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CellNoise3DDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "CellNoise3D"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "ScaleX": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ScaleY": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ScaleZ": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Jitter": {
          "type": "number",
          "default": 1
        },
        "Octaves": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "CellType": {
          "type": [
            "string",
            "null"
          ],
          "title": "CellularReturnType",
          "enum": [
            "CellValue",
            "Distance",
            "Distance2",
            "Distance2Add",
            "Distance2Sub",
            "Distance2Mul",
            "Distance2Div"
          ],
          "default": "CellValue"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CellWallDistanceDensityAsset": {
      "type": "object",
      "title": "CellWallDistanceDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CellWallDistance\" to function as this type.",
          "const": "CellWallDistance"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CellWallDistanceDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CellWallDistanceDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "CellWallDistance"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ClampDensityAsset": {
      "type": "object",
      "title": "ClampDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Clamp\" to function as this type.",
          "const": "Clamp"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ClampDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ClampDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Clamp"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "WallA": {
          "type": "number",
          "default": 0
        },
        "WallB": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConstantDensityAsset": {
      "type": "object",
      "title": "ConstantDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Constant\" to function as this type.",
          "const": "Constant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConstantDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConstantDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Constant"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CubeDensityAsset": {
      "type": "object",
      "title": "CubeDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cube\" to function as this type.",
          "const": "Cube"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CubeDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CubeDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cube"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CuboidDensityAsset": {
      "type": "object",
      "title": "CuboidDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cuboid\" to function as this type.",
          "const": "Cuboid"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CuboidDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CuboidDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cuboid"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scale": {
          "anyOf": [
            {
              "default": {
                "X": 1,
                "Y": 1,
                "Z": 1
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "NewYAxis": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 1,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Spin": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CurveMapperDensityAsset": {
      "type": "object",
      "title": "CurveMapperDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CurveMapper\" to function as this type.",
          "const": "CurveMapper"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CurveMapperDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CurveMapperDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "CurveMapper"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CylinderDensityAsset": {
      "type": "object",
      "title": "CylinderDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Cylinder\" to function as this type.",
          "const": "Cylinder"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CylinderDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CylinderDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Cylinder"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "RadialCurve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "AxialCurve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "NewYAxis": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 1,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Spin": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DistanceDensityAsset": {
      "type": "object",
      "title": "DistanceDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Distance\" to function as this type.",
          "const": "Distance"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DistanceDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DistanceDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Distance"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DistanceToBiomeEdgeDensityAsset": {
      "type": "object",
      "title": "DistanceToBiomeEdgeDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DistanceToBiomeEdge\" to function as this type.",
          "const": "DistanceToBiomeEdge"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DistanceToBiomeEdgeDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DistanceToBiomeEdgeDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "DistanceToBiomeEdge"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EllipsoidDensityAsset": {
      "type": "object",
      "title": "EllipsoidDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Ellipsoid\" to function as this type.",
          "const": "Ellipsoid"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EllipsoidDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EllipsoidDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Ellipsoid"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scale": {
          "anyOf": [
            {
              "default": {
                "X": 1,
                "Y": 1,
                "Z": 1
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "NewYAxis": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 1,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Spin": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ExportedDensityAsset": {
      "type": "object",
      "title": "ExportedDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Exported\" to function as this type.",
          "const": "Exported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ExportedDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ExportedDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Exported"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "SingleInstance": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FastGradientWarpDensityAsset": {
      "type": "object",
      "title": "FastGradientWarpDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FastGradientWarp\" to function as this type.",
          "const": "FastGradientWarp"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FastGradientWarpDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FastGradientWarpDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "FastGradientWarp"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "WarpScale": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "WarpOctaves": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "WarpLacunarity": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "WarpPersistence": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "WarpFactor": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FloorDensityAsset": {
      "type": "object",
      "title": "FloorDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Floor\" to function as this type.",
          "const": "Floor"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FloorDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FloorDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Floor"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Limit": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "GradientDensityAsset": {
      "type": "object",
      "title": "GradientDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Gradient\" to function as this type.",
          "const": "Gradient"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another GradientDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **GradientDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Gradient"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Axis": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 1,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "SampleRange": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "GradientWarpDensityAsset": {
      "type": "object",
      "title": "GradientWarpDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"GradientWarp\" to function as this type.",
          "const": "GradientWarp"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another GradientWarpDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **GradientWarpDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "GradientWarp"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "SampleRange": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "WarpFactor": {
          "type": "number",
          "default": 1
        },
        "2D": {
          "type": "boolean",
          "default": false
        },
        "YFor2D": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ImportedDensityAsset": {
      "type": "object",
      "title": "ImportedDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "InverterDensityAsset": {
      "type": "object",
      "title": "InverterDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Inverter\" to function as this type.",
          "const": "Inverter"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another InverterDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **InverterDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Inverter"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MaxDensityAsset": {
      "type": "object",
      "title": "MaxDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Max\" to function as this type.",
          "const": "Max"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MaxDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MaxDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Max"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MinDensityAsset": {
      "type": "object",
      "title": "MinDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Min\" to function as this type.",
          "const": "Min"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MinDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MinDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Min"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MixDensityAsset": {
      "type": "object",
      "title": "MixDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Mix\" to function as this type.",
          "const": "Mix"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MixDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MixDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Mix"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MultiMixDensityAsset": {
      "type": "object",
      "title": "MultiMixDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"MultiMix\" to function as this type.",
          "const": "MultiMix"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MultiMixDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MultiMixDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "MultiMix"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Keys": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/KeyAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "KeyAsset": {
      "type": "object",
      "title": "KeyAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another KeyAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **KeyAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "KeyAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Value": {
          "type": "number",
          "default": 0
        },
        "DensityIndex": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "MultiplierDensityAsset": {
      "type": "object",
      "title": "MultiplierDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Multiplier\" to function as this type.",
          "const": "Multiplier"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MultiplierDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MultiplierDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Multiplier"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "NormalizerDensityAsset": {
      "type": "object",
      "title": "NormalizerDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Normalizer\" to function as this type.",
          "const": "Normalizer"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another NormalizerDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **NormalizerDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Normalizer"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "FromMin": {
          "type": "number",
          "default": 0
        },
        "FromMax": {
          "type": "number",
          "default": 1
        },
        "ToMin": {
          "type": "number",
          "default": 0
        },
        "ToMax": {
          "type": "number",
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OffsetDensityAsset": {
      "type": "object",
      "title": "OffsetDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Offset\" to function as this type.",
          "const": "Offset"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OffsetDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OffsetDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Offset"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "FunctionForY": {
          "anyOf": [
            {
              "default": {
                "Points": []
              },
              "$ref": "common.schema.json#/$defs/NodeFunctionYOutAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OffsetConstantAsset": {
      "type": "object",
      "title": "OffsetConstantAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OffsetConstant\" to function as this type.",
          "const": "OffsetConstant"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OffsetConstantAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OffsetConstantAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "OffsetConstant"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PipelineDensityAsset": {
      "type": "object",
      "title": "PipelineDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Pipeline\" to function as this type.",
          "const": "Pipeline"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PipelineDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PipelineDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Pipeline"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Pipeline": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PlaneDensityAsset": {
      "type": "object",
      "title": "PlaneDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Plane\" to function as this type.",
          "const": "Plane"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PlaneDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PlaneDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Plane"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "IsAnchored": {
          "type": "boolean",
          "default": false
        },
        "PlaneNormal": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 1,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Positions3DDensityAsset": {
      "type": "object",
      "title": "Positions3DDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Positions3D\" to function as this type.",
          "const": "Positions3D"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Positions3DDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Positions3DDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Positions3D"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "DistanceCurve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaxDistance": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PositionsCellNoiseDensityAsset": {
      "type": "object",
      "title": "PositionsCellNoiseDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PositionsCellNoise\" to function as this type.",
          "const": "PositionsCellNoise"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PositionsCellNoiseDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PositionsCellNoiseDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "PositionsCellNoise"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "ReturnType": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CellValueReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CurveReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DensityReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Distance2ReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Distance2AddReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Distance2DivReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Distance2MulReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Distance2SubReturnTypeAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedReturnTypeAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "DistanceFunction": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/EuclideanDistanceFunctionAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManhattanDistanceFunctionAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaxDistance": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CellValueReturnTypeAsset": {
      "type": "object",
      "title": "CellValueReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CellValue\" to function as this type.",
          "const": "CellValue"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CellValueReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CellValueReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "CellValue"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "DefaultValue": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CurveReturnTypeAsset": {
      "type": "object",
      "title": "CurveReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Curve\" to function as this type.",
          "const": "Curve"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CurveReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CurveReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Curve"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Curve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DensityReturnTypeAsset": {
      "type": "object",
      "title": "DensityReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Density\" to function as this type.",
          "const": "Density"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DensityReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DensityReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Density"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "ChoiceDensity": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Delimiters": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DelimiterAsset@8"
          }
        },
        "DefaultValue": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DelimiterAsset@8": {
      "type": "object",
      "title": "DelimiterAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DelimiterAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DelimiterAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DelimiterAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "From": {
          "type": "number",
          "default": 0
        },
        "To": {
          "type": "number",
          "default": 0
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "DistanceReturnTypeAsset": {
      "type": "object",
      "title": "DistanceReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Distance\" to function as this type.",
          "const": "Distance"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DistanceReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DistanceReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Distance"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Distance2ReturnTypeAsset": {
      "type": "object",
      "title": "Distance2ReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Distance2\" to function as this type.",
          "const": "Distance2"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Distance2ReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Distance2ReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Distance2"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Distance2AddReturnTypeAsset": {
      "type": "object",
      "title": "Distance2AddReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Distance2Add\" to function as this type.",
          "const": "Distance2Add"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Distance2AddReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Distance2AddReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Distance2Add"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Distance2DivReturnTypeAsset": {
      "type": "object",
      "title": "Distance2DivReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Distance2Div\" to function as this type.",
          "const": "Distance2Div"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Distance2DivReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Distance2DivReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Distance2Div"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Distance2MulReturnTypeAsset": {
      "type": "object",
      "title": "Distance2MulReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Distance2Mul\" to function as this type.",
          "const": "Distance2Mul"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Distance2MulReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Distance2MulReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Distance2Mul"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Distance2SubReturnTypeAsset": {
      "type": "object",
      "title": "Distance2SubReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Distance2Sub\" to function as this type.",
          "const": "Distance2Sub"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another Distance2SubReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **Distance2SubReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Distance2Sub"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ImportedReturnTypeAsset": {
      "type": "object",
      "title": "ImportedReturnTypeAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Imported\" to function as this type.",
          "const": "Imported"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ImportedReturnTypeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ImportedReturnTypeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ReturnTypeAsset",
            "mapKey": "Type",
            "mapKeyValue": "Imported"
          }
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EuclideanDistanceFunctionAsset": {
      "type": "object",
      "title": "EuclideanDistanceFunctionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Euclidean\" to function as this type.",
          "const": "Euclidean"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EuclideanDistanceFunctionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EuclideanDistanceFunctionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DistanceFunctionAsset",
            "mapKey": "Type",
            "mapKeyValue": "Euclidean"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ManhattanDistanceFunctionAsset": {
      "type": "object",
      "title": "ManhattanDistanceFunctionAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Manhattan\" to function as this type.",
          "const": "Manhattan"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ManhattanDistanceFunctionAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ManhattanDistanceFunctionAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DistanceFunctionAsset",
            "mapKey": "Type",
            "mapKeyValue": "Manhattan"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PositionsPinchDensityAsset": {
      "type": "object",
      "title": "PositionsPinchDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PositionsPinch\" to function as this type.",
          "const": "PositionsPinch"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PositionsPinchDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PositionsPinchDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "PositionsPinch"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "PinchCurve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaxDistance": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "NormalizeDistance": {
          "type": "boolean",
          "default": false
        },
        "HorizontalPinch": {
          "type": "boolean",
          "default": false
        },
        "PositionsMinY": {
          "type": "number",
          "default": 0
        },
        "PositionsMaxY": {
          "type": "number",
          "default": 0.000001
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PositionsTwistDensityAsset": {
      "type": "object",
      "title": "PositionsTwistDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PositionsTwist\" to function as this type.",
          "const": "PositionsTwist"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PositionsTwistDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PositionsTwistDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "PositionsTwist"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Positions": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AnchorPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/BaseHeightPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/CachedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ListPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh2DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/Mesh3DPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FieldFunctionOccurrencePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/OffsetPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SimpleHorizontalPositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SpherePositionProviderAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/UnionPositionProviderAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "TwistCurve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "TwistAxis": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaxDistance": {
          "type": "number",
          "minimum": 0,
          "default": 0
        },
        "NormalizeDistance": {
          "type": "boolean",
          "default": false
        },
        "ZeroPositionsY": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PowDensityAsset": {
      "type": "object",
      "title": "PowDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Pow\" to function as this type.",
          "const": "Pow"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PowDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PowDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Pow"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Exponent": {
          "type": "number",
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RotatorDensityAsset": {
      "type": "object",
      "title": "RotatorDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Rotator\" to function as this type.",
          "const": "Rotator"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RotatorDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RotatorDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Rotator"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "NewYAxis": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "SpinAngle": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ScaleDensityAsset": {
      "type": "object",
      "title": "ScaleDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Scale\" to function as this type.",
          "const": "Scale"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ScaleDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ScaleDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Scale"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "ScaleX": {
          "type": "number",
          "default": 1
        },
        "ScaleY": {
          "type": "number",
          "default": 1
        },
        "ScaleZ": {
          "type": "number",
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ShellDensityAsset": {
      "type": "object",
      "title": "ShellDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Shell\" to function as this type.",
          "const": "Shell"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ShellDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ShellDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Shell"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Axis": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Mirror": {
          "type": "boolean",
          "default": false
        },
        "AngleCurve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "DistanceCurve": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ConstantCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceExponentialCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/DistanceSCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/FloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ImportedCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/InverterCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/ManualCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/MultiplierCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/NotCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothCeilingCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothClampCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothFloorCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMaxCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SmoothMinCurveAsset"
            },
            {
              "$ref": "common.schema.json#/$defs/SumCurveAsset"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SimplexNoise2dDensityAsset": {
      "type": "object",
      "title": "SimplexNoise2dDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SimplexNoise2D\" to function as this type.",
          "const": "SimplexNoise2D"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SimplexNoise2dDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SimplexNoise2dDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "SimplexNoise2D"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Lacunarity": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Persistence": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Scale": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Octaves": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SimplexNoise3DDensityAsset": {
      "type": "object",
      "title": "SimplexNoise3DDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SimplexNoise3D\" to function as this type.",
          "const": "SimplexNoise3D"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SimplexNoise3DDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SimplexNoise3DDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "SimplexNoise3D"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Lacunarity": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Persistence": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ScaleXZ": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ScaleY": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Octaves": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "Seed": {
          "type": [
            "string",
            "null"
          ],
          "default": "A"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SliderDensityAsset": {
      "type": "object",
      "title": "SliderDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Slider\" to function as this type.",
          "const": "Slider"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SliderDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SliderDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Slider"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "SlideX": {
          "type": "number",
          "default": 0
        },
        "SlideY": {
          "type": "number",
          "default": 0
        },
        "SlideZ": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothCeilingDensityAsset": {
      "type": "object",
      "title": "SmoothCeilingDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothCeiling\" to function as this type.",
          "const": "SmoothCeiling"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothCeilingDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothCeilingDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothCeiling"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Limit": {
          "type": "number",
          "default": 0
        },
        "SmoothRange": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothClampDensityAsset": {
      "type": "object",
      "title": "SmoothClampDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothClamp\" to function as this type.",
          "const": "SmoothClamp"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothClampDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothClampDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothClamp"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "WallA": {
          "type": "number",
          "default": -1
        },
        "WallB": {
          "type": "number",
          "default": 1
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 0.01
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothFloorDensityAsset": {
      "type": "object",
      "title": "SmoothFloorDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothFloor\" to function as this type.",
          "const": "SmoothFloor"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothFloorDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothFloorDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothFloor"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Limit": {
          "type": "number",
          "default": 0
        },
        "SmoothRange": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothMaxDensityAsset": {
      "type": "object",
      "title": "SmoothMaxDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothMax\" to function as this type.",
          "const": "SmoothMax"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothMaxDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothMaxDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothMax"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SmoothMinDensityAsset": {
      "type": "object",
      "title": "SmoothMinDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SmoothMin\" to function as this type.",
          "const": "SmoothMin"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SmoothMinDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SmoothMinDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "SmoothMin"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Range": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SqrtDensityAsset": {
      "type": "object",
      "title": "SqrtDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Sqrt\" to function as this type.",
          "const": "Sqrt"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SqrtDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SqrtDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Sqrt"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SumDensityAsset": {
      "type": "object",
      "title": "SumDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Sum\" to function as this type.",
          "const": "Sum"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SumDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SumDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Sum"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SwitchDensityAsset": {
      "type": "object",
      "title": "SwitchDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Switch\" to function as this type.",
          "const": "Switch"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SwitchDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SwitchDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Switch"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "SwitchCases": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/SwitchCaseAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SwitchCaseAsset": {
      "type": "object",
      "title": "SwitchCaseAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SwitchCaseAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SwitchCaseAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "SwitchCaseAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "CaseState": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "SwitchStateDensityAsset": {
      "type": "object",
      "title": "SwitchStateDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SwitchState\" to function as this type.",
          "const": "SwitchState"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SwitchStateDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SwitchStateDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "SwitchState"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "SwitchState": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TerrainDensityAsset": {
      "type": "object",
      "title": "TerrainDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Terrain\" to function as this type.",
          "const": "Terrain"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TerrainDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TerrainDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "Terrain"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "VectorWarpDensityAsset": {
      "type": "object",
      "title": "VectorWarpDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"VectorWarp\" to function as this type.",
          "const": "VectorWarp"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another VectorWarpDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **VectorWarpDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "VectorWarp"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "WarpFactor": {
          "type": "number",
          "default": 1
        },
        "WarpVector": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "XOverrideDensityAsset": {
      "type": "object",
      "title": "XOverrideDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"XOverride\" to function as this type.",
          "const": "XOverride"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another XOverrideDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **XOverrideDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "XOverride"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "XValueDensityAsset": {
      "type": "object",
      "title": "XValueDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"XValue\" to function as this type.",
          "const": "XValue"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another XValueDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **XValueDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "XValue"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "YOverrideDensityAsset": {
      "type": "object",
      "title": "YOverrideDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"YOverride\" to function as this type.",
          "const": "YOverride"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another YOverrideDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **YOverrideDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "YOverride"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "YValueDensityAsset": {
      "type": "object",
      "title": "YValueDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"YValue\" to function as this type.",
          "const": "YValue"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another YValueDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **YValueDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "YValue"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ZOverrideDensityAsset": {
      "type": "object",
      "title": "ZOverrideDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ZOverride\" to function as this type.",
          "const": "ZOverride"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ZOverrideDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ZOverrideDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "ZOverride"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Value": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ZValueDensityAsset": {
      "type": "object",
      "title": "ZValueDensityAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ZValue\" to function as this type.",
          "const": "ZValue"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ZValueDensityAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ZValueDensityAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "DensityAsset",
            "mapKey": "Type",
            "mapKeyValue": "ZValue"
          }
        },
        "Inputs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "DensityAsset.json#"
          }
        },
        "Skip": {
          "type": "boolean",
          "default": false
        },
        "ExportAs": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DeployableAoeConfig": {
      "type": "object",
      "title": "DeployableAoeConfig",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Aoe\" to function as this type.",
          "const": "Aoe"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ],
          "description": "Used to identify this deployable for uses such as MaxLiveCount"
        },
        "MaxLiveCount": {
          "type": "integer",
          "description": "The maximum amount of this deployable that can be live at once",
          "default": 2147483647
        },
        "Model": {
          "type": "string"
        },
        "ModelPreview": {
          "type": [
            "string",
            "null"
          ]
        },
        "ModelScale": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "LiveDuration": {
          "description": "The duration of the lifetime of the deployable in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Invulnerable": {
          "type": "boolean",
          "description": "Whether this deployable is invulnerable to damage or not",
          "default": false
        },
        "Stats": {
          "type": [
            "object",
            "null"
          ],
          "description": "The default stat configuration for the deployable",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/StatConfig"
          }
        },
        "DeploySoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play upon deployment (at deployment location)"
        },
        "DespawnSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play when despawning"
        },
        "DieSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play when despawning due to death"
        },
        "AmbientSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play ambiently from the deployable while it's in the world"
        },
        "SpawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of model particles to play when this deployable is spawned.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "DespawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of model particles to play when this deployable is despawned.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "DebugVisuals": {
          "type": "boolean",
          "description": "Whether or not to display debug visuals.",
          "default": false
        },
        "AllowPlaceOnWalls": {
          "type": "boolean",
          "description": "Whether or not this deployable can be placed on walls.",
          "default": false
        },
        "WireframeDebugVisuals": {
          "type": "boolean",
          "description": "Whether debug visuals will be wireframe or have color.",
          "default": false
        },
        "HitboxCollisionConfig": {
          "type": [
            "string",
            "null"
          ],
          "description": "The HitboxCollision config to apply to the deployable."
        },
        "CountTowardsGlobalLimit": {
          "type": "boolean",
          "description": "Whether or not this deployable counts towards global deployable limit",
          "default": true
        },
        "Shape": {
          "type": [
            "string",
            "null"
          ],
          "title": "Shape",
          "description": "The shape of the detection area",
          "enum": [
            "Sphere",
            "Cylinder"
          ],
          "default": "Sphere"
        },
        "StartRadius": {
          "description": "The initial detection radius",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "EndRadius": {
          "description": "If set, the detection radius will expand to this size over the RadiusChangeTime (RadiusChangeTime must be set)",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Height": {
          "description": "The height of the Shape, if using a cylinder shape",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RadiusChangeTime": {
          "description": "The time (starting at spawn) it takes to change from StartRadius to EndRadius",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageInterval": {
          "description": "The interval between damage being applied to targets in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageAmount": {
          "description": "The amount of damage to apply to targets per interval",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageCause": {
          "description": "The amount of damage to apply to targets per interval",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to DamageCause"
            },
            {
              "$ref": "DamageCause.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ApplyEffects": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to EntityEffect"
              },
              {
                "$ref": "EntityEffect.json#"
              }
            ]
          }
        },
        "AttackOwner": {
          "type": "boolean",
          "description": "Whether or not the owner is affected by the attack & effect of this deployable",
          "default": false
        },
        "AttackTeam": {
          "type": "boolean",
          "description": "Whether or not the team is affected by the attack & effect of this deployable",
          "default": false
        },
        "AttackEnemies": {
          "type": "boolean",
          "description": "Whether or not this deployable interacts with non-team entities",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "StatConfig": {
      "type": "object",
      "title": "StatConfig",
      "description": "Initial and maximum values for a stat.",
      "properties": {
        "Max": {
          "description": "The maximum value for the stat.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "Initial": {
          "description": "The initial value for the stat. If omitted, will be set to max.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "DeployableTrapConfig": {
      "type": "object",
      "title": "DeployableTrapConfig",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Trap\" to function as this type.",
          "const": "Trap"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ],
          "description": "Used to identify this deployable for uses such as MaxLiveCount"
        },
        "MaxLiveCount": {
          "type": "integer",
          "description": "The maximum amount of this deployable that can be live at once",
          "default": 2147483647
        },
        "Model": {
          "type": "string"
        },
        "ModelPreview": {
          "type": [
            "string",
            "null"
          ]
        },
        "ModelScale": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "LiveDuration": {
          "description": "The duration of the lifetime of the deployable in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Invulnerable": {
          "type": "boolean",
          "description": "Whether this deployable is invulnerable to damage or not",
          "default": false
        },
        "Stats": {
          "type": [
            "object",
            "null"
          ],
          "description": "The default stat configuration for the deployable",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/StatConfig"
          }
        },
        "DeploySoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play upon deployment (at deployment location)"
        },
        "DespawnSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play when despawning"
        },
        "DieSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play when despawning due to death"
        },
        "AmbientSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play ambiently from the deployable while it's in the world"
        },
        "SpawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of model particles to play when this deployable is spawned.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "DespawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of model particles to play when this deployable is despawned.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "DebugVisuals": {
          "type": "boolean",
          "description": "Whether or not to display debug visuals.",
          "default": false
        },
        "AllowPlaceOnWalls": {
          "type": "boolean",
          "description": "Whether or not this deployable can be placed on walls.",
          "default": false
        },
        "WireframeDebugVisuals": {
          "type": "boolean",
          "description": "Whether debug visuals will be wireframe or have color.",
          "default": false
        },
        "HitboxCollisionConfig": {
          "type": [
            "string",
            "null"
          ],
          "description": "The HitboxCollision config to apply to the deployable."
        },
        "CountTowardsGlobalLimit": {
          "type": "boolean",
          "description": "Whether or not this deployable counts towards global deployable limit",
          "default": true
        },
        "Shape": {
          "type": [
            "string",
            "null"
          ],
          "title": "Shape",
          "description": "The shape of the detection area",
          "enum": [
            "Sphere",
            "Cylinder"
          ],
          "default": "Sphere"
        },
        "StartRadius": {
          "description": "The initial detection radius",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "EndRadius": {
          "description": "If set, the detection radius will expand to this size over the RadiusChangeTime (RadiusChangeTime must be set)",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Height": {
          "description": "The height of the Shape, if using a cylinder shape",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RadiusChangeTime": {
          "description": "The time (starting at spawn) it takes to change from StartRadius to EndRadius",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageInterval": {
          "description": "The interval between damage being applied to targets in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageAmount": {
          "description": "The amount of damage to apply to targets per interval",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageCause": {
          "description": "The amount of damage to apply to targets per interval",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to DamageCause"
            },
            {
              "$ref": "DamageCause.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ApplyEffects": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to EntityEffect"
              },
              {
                "$ref": "EntityEffect.json#"
              }
            ]
          }
        },
        "AttackOwner": {
          "type": "boolean",
          "description": "Whether or not the owner is affected by the attack & effect of this deployable",
          "default": false
        },
        "AttackTeam": {
          "type": "boolean",
          "description": "Whether or not the team is affected by the attack & effect of this deployable",
          "default": false
        },
        "AttackEnemies": {
          "type": "boolean",
          "description": "Whether or not this deployable interacts with non-team entities",
          "default": true
        },
        "FuzeDuration": {
          "description": "The time it will take for the trap to become active",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ActiveDuration": {
          "description": "The time the trap will stay alive after getting triggered",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DestroyOnTriggered": {
          "type": "boolean",
          "description": "Whether the trap will disappear when it's triggered by a players",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "DeployableTrapSpawnerConfig": {
      "type": "object",
      "title": "DeployableTrapSpawnerConfig",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TrapSpawner\" to function as this type.",
          "const": "TrapSpawner"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ],
          "description": "Used to identify this deployable for uses such as MaxLiveCount"
        },
        "MaxLiveCount": {
          "type": "integer",
          "description": "The maximum amount of this deployable that can be live at once",
          "default": 2147483647
        },
        "Model": {
          "type": "string"
        },
        "ModelPreview": {
          "type": [
            "string",
            "null"
          ]
        },
        "ModelScale": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "LiveDuration": {
          "description": "The duration of the lifetime of the deployable in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Invulnerable": {
          "type": "boolean",
          "description": "Whether this deployable is invulnerable to damage or not",
          "default": false
        },
        "Stats": {
          "type": [
            "object",
            "null"
          ],
          "description": "The default stat configuration for the deployable",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/StatConfig"
          }
        },
        "DeploySoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play upon deployment (at deployment location)"
        },
        "DespawnSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play when despawning"
        },
        "DieSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play when despawning due to death"
        },
        "AmbientSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play ambiently from the deployable while it's in the world"
        },
        "SpawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of model particles to play when this deployable is spawned.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "DespawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of model particles to play when this deployable is despawned.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "DebugVisuals": {
          "type": "boolean",
          "description": "Whether or not to display debug visuals.",
          "default": false
        },
        "AllowPlaceOnWalls": {
          "type": "boolean",
          "description": "Whether or not this deployable can be placed on walls.",
          "default": false
        },
        "WireframeDebugVisuals": {
          "type": "boolean",
          "description": "Whether debug visuals will be wireframe or have color.",
          "default": false
        },
        "HitboxCollisionConfig": {
          "type": [
            "string",
            "null"
          ],
          "description": "The HitboxCollision config to apply to the deployable."
        },
        "CountTowardsGlobalLimit": {
          "type": "boolean",
          "description": "Whether or not this deployable counts towards global deployable limit",
          "default": true
        },
        "Shape": {
          "type": [
            "string",
            "null"
          ],
          "title": "Shape",
          "description": "The shape of the detection area",
          "enum": [
            "Sphere",
            "Cylinder"
          ],
          "default": "Sphere"
        },
        "StartRadius": {
          "description": "The initial detection radius",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "EndRadius": {
          "description": "If set, the detection radius will expand to this size over the RadiusChangeTime (RadiusChangeTime must be set)",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Height": {
          "description": "The height of the Shape, if using a cylinder shape",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RadiusChangeTime": {
          "description": "The time (starting at spawn) it takes to change from StartRadius to EndRadius",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageInterval": {
          "description": "The interval between damage being applied to targets in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageAmount": {
          "description": "The amount of damage to apply to targets per interval",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DamageCause": {
          "description": "The amount of damage to apply to targets per interval",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to DamageCause"
            },
            {
              "$ref": "DamageCause.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ApplyEffects": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to EntityEffect"
              },
              {
                "$ref": "EntityEffect.json#"
              }
            ]
          }
        },
        "AttackOwner": {
          "type": "boolean",
          "description": "Whether or not the owner is affected by the attack & effect of this deployable",
          "default": false
        },
        "AttackTeam": {
          "type": "boolean",
          "description": "Whether or not the team is affected by the attack & effect of this deployable",
          "default": false
        },
        "AttackEnemies": {
          "type": "boolean",
          "description": "Whether or not this deployable interacts with non-team entities",
          "default": true
        },
        "FuzeDuration": {
          "description": "The time it will take for the trap to become active",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ActiveDuration": {
          "description": "The time the trap will stay alive after getting triggered",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DestroyOnTriggered": {
          "type": "boolean",
          "description": "Whether the trap will disappear when it's triggered by a players",
          "default": false
        },
        "DeployableConfig": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "DeployableTurretConfig": {
      "type": "object",
      "title": "DeployableTurretConfig",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Turret\" to function as this type.",
          "const": "Turret"
        },
        "Id": {
          "type": [
            "string",
            "null"
          ],
          "description": "Used to identify this deployable for uses such as MaxLiveCount"
        },
        "MaxLiveCount": {
          "type": "integer",
          "description": "The maximum amount of this deployable that can be live at once",
          "default": 2147483647
        },
        "Model": {
          "type": "string"
        },
        "ModelPreview": {
          "type": [
            "string",
            "null"
          ]
        },
        "ModelScale": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "LiveDuration": {
          "description": "The duration of the lifetime of the deployable in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Invulnerable": {
          "type": "boolean",
          "description": "Whether this deployable is invulnerable to damage or not",
          "default": false
        },
        "Stats": {
          "type": [
            "object",
            "null"
          ],
          "description": "The default stat configuration for the deployable",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/StatConfig"
          }
        },
        "DeploySoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play upon deployment (at deployment location)"
        },
        "DespawnSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play when despawning"
        },
        "DieSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play when despawning due to death"
        },
        "AmbientSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the sound to play ambiently from the deployable while it's in the world"
        },
        "SpawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of model particles to play when this deployable is spawned.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "DespawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of model particles to play when this deployable is despawned.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "DebugVisuals": {
          "type": "boolean",
          "description": "Whether or not to display debug visuals.",
          "default": false
        },
        "AllowPlaceOnWalls": {
          "type": "boolean",
          "description": "Whether or not this deployable can be placed on walls.",
          "default": false
        },
        "WireframeDebugVisuals": {
          "type": "boolean",
          "description": "Whether debug visuals will be wireframe or have color.",
          "default": false
        },
        "HitboxCollisionConfig": {
          "type": [
            "string",
            "null"
          ],
          "description": "The HitboxCollision config to apply to the deployable."
        },
        "CountTowardsGlobalLimit": {
          "type": "boolean",
          "description": "Whether or not this deployable counts towards global deployable limit",
          "default": true
        },
        "TrackableRadius": {
          "description": "The radius in which a targeted entity can be tracked",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DetectionRadius": {
          "description": "The radius in which an entity can be targeted",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RotationSpeed": {
          "description": "The speed at which the turret can rotate to hit it's target",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "PreferOwnerTarget": {
          "type": "boolean",
          "description": "If true, will prefer targeting entities that the owner is attacking",
          "default": false
        },
        "Ammo": {
          "type": "integer",
          "description": "The total ammo the turret has, each projectile will consume one",
          "default": 0
        },
        "DeployDelay": {
          "description": "The delay in seconds until the deployable is ready to begin targeting logic",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ProjectileConfig": {
          "$ref": "ProjectileConfig.json#"
        },
        "ShotInterval": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "BurstCount": {
          "type": "integer",
          "default": 0
        },
        "BurstCooldown": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ProjectileDamage": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CanShootOwner": {
          "type": "boolean",
          "default": false
        },
        "Knockback": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DirectionalKnockback"
            },
            {
              "$ref": "common.schema.json#/$defs/ForceKnockback"
            },
            {
              "$ref": "common.schema.json#/$defs/PointKnockback"
            },
            {
              "type": "null"
            }
          ]
        },
        "TargetOffset": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "DoLineOfSightTest": {
          "type": "boolean",
          "default": true
        },
        "ProjectileHitWorldSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The positioned sound event played to surrounding players when the projectile hits a player"
        },
        "ProjectileHitLocalSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The positioned sound event played to a player hit by the projectile"
        },
        "RespectTeams": {
          "type": "boolean",
          "default": true
        },
        "ProjectileSpawnOffsets": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/Vector3d"
          }
        }
      },
      "additionalProperties": false
    },
    "DirectionalKnockback": {
      "type": "object",
      "title": "DirectionalKnockback",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"Directional\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "Force",
                  "Point"
                ]
              }
            }
          ]
        },
        "Force": {
          "type": "number",
          "default": 0
        },
        "Duration": {
          "description": "The duration for which the knockback force should be continuously applied. If 0, force is applied once.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "VelocityType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ChangeVelocityType",
          "enumDescriptions": [
            "Adds the velocity to any existing velocity",
            "Changes the velocity to the given value. Overriding existing values."
          ],
          "markdownEnumDescriptions": [
            "Adds the velocity to any existing velocity",
            "Changes the velocity to the given value. Overriding existing values."
          ],
          "enum": [
            "Add",
            "Set"
          ],
          "default": "Add"
        },
        "VelocityConfig": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/VelocityConfig"
            },
            {
              "type": "null"
            }
          ]
        },
        "RelativeX": {
          "type": "number",
          "default": 0
        },
        "VelocityY": {
          "type": "number",
          "default": 0
        },
        "RelativeZ": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "VelocityConfig": {
      "type": "object",
      "title": "VelocityConfig",
      "properties": {
        "GroundResistance": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "GroundResistanceMax": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "AirResistance": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "AirResistanceMax": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Threshold": {
          "description": "The threshold of the velocity's length before resistance starts to transition to the Max values (if set)",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Style": {
          "type": [
            "string",
            "null"
          ],
          "title": "VelocityThresholdStyle",
          "description": "Whether the transition from min to max resistance values should be linear or not",
          "enum": [
            "Linear",
            "Exp"
          ],
          "default": "Linear"
        }
      },
      "additionalProperties": false
    },
    "ForceKnockback": {
      "type": "object",
      "title": "ForceKnockback",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Force\" to function as this type.",
          "const": "Force"
        },
        "Force": {
          "type": "number",
          "default": 0
        },
        "Duration": {
          "description": "The duration for which the knockback force should be continuously applied. If 0, force is applied once.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "VelocityType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ChangeVelocityType",
          "enumDescriptions": [
            "Adds the velocity to any existing velocity",
            "Changes the velocity to the given value. Overriding existing values."
          ],
          "markdownEnumDescriptions": [
            "Adds the velocity to any existing velocity",
            "Changes the velocity to the given value. Overriding existing values."
          ],
          "enum": [
            "Add",
            "Set"
          ],
          "default": "Add"
        },
        "VelocityConfig": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/VelocityConfig"
            },
            {
              "type": "null"
            }
          ]
        },
        "Direction": {
          "default": {
            "X": 0,
            "Y": 1,
            "Z": 0
          },
          "$ref": "common.schema.json#/$defs/Vector3d"
        }
      },
      "additionalProperties": false
    },
    "PointKnockback": {
      "type": "object",
      "title": "PointKnockback",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Point\" to function as this type.",
          "const": "Point"
        },
        "Force": {
          "type": "number",
          "default": 0
        },
        "Duration": {
          "description": "The duration for which the knockback force should be continuously applied. If 0, force is applied once.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "VelocityType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ChangeVelocityType",
          "enumDescriptions": [
            "Adds the velocity to any existing velocity",
            "Changes the velocity to the given value. Overriding existing values."
          ],
          "markdownEnumDescriptions": [
            "Adds the velocity to any existing velocity",
            "Changes the velocity to the given value. Overriding existing values."
          ],
          "enum": [
            "Add",
            "Set"
          ],
          "default": "Add"
        },
        "VelocityConfig": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/VelocityConfig"
            },
            {
              "type": "null"
            }
          ]
        },
        "VelocityY": {
          "type": "number",
          "default": 0
        },
        "RotateY": {
          "type": "integer",
          "default": 0
        },
        "OffsetX": {
          "type": "integer",
          "default": 0
        },
        "OffsetZ": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ApplicationEffects": {
      "type": "object",
      "title": "ApplicationEffects",
      "properties": {
        "EntityBottomTint": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "EntityTopTint": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "EntityAnimationId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Particles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "FirstPersonParticles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "ScreenEffect": {
          "type": [
            "string",
            "null"
          ]
        },
        "HorizontalSpeedMultiplier": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "KnockbackMultiplier": {
          "type": "number",
          "minimum": 0,
          "default": 1
        },
        "LocalSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "Local sound event played to the affected player"
        },
        "WorldSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "World sound event played to surrounding players"
        },
        "ModelVFXId": {
          "type": [
            "string",
            "null"
          ]
        },
        "MovementEffects": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/MovementEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "AbilityEffects": {
          "description": "Handles any effects applied that are affiliated with abilities",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AbilityEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "MouseSensitivityAdjustmentTarget": {
          "description": "What is the target modifier to apply to mouse sensitivity while this interaction is active.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "MouseSensitivityAdjustmentDuration": {
          "description": "Override the global linear modifier adjustment with this as the time to go from 1.0 to 0.0.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "MovementEffects": {
      "type": "object",
      "title": "MovementEffects",
      "properties": {
        "DisableAll": {
          "type": "boolean",
          "description": "Determines whether all movement input is disabled",
          "default": false
        },
        "DisableForward": {
          "type": "boolean",
          "description": "Determines whether forwards movement input is disabled",
          "default": false
        },
        "DisableBackward": {
          "type": "boolean",
          "description": "Determines whether backwards movement input is disabled",
          "default": false
        },
        "DisableLeft": {
          "type": "boolean",
          "description": "Determines whether left-strafe movement input is disabled",
          "default": false
        },
        "DisableRight": {
          "type": "boolean",
          "description": "Determines whether right-strafe movement input is disabled",
          "default": false
        },
        "DisableSprint": {
          "type": "boolean",
          "description": "Determines whether sprint input is disabled",
          "default": false
        },
        "DisableJump": {
          "type": "boolean",
          "description": "Determines whether jump input is disabled",
          "default": false
        },
        "DisableCrouch": {
          "type": "boolean",
          "description": "Determines whether crouch input is disabled",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "AbilityEffects": {
      "type": "object",
      "title": "AbilityEffects",
      "properties": {
        "Disabled": {
          "type": [
            "array",
            "null"
          ],
          "title": "Set",
          "description": "A collection of interaction types to become disabled while the entity effect affiliated with this ability effect is active",
          "items": {
            "type": "string",
            "title": "InteractionType",
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          },
          "uniqueItems": true
        }
      },
      "additionalProperties": false
    },
    "DamageCalculator": {
      "type": "object",
      "title": "DamageCalculator",
      "properties": {
        "Type": {
          "type": [
            "string",
            "null"
          ],
          "title": "Type",
          "enum": [
            "Dps",
            "Absolute"
          ],
          "default": "Absolute"
        },
        "Class": {
          "type": "string",
          "title": "DamageClass",
          "description": "The class of the damage being created, used by the damage system to apply modifiers based on equipment of the source.",
          "enum": [
            "Unknown",
            "Light",
            "Charged",
            "Signature"
          ],
          "default": "Unknown"
        },
        "BaseDamage": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of string to float",
          "additionalProperties": {
            "type": "number"
          }
        },
        "SequentialModifierStep": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SequentialModifierMinimum": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RandomPercentageModifier": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "DamageEffects": {
      "type": "object",
      "title": "DamageEffects",
      "properties": {
        "ModelParticles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "WorldParticles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/WorldParticle"
          }
        },
        "LocalSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "WorldSoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "PlayerSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The sound to play to a player receiving the damage."
        },
        "ViewDistance": {
          "type": "number",
          "default": 75
        },
        "Knockback": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DirectionalKnockback"
            },
            {
              "$ref": "common.schema.json#/$defs/ForceKnockback"
            },
            {
              "$ref": "common.schema.json#/$defs/PointKnockback"
            },
            {
              "type": "null"
            }
          ]
        },
        "CameraEffect": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to CameraEffect"
            },
            {
              "$ref": "CameraEffect.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "StaminaDrainMultiplier": {
          "description": "A multiplier to apply to any stamina drain caused by this damage.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "WorldParticle": {
      "type": "object",
      "title": "WorldParticle",
      "description": "Particle System that can be spawned in the world.",
      "properties": {
        "SystemId": {
          "type": "string",
          "description": "The id of the particle system."
        },
        "Color": {
          "description": "The colour used if none was specified in the particle settings.",
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scale": {
          "description": "The scale of the particle system.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "PositionOffset": {
          "description": "The position offset from the spawn position.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "RotationOffset": {
          "description": "The rotation offset from the spawn rotation.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Direction"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ModelOverride": {
      "type": "object",
      "title": "ModelOverride",
      "properties": {
        "Model": {
          "type": [
            "string",
            "null"
          ]
        },
        "Texture": {
          "type": [
            "string",
            "null"
          ]
        },
        "AnimationSets": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/AnimationSet"
          }
        }
      },
      "additionalProperties": false
    },
    "AnimationSet": {
      "type": "object",
      "title": "AnimationSet",
      "properties": {
        "Animations": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/Animation"
          },
          "minItems": 1
        },
        "NextAnimationDelay": {
          "anyOf": [
            {
              "default": {
                "Min": 2,
                "Max": 10
              },
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Animation": {
      "type": "object",
      "title": "Animation",
      "properties": {
        "Animation": {
          "type": "string"
        },
        "Speed": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "BlendingDuration": {
          "type": "number",
          "minimum": 0,
          "default": 0.20000000298023224
        },
        "Looping": {
          "type": "boolean",
          "default": true
        },
        "Weight": {
          "type": "number",
          "default": 1
        },
        "FootstepIntervals": {
          "type": [
            "array",
            "null"
          ],
          "description": "The intervals (in percentage of the animation duration) at which footsteps are supposed to occur. Only relevant for movement animations (used for timing footstep sound effects).",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100
          }
        },
        "SoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "PassiveLoopCount": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "StaticModifier": {
      "type": "object",
      "title": "StaticModifier",
      "properties": {
        "Target": {
          "type": [
            "string",
            "null"
          ],
          "title": "ModifierTarget",
          "enum": [
            "Min",
            "Max"
          ],
          "default": "Max"
        },
        "CalculationType": {
          "type": "string",
          "title": "CalculationType",
          "enum": [
            "Additive",
            "Multiplicative"
          ]
        },
        "Amount": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "Regenerating": {
      "type": "object",
      "title": "Regenerating",
      "properties": {
        "Interval": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Amount": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ClampAtZero": {
          "type": "boolean",
          "description": "Prevents this regenerating value from taking the stat value below zero.",
          "default": false
        },
        "RegenType": {
          "type": [
            "string",
            "null"
          ],
          "title": "RegenType",
          "enum": [
            "Additive",
            "Percentage"
          ]
        },
        "Conditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/AliveCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/ChargingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/EnvironmentCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/GlidingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/LogicCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/NoDamageTakenCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/OutOfCombatCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/PlayerCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/RegenHealthCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/SprintingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/StatCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/SuffocatingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/WieldingCondition"
              }
            ]
          }
        },
        "Modifiers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/RegeneratingModifier"
          }
        }
      },
      "additionalProperties": false
    },
    "AliveCondition": {
      "type": "object",
      "title": "AliveCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Alive\" to function as this type.",
          "const": "Alive"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "ChargingCondition": {
      "type": "object",
      "title": "ChargingCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Charging\" to function as this type.",
          "const": "Charging"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        },
        "Delay": {
          "type": "number",
          "description": "The delay duration within which a recent charge is considered valid."
        }
      },
      "additionalProperties": false
    },
    "EnvironmentCondition": {
      "type": "object",
      "title": "EnvironmentCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Environment\" to function as this type.",
          "const": "Environment"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        },
        "Environments": {
          "type": [
            "array",
            "null"
          ],
          "description": "The environments to evaluate the condition against.",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "GlidingCondition": {
      "type": "object",
      "title": "GlidingCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Gliding\" to function as this type.",
          "const": "Gliding"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "LogicCondition": {
      "type": "object",
      "title": "LogicCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LogicCondition\" to function as this type.",
          "const": "LogicCondition"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        },
        "Operator": {
          "type": "string",
          "title": "Operator",
          "description": "The logical operator to combine the conditions.",
          "enum": [
            "And",
            "Or"
          ]
        },
        "Conditions": {
          "type": "array",
          "description": "The array of conditions to be evaluated.",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/AliveCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/ChargingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/EnvironmentCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/GlidingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/LogicCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/NoDamageTakenCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/OutOfCombatCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/PlayerCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/RegenHealthCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/SprintingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/StatCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/SuffocatingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/WieldingCondition"
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "NoDamageTakenCondition": {
      "type": "object",
      "title": "NoDamageTakenCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"NoDamageTaken\" to function as this type.",
          "const": "NoDamageTaken"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        },
        "Delay": {
          "type": "number",
          "description": "The delay duration for the no damage taken condition."
        }
      },
      "additionalProperties": false
    },
    "OutOfCombatCondition": {
      "type": "object",
      "title": "OutOfCombatCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OutOfCombat\" to function as this type.",
          "const": "OutOfCombat"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        },
        "DelaySeconds": {
          "type": [
            "number",
            "null"
          ],
          "description": "Delay before an entity is considered out of combat. Expressed in seconds."
        }
      },
      "additionalProperties": false
    },
    "PlayerCondition": {
      "type": "object",
      "title": "PlayerCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Player\" to function as this type.",
          "const": "Player"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        },
        "GameMode": {
          "type": [
            "string",
            "null"
          ],
          "title": "GameMode",
          "description": "The game mode to check for. If null, the condition always passes.",
          "enum": [
            "Adventure",
            "Creative"
          ]
        }
      },
      "additionalProperties": false
    },
    "RegenHealthCondition": {
      "type": "object",
      "title": "RegenHealthCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"RegenHealth\" to function as this type.",
          "const": "RegenHealth"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "SprintingCondition": {
      "type": "object",
      "title": "SprintingCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Sprinting\" to function as this type.",
          "const": "Sprinting"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "StatCondition": {
      "type": "object",
      "title": "StatCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Stat\" to function as this type.",
          "const": "Stat"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        },
        "Stat": {
          "type": "string",
          "description": "The stat to evaluate the condition against."
        },
        "Amount": {
          "description": "The amount to compare the entity's stat against.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "Comparison": {
          "type": [
            "string",
            "null"
          ],
          "title": "StatComparisonType",
          "description": "The comparison type used for evaluating the stat condition.",
          "enum": [
            "Gte",
            "Gt",
            "Lte",
            "Lt",
            "Equal"
          ],
          "default": "Gte"
        }
      },
      "additionalProperties": false
    },
    "SuffocatingCondition": {
      "type": "object",
      "title": "SuffocatingCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Suffocating\" to function as this type.",
          "const": "Suffocating"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "WieldingCondition": {
      "type": "object",
      "title": "WieldingCondition",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Wielding\" to function as this type.",
          "const": "Wielding"
        },
        "Inverse": {
          "type": "boolean",
          "description": "Determines whether the condition is inverted.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "RegeneratingModifier": {
      "type": "object",
      "title": "RegeneratingModifier",
      "properties": {
        "Conditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/AliveCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/ChargingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/EnvironmentCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/GlidingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/LogicCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/NoDamageTakenCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/OutOfCombatCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/PlayerCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/RegenHealthCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/SprintingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/StatCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/SuffocatingCondition"
              },
              {
                "$ref": "common.schema.json#/$defs/WieldingCondition"
              }
            ]
          }
        },
        "Amount": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "EntityStatEffects": {
      "type": "object",
      "title": "EntityStatEffects",
      "properties": {
        "TriggerAtZero": {
          "type": "boolean",
          "description": "Indicates that the effects should trigger when the stat reaches zero",
          "default": false
        },
        "SoundEventId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Particles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "Interactions": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "CombatTextUIComponent": {
      "type": "object",
      "title": "CombatTextUIComponent",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CombatText\" to function as this type.",
          "const": "CombatText"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CombatTextUIComponent most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CombatTextUIComponent** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "EntityUIComponent",
            "mapKey": "Type",
            "mapKeyValue": "CombatText"
          }
        },
        "HitboxOffset": {
          "description": "Offset from the centre of the entity's hitbox to display this component.",
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0
              },
              "$ref": "common.schema.json#/$defs/Vector2f"
            },
            {
              "type": "null"
            }
          ]
        },
        "RandomPositionOffsetRange": {
          "description": "The maximum range for randomly offsetting text instances from their starting position. Values are treated as absolute and apply in both directions of the axis.",
          "$ref": "common.schema.json#/$defs/RangeVector2f"
        },
        "ViewportMargin": {
          "description": "The minimum distance (in px) from the edges of the viewport that text instances should clamp to.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Duration": {
          "description": "The duration for which text instances in this component should be visible.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "HitAngleModifierStrength": {
          "description": "Strength of the modifier to apply to the X axis of a position animation (if set) based on the angle of a melee attack.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "FontSize": {
          "description": "The font size to apply to text instances.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "TextColor": {
          "description": "The text color to apply to text instances.",
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "AnimationEvents": {
          "type": "array",
          "description": "Animation events for controlling animation of scale, position, and opacity.",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/CombatTextUIComponentOpacityAnimationEvent"
              },
              {
                "$ref": "common.schema.json#/$defs/CombatTextUIComponentPositionAnimationEvent"
              },
              {
                "$ref": "common.schema.json#/$defs/CombatTextUIComponentScaleAnimationEvent"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Vector2f": {
      "type": "object",
      "title": "Vector2f",
      "properties": {
        "X": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Y": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "RangeVector2f": {
      "type": "object",
      "title": "RangeVector2f",
      "properties": {
        "X": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "Y": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "CombatTextUIComponentOpacityAnimationEvent": {
      "type": "object",
      "title": "CombatTextUIComponentOpacityAnimationEvent",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Opacity\" to function as this type.",
          "const": "Opacity"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CombatTextUIComponentOpacityAnimationEvent most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CombatTextUIComponentOpacityAnimationEvent** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CombatTextUIComponentAnimationEvent",
            "mapKey": "Type",
            "mapKeyValue": "Opacity"
          }
        },
        "StartAt": {
          "description": "The percentage of the display duration at which this event should begin.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "EndAt": {
          "description": "The percentage of the display duration at which this event should end.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "StartOpacity": {
          "description": "The opacity that should be applied to text instances before the animation event begins.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "EndOpacity": {
          "description": "The opacity that should be applied to text instances by the end of the animation.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CombatTextUIComponentPositionAnimationEvent": {
      "type": "object",
      "title": "CombatTextUIComponentPositionAnimationEvent",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Position\" to function as this type.",
          "const": "Position"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CombatTextUIComponentPositionAnimationEvent most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CombatTextUIComponentPositionAnimationEvent** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CombatTextUIComponentAnimationEvent",
            "mapKey": "Type",
            "mapKeyValue": "Position"
          }
        },
        "StartAt": {
          "description": "The percentage of the display duration at which this event should begin.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "EndAt": {
          "description": "The percentage of the display duration at which this event should end.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "PositionOffset": {
          "description": "The offset from the starting position that the text instance should animate to.",
          "$ref": "common.schema.json#/$defs/Vector2f"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CombatTextUIComponentScaleAnimationEvent": {
      "type": "object",
      "title": "CombatTextUIComponentScaleAnimationEvent",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Scale\" to function as this type.",
          "const": "Scale"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CombatTextUIComponentScaleAnimationEvent most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CombatTextUIComponentScaleAnimationEvent** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "CombatTextUIComponentAnimationEvent",
            "mapKey": "Type",
            "mapKeyValue": "Scale"
          }
        },
        "StartAt": {
          "description": "The percentage of the display duration at which this event should begin.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "EndAt": {
          "description": "The percentage of the display duration at which this event should end.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "StartScale": {
          "description": "The scale that should be applied to text instances before the animation event begins.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "EndScale": {
          "description": "The scale that should be applied to text instances by the end of the animation.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EntityStatUIComponent": {
      "type": "object",
      "title": "EntityStatUIComponent",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"EntityStat\" to function as this type.",
          "const": "EntityStat"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EntityStatUIComponent most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EntityStatUIComponent** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "EntityUIComponent",
            "mapKey": "Type",
            "mapKeyValue": "EntityStat"
          }
        },
        "HitboxOffset": {
          "description": "Offset from the centre of the entity's hitbox to display this component.",
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0
              },
              "$ref": "common.schema.json#/$defs/Vector2f"
            },
            {
              "type": "null"
            }
          ]
        },
        "EntityStat": {
          "type": "string",
          "description": "The entity stat to represent.",
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FluidParticle": {
      "type": "object",
      "title": "FluidParticle",
      "description": "Particle System that can be spawned in relation to a fluid.",
      "properties": {
        "SystemId": {
          "type": "string",
          "description": "The id of the particle system."
        },
        "Color": {
          "description": "The colour used if none was specified in the particle settings.",
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scale": {
          "description": "The scale of the particle system.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "WeatherForecast": {
      "type": "object",
      "title": "WeatherForecast",
      "properties": {
        "WeatherId": {
          "type": "string"
        },
        "Weight": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "RangeSizeFlockAsset": {
      "type": "object",
      "title": "RangeSizeFlockAsset",
      "description": "A flock definition in which the initial random size is picked from a range.",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"Default\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "Weighted"
                ]
              }
            }
          ]
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RangeSizeFlockAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RangeSizeFlockAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "FlockAsset"
          }
        },
        "MaxGrowSize": {
          "type": "integer",
          "description": "The maximum size a flock can possibly grow to after spawning. It is technically possible to spawn a flock without specifying a definition (e.g. via a command), in which case the maximum grow size is irrelevant.",
          "minimum": 0,
          "default": 8
        },
        "BlockedRoles": {
          "type": [
            "array",
            "null"
          ],
          "description": "An array of roles that will not be allowed to join this flock once it has been spawned. This is used to exclude roles from the list of allowed roles in the NPC configuration of the initial leader.",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "Size": {
          "type": "array",
          "description": "An array with two values specifying the random range from which to pick the size of the flock when it spawns. e.g. [ 2, 4 ] will randomly pick a size between two and four (inclusive).",
          "items": {
            "type": "integer",
            "exclusiveMinimum": 0
          },
          "minItems": 2,
          "maxItems": 2
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WeightedSizeFlockAsset": {
      "type": "object",
      "title": "WeightedSizeFlockAsset",
      "description": "A flock definition where the initial random size is picked from a weighted map of sizes.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Weighted\" to function as this type.",
          "const": "Weighted"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WeightedSizeFlockAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WeightedSizeFlockAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "FlockAsset",
            "mapKey": "Type",
            "mapKeyValue": "Weighted"
          }
        },
        "MaxGrowSize": {
          "type": "integer",
          "description": "The maximum size a flock can possibly grow to after spawning. It is technically possible to spawn a flock without specifying a definition (e.g. via a command), in which case the maximum grow size is irrelevant.",
          "minimum": 0,
          "default": 8
        },
        "BlockedRoles": {
          "type": [
            "array",
            "null"
          ],
          "description": "An array of roles that will not be allowed to join this flock once it has been spawned. This is used to exclude roles from the list of allowed roles in the NPC configuration of the initial leader.",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        },
        "MinSize": {
          "type": "integer",
          "description": "The absolute minimum size to spawn the flock with.",
          "minimum": 0,
          "default": 0
        },
        "SizeWeights": {
          "type": "array",
          "description": "An array of weights which is used in conjunction with the MinSize to determine the weighted size of the flock. The first value in the array corresponds to the weight of the minimum size and each successive value to a flock larger by one. e.g. If MinSize is 2 and SizeWeights is [ 25, 75 ], there will be a 25% chance that the flock will spawn with a size of 2 and a 75% chance that the flock will spawn with a size of 3. As these are weights, they do not need to add up to 100 and their percentage is relative to the total sum.",
          "markdownDescription": "An array of weights which is used in conjunction with the **MinSize** to determine the weighted size of the flock. The first value in the array corresponds to the weight of the minimum size and each successive value to a flock larger by one. e.g. If **MinSize** is 2 and **SizeWeights** is [ 25, 75 ], there will be a 25% chance that the flock will spawn with a size of 2 and a 75% chance that the flock will spawn with a size of 3. As these are weights, they do not need to add up to 100 and their percentage is relative to the total sum.",
          "items": {
            "type": "number",
            "exclusiveMinimum": 0
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DefaultFluidTicker": {
      "type": "object",
      "title": "DefaultFluidTicker",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"Default\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "Finite"
                ]
              }
            }
          ]
        },
        "FlowRate": {
          "description": "The tick frequency for this fluid type, in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CanDemote": {
          "type": "boolean",
          "description": "If false then the fluid will stay at its level",
          "default": true
        },
        "SupportedBy": {
          "type": [
            "string",
            "null"
          ]
        },
        "SpreadFluid": {
          "type": [
            "string",
            "null"
          ]
        },
        "Collisions": {
          "type": [
            "object",
            "null"
          ],
          "description": "Defines what happens when this fluid tries to spread into another fluid",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/FluidCollisionConfig"
          }
        }
      },
      "additionalProperties": false
    },
    "FluidCollisionConfig": {
      "type": "object",
      "title": "FluidCollisionConfig",
      "properties": {
        "BlockToPlace": {
          "type": [
            "string",
            "null"
          ],
          "description": "The block to place when a collision occurs"
        },
        "SoundEvent": {
          "type": [
            "string",
            "null"
          ]
        },
        "PlaceFluid": {
          "type": "boolean",
          "description": "Whether to still place the fluid on collision",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "FiniteFluidTicker": {
      "type": "object",
      "title": "FiniteFluidTicker",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Finite\" to function as this type.",
          "const": "Finite"
        },
        "FlowRate": {
          "description": "The tick frequency for this fluid type, in seconds",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CanDemote": {
          "type": "boolean",
          "description": "If false then the fluid will stay at its level",
          "default": true
        },
        "SupportedBy": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "FluidFXMovementSettings": {
      "type": "object",
      "title": "FluidFXMovementSettings",
      "properties": {
        "SwimUpSpeed": {
          "type": "number",
          "default": 0
        },
        "SwimDownSpeed": {
          "type": "number",
          "default": 0
        },
        "SinkSpeed": {
          "type": "number",
          "default": 0
        },
        "HorizontalSpeedMultiplier": {
          "type": "number",
          "default": 0
        },
        "FieldOfViewMultiplier": {
          "type": "number",
          "default": 0
        },
        "EntryVelocityMultiplier": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "GatheringConfig": {
      "type": "object",
      "title": "GatheringConfig",
      "properties": {
        "UnbreakableBlock": {
          "anyOf": [
            {
              "default": {},
              "$ref": "common.schema.json#/$defs/GatheringEffectsConfig"
            },
            {
              "type": "null"
            }
          ]
        },
        "IncorrectTool": {
          "anyOf": [
            {
              "default": {},
              "$ref": "common.schema.json#/$defs/GatheringEffectsConfig"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "GatheringEffectsConfig": {
      "type": "object",
      "title": "GatheringEffectsConfig",
      "properties": {
        "ParticleSystemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "SoundEventId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "WorldConfig": {
      "type": "object",
      "title": "WorldConfig",
      "properties": {
        "AllowBlockBreaking": {
          "type": "boolean",
          "default": true
        },
        "AllowBlockGathering": {
          "type": "boolean",
          "default": true
        },
        "AllowBlockPlacement": {
          "type": "boolean",
          "default": true
        },
        "BlockPlacementFragilityTimer": {
          "type": "number",
          "description": "The timer, in seconds, that blocks have after placement during which they are fragile and can be broken instantly",
          "default": 0
        },
        "DaytimeDurationSeconds": {
          "type": "integer",
          "description": "The number of real-world seconds it takes for the day to pass (from sunrise to sunset)",
          "default": 1728
        },
        "NighttimeDurationSeconds": {
          "type": "integer",
          "description": "The number of real-world seconds it takes for the night to pass (from sunset to sunrise)",
          "default": 1728
        },
        "TotalMoonPhases": {
          "type": "integer",
          "default": 5
        },
        "Sleep": {
          "description": "Configurations related to sleeping in this world (in beds)",
          "anyOf": [
            {
              "default": {
                "WakeUpHour": 5.5
              },
              "$ref": "common.schema.json#/$defs/SleepConfig"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "SleepConfig": {
      "type": "object",
      "title": "SleepConfig",
      "properties": {
        "WakeUpHour": {
          "description": "The in-game hour at which players naturally wake up from sleep.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "AllowedSleepHoursRange": {
          "type": [
            "array",
            "null"
          ],
          "description": "The in-game hours during which players can sleep to skip to the WakeUpHour. If missing, there is no restriction.",
          "items": {
            "type": "number"
          },
          "minItems": 2,
          "maxItems": 2
        }
      },
      "additionalProperties": false
    },
    "WorldMapConfig": {
      "type": "object",
      "title": "WorldMapConfig",
      "properties": {
        "DisplaySpawn": {
          "type": "boolean",
          "default": true
        },
        "DisplayHome": {
          "type": "boolean",
          "default": true
        },
        "DisplayWarps": {
          "type": "boolean",
          "default": true
        },
        "DisplayDeathMarker": {
          "type": "boolean",
          "default": true
        },
        "DisplayPlayers": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "DeathConfig": {
      "type": "object",
      "title": "DeathConfig",
      "properties": {
        "RespawnController": {
          "title": "Type Selector",
          "description": "The respawn controller that determines where the player respawns.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ExitInstance"
            },
            {
              "$ref": "common.schema.json#/$defs/HomeOrSpawnPoint"
            },
            {
              "$ref": "common.schema.json#/$defs/WorldSpawnPoint"
            }
          ]
        },
        "ItemsLossMode": {
          "type": [
            "string",
            "null"
          ],
          "title": "ItemsLossMode",
          "description": "The mode used to compute what the entity will lose upon death.",
          "enum": [
            "None",
            "All",
            "Configured"
          ],
          "default": "None"
        },
        "ItemsAmountLossPercentage": {
          "type": "number",
          "description": "The amount (in %) of items lost for an ItemStack upon death (applied to the entire inventory). Used ONLY if `ItemsLossMode` is set to 'Configured` and applied to items that have `DropOnDeath` set to `true`.",
          "minimum": 0,
          "maximum": 100,
          "default": 10
        },
        "ItemsDurabilityLossPercentage": {
          "type": "number",
          "description": "The amount of durability (in %) items lose upon death (applied to the entire inventory).",
          "minimum": 0,
          "maximum": 100,
          "default": 10
        }
      },
      "additionalProperties": false
    },
    "ExitInstance": {
      "type": "object",
      "title": "ExitInstance",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ExitInstance\" to function as this type.",
          "const": "ExitInstance"
        },
        "Fallback": {
          "title": "Type Selector",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ExitInstance"
            },
            {
              "$ref": "common.schema.json#/$defs/HomeOrSpawnPoint"
            },
            {
              "$ref": "common.schema.json#/$defs/WorldSpawnPoint"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "HomeOrSpawnPoint": {
      "type": "object",
      "title": "HomeOrSpawnPoint",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"HomeOrSpawnPoint\" to function as this type.",
          "const": "HomeOrSpawnPoint"
        }
      },
      "additionalProperties": false
    },
    "WorldSpawnPoint": {
      "type": "object",
      "title": "WorldSpawnPoint",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"WorldSpawnPoint\" to function as this type.",
          "const": "WorldSpawnPoint"
        }
      },
      "additionalProperties": false
    },
    "RespawnConfig": {
      "type": "object",
      "title": "RespawnConfig",
      "properties": {
        "RadiusLimitRespawnPoint": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 500
        },
        "MaxRespawnPointsPerPlayer": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 3
        }
      },
      "additionalProperties": false
    },
    "ItemDurabilityConfig": {
      "type": "object",
      "title": "ItemDurabilityConfig",
      "properties": {
        "BrokenPenalties": {
          "default": {},
          "$ref": "common.schema.json#/$defs/BrokenPenalties"
        }
      },
      "additionalProperties": false
    },
    "BrokenPenalties": {
      "type": "object",
      "title": "BrokenPenalties",
      "properties": {
        "Tool": {
          "type": "number"
        },
        "Armor": {
          "type": "number"
        },
        "Weapon": {
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "ItemEntityConfig": {
      "type": "object",
      "title": "ItemEntityConfig",
      "properties": {
        "Physics": {
          "anyOf": [
            {
              "default": {
                "Mass": 5,
                "DragCoefficient": 0.5,
                "InvertedGravity": false
              },
              "$ref": "common.schema.json#/$defs/PhysicsValues"
            },
            {
              "type": "null"
            }
          ]
        },
        "PickupRadius": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Lifetime": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ParticleSystemId": {
          "type": [
            "string",
            "null"
          ],
          "default": "Item"
        },
        "ParticleColor": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "ShowItemParticles": {
          "type": "boolean",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "PhysicsValues": {
      "type": "object",
      "title": "PhysicsValues",
      "properties": {
        "Mass": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "DragCoefficient": {
          "type": "number",
          "minimum": 0,
          "default": 0.5
        },
        "InvertedGravity": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "CombatConfig": {
      "type": "object",
      "title": "CombatConfig",
      "properties": {
        "OutOfCombatDelaySeconds": {
          "type": [
            "number",
            "null"
          ],
          "description": "Delay before an entity is considered out of combat. Expressed in seconds."
        },
        "StaminaBrokenEffectId": {
          "type": "string",
          "description": "The id of the EntityEffect to apply upon stamina being depleted due to damage.",
          "default": "Stamina_Broken"
        },
        "DisplayHealthBars": {
          "type": "boolean",
          "description": "Whether to display health bars above entities. Clients can still disable this in their settings.",
          "default": true
        },
        "DisplayCombatText": {
          "type": "boolean",
          "description": "Whether to display combat text (damage numbers) on entities. Clients can still disable this in their settings.",
          "default": true
        },
        "DisableNPCIncomingDamage": {
          "type": "boolean",
          "description": "Whether NPCs can take damage.",
          "default": false
        },
        "DisablePlayerIncomingDamage": {
          "type": "boolean",
          "description": "Whether players can take damage.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "VoidEventConfig": {
      "type": "object",
      "title": "VoidEventConfig",
      "properties": {
        "DurationSeconds": {
          "type": "integer",
          "description": "How long the void event lasts in seconds. The void event starts at the end of the instance. If your fragment is 10 minutes and this is 180 seconds, it will start 7 minutes in.",
          "default": 180
        },
        "InvasionPortals": {
          "description": "Configuration regarding the enemy portals that spawn around the players during the event",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InvasionPortalConfig"
            },
            {
              "type": "null"
            }
          ]
        },
        "Stages": {
          "type": [
            "array",
            "null"
          ],
          "description": "Certain event characteristics happen over stages that can be defined here. Stages are spread in time. Only one stage is \"active\" at a time.",
          "items": {
            "$ref": "common.schema.json#/$defs/VoidEventStage"
          }
        },
        "MusicAmbienceFX": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of an AmbienceFX which will be used for the music during the event"
        }
      },
      "additionalProperties": false
    },
    "InvasionPortalConfig": {
      "type": "object",
      "title": "InvasionPortalConfig",
      "description": "An array of SpawnBeacon IDs, which will make mobs spawn around the evil portals",
      "properties": {
        "BlockKey": {
          "type": [
            "string",
            "null"
          ],
          "description": "The block used for evil portals that spawn around the world during the event"
        },
        "SpawnBeacons": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "OnSpawnParticles": {
          "type": [
            "string",
            "null"
          ],
          "description": "A particle system ID to spawn when the portal spawns, should be a temporary one."
        }
      },
      "additionalProperties": false
    },
    "VoidEventStage": {
      "type": "object",
      "title": "VoidEventStage",
      "properties": {
        "SecondsInto": {
          "type": "integer",
          "description": "How many seconds into the void event does this stage becomes the active stage.",
          "default": 0
        },
        "ForcedWeather": {
          "type": [
            "string",
            "null"
          ],
          "description": "What weather to force during this stage."
        }
      },
      "additionalProperties": false
    },
    "SprintRegenDelayConfig": {
      "type": "object",
      "title": "SprintRegenDelayConfig",
      "properties": {
        "EntityStatId": {
          "type": "string",
          "description": "The ID of the stamina regen delay EntityStat"
        },
        "Value": {
          "description": "The amount of stamina regen delay to apply",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "PlayerConfig": {
      "type": "object",
      "title": "PlayerConfig",
      "properties": {
        "HitboxCollisionConfig": {
          "type": [
            "string",
            "null"
          ],
          "description": "The HitboxCollision config to apply to all players."
        },
        "RepulsionConfig": {
          "type": [
            "string",
            "null"
          ],
          "description": "The Repulsion to apply to all players."
        },
        "MovementConfig": {
          "type": [
            "string",
            "null"
          ],
          "description": "The maximum number of simultaneous deployable entities players are allowed to own.",
          "default": "BuiltinDefault"
        },
        "MaxDeployableEntities": {
          "type": "integer",
          "default": -1
        },
        "ArmorVisibilityOption": {
          "type": [
            "string",
            "null"
          ],
          "title": "ArmorVisibilityOption",
          "enum": [
            "All",
            "HelmetOnly",
            "None"
          ],
          "default": "All"
        }
      },
      "additionalProperties": false
    },
    "CameraEffectsConfig": {
      "type": "object",
      "title": "CameraEffectsConfig",
      "properties": {
        "DamageEffects": {
          "type": [
            "object",
            "null"
          ],
          "description": "The default damage camera effects",
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to CameraEffect"
              },
              {
                "$ref": "CameraEffect.json#"
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "CraftingConfig": {
      "type": "object",
      "title": "CraftingConfig",
      "properties": {
        "BenchMaterialChestHorizontalSearchRadius": {
          "type": "integer",
          "description": "The horizontal radius of search around a bench to use materials from the chests",
          "minimum": 0,
          "maximum": 14,
          "default": 14
        },
        "BenchMaterialChestVerticalSearchRadius": {
          "type": "integer",
          "description": "The vertical radius of search around a bench to use materials from the chests",
          "minimum": 0,
          "maximum": 14,
          "default": 6
        },
        "BenchMaterialChestLimit": {
          "type": "integer",
          "description": "The maximum number of chests a crafting bench will draw materials from",
          "minimum": 0,
          "maximum": 200,
          "default": 100
        }
      },
      "additionalProperties": false
    },
    "SpawnConfig": {
      "type": "object",
      "title": "SpawnConfig",
      "properties": {
        "FirstSpawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/WorldParticle"
          }
        },
        "SpawnParticles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/WorldParticle"
          }
        }
      },
      "additionalProperties": false
    },
    "FertilizerGrowthModifierAsset": {
      "type": "object",
      "title": "FertilizerGrowthModifierAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Fertilizer\" to function as this type.",
          "const": "Fertilizer"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FertilizerGrowthModifierAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FertilizerGrowthModifierAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "GrowthModifierAsset",
            "mapKey": "Type",
            "mapKeyValue": "Fertilizer"
          }
        },
        "Modifier": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "LightLevelGrowthModifierAsset": {
      "type": "object",
      "title": "LightLevelGrowthModifierAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LightLevel\" to function as this type.",
          "const": "LightLevel"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another LightLevelGrowthModifierAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **LightLevelGrowthModifierAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "GrowthModifierAsset",
            "mapKey": "Type",
            "mapKeyValue": "LightLevel"
          }
        },
        "Modifier": {
          "type": "number",
          "default": 0
        },
        "ArtificialLight": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ArtificialLight"
            },
            {
              "type": "null"
            }
          ]
        },
        "Sunlight": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "RequireBoth": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ArtificialLight": {
      "type": "object",
      "title": "ArtificialLight",
      "properties": {
        "Red": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Range"
            },
            {
              "type": "null"
            }
          ]
        },
        "Green": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Range"
            },
            {
              "type": "null"
            }
          ]
        },
        "Blue": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Range"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "WaterGrowthModifierAsset": {
      "type": "object",
      "title": "WaterGrowthModifierAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Water\" to function as this type.",
          "const": "Water"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WaterGrowthModifierAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WaterGrowthModifierAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "GrowthModifierAsset",
            "mapKey": "Type",
            "mapKeyValue": "Water"
          }
        },
        "Modifier": {
          "type": "number",
          "default": 0
        },
        "Fluids": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "Weathers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "RainDuration": {
          "type": "integer",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AddItemInteraction": {
      "type": "object",
      "title": "AddItemInteraction",
      "description": "Adds an item to the users inventory.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"AddItem\" to function as this type.",
          "const": "AddItem"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AddItemInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AddItemInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "AddItem"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "ItemId": {
          "type": "string",
          "description": "The id of the item to add."
        },
        "Quantity": {
          "type": "integer",
          "description": "The amount of the item to add.",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "InteractionEffects": {
      "type": "object",
      "title": "InteractionEffects",
      "properties": {
        "Particles": {
          "type": [
            "array",
            "null"
          ],
          "description": "Particles to play when triggering this interaction.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "FirstPersonParticles": {
          "type": [
            "array",
            "null"
          ],
          "description": "Particles to play when triggering this interaction while in first person.",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "WorldSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "Sound to play when triggering this interaction."
        },
        "LocalSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "Sound to play when triggering this interaction but only to the player that triggered it."
        },
        "Trails": {
          "type": [
            "array",
            "null"
          ],
          "description": "The model trails to create when triggering this interaction",
          "items": {
            "$ref": "common.schema.json#/$defs/ModelTrail"
          }
        },
        "WaitForAnimationToFinish": {
          "type": "boolean",
          "description": "Whether this interaction should hold until the animation is finished before continuing.\nGenerally this overrides the runtime of the interaction.",
          "default": false
        },
        "ItemPlayerAnimationsId": {
          "description": "The item animations set to use while this interaction is active",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to ItemPlayerAnimations"
            },
            {
              "$ref": "ItemPlayerAnimations.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ItemAnimationId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The item animation to play when triggering this interaction."
        },
        "ClearAnimationOnFinish": {
          "type": "boolean",
          "description": "Whether any animations triggered by this interaction should be cleared when this interaction finishes.",
          "default": false
        },
        "ClearSoundEventOnFinish": {
          "type": "boolean",
          "description": "Whether any sound events triggered by this interaction should be cleared when this interaction finishes.",
          "default": false
        },
        "CameraEffect": {
          "description": "The camera effects to trigger while this interaction is active.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to CameraEffect"
            },
            {
              "$ref": "CameraEffect.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "MovementEffects": {
          "description": "The movement effects to apply while this interaction is active.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/MovementEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "StartDelay": {
          "description": "An optional delay on applying any interaction effects.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "ModelTrail": {
      "type": "object",
      "title": "ModelTrail",
      "properties": {
        "TrailId": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Trail"
            },
            {
              "$ref": "Trail.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "TargetEntityPart": {
          "type": [
            "string",
            "null"
          ],
          "title": "EntityPart",
          "enum": [
            "Self",
            "Entity",
            "PrimaryItem",
            "SecondaryItem"
          ],
          "default": "Self"
        },
        "TargetNodeName": {
          "type": [
            "string",
            "null"
          ]
        },
        "PositionOffset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "RotationOffset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Direction"
            },
            {
              "type": "null"
            }
          ]
        },
        "FixedRotation": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "InteractionRules": {
      "type": "object",
      "title": "InteractionRules",
      "properties": {
        "BlockedBy": {
          "type": [
            "array",
            "null"
          ],
          "title": "Set",
          "description": "A collection of interaction types that should block this interaction from starting. If not set then a set of default rules will be applied based on the interaction type that theinteraction is fired with.\nThis is only effective when used on the root interaction of a chain.",
          "items": {
            "type": "string",
            "title": "InteractionType",
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          },
          "uniqueItems": true
        },
        "Blocking": {
          "type": "array",
          "title": "Set",
          "description": "A collection of interaction types that this interaction blocks from starting whilst running.\nDefaults to an empty set (blocking nothing).",
          "items": {
            "type": "string",
            "title": "InteractionType",
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          },
          "uniqueItems": true
        },
        "InterruptedBy": {
          "type": [
            "array",
            "null"
          ],
          "title": "Set",
          "description": "A collection of interaction types that should stop this interaction while it's running.\nThis is only effective when used on the root interaction of a chain.",
          "items": {
            "type": "string",
            "title": "InteractionType",
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          },
          "uniqueItems": true
        },
        "Interrupting": {
          "type": [
            "array",
            "null"
          ],
          "title": "Set",
          "description": "A collection of interaction types that this interaction should stop when it starts.",
          "items": {
            "type": "string",
            "title": "InteractionType",
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          },
          "uniqueItems": true
        },
        "BlockedByBypass": {
          "type": [
            "string",
            "null"
          ],
          "description": "A tag that if matched will bypass the `BlockedBy` rules."
        },
        "BlockingBypass": {
          "type": [
            "string",
            "null"
          ],
          "description": "A tag that if matched will bypass the `Blocking` rules."
        },
        "InterruptedByBypass": {
          "type": [
            "string",
            "null"
          ],
          "description": "A tag that if matched will bypass the `InterruptedBy` rules."
        },
        "InterruptingBypass": {
          "type": [
            "string",
            "null"
          ],
          "description": "A tag that if matched will bypass the `Interrupting` rules."
        }
      },
      "additionalProperties": false
    },
    "InteractionSettings": {
      "type": "object",
      "title": "InteractionSettings",
      "properties": {
        "AllowSkipOnClick": {
          "type": "boolean",
          "description": "Whether to skip this interaction when another click is sent.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "InteractionCameraSettings": {
      "type": "object",
      "title": "InteractionCameraSettings",
      "properties": {
        "FirstPerson": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/InteractionCamera"
          }
        },
        "ThirdPerson": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/InteractionCamera"
          }
        }
      },
      "additionalProperties": false
    },
    "InteractionCamera": {
      "type": "object",
      "title": "InteractionCamera",
      "properties": {
        "Time": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Position": {
          "default": {
            "X": 0,
            "Y": 0,
            "Z": 0
          },
          "$ref": "common.schema.json#/$defs/Vector3f"
        },
        "Rotation": {
          "default": {
            "Yaw": 0,
            "Pitch": 0,
            "Roll": 0
          },
          "$ref": "common.schema.json#/$defs/Direction"
        }
      },
      "additionalProperties": false
    },
    "ApplyEffectInteraction": {
      "type": "object",
      "title": "ApplyEffectInteraction",
      "description": "Applies the given entity effect to the entity.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ApplyEffect\" to function as this type.",
          "const": "ApplyEffect"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ApplyEffectInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ApplyEffectInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ApplyEffect"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "EffectId": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to EntityEffect"
            },
            {
              "$ref": "EntityEffect.json#"
            }
          ]
        },
        "Entity": {
          "type": "string",
          "title": "InteractionTarget",
          "description": "The entity to target for this interaction.",
          "enumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "markdownEnumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "enum": [
            "User",
            "Owner",
            "Target"
          ],
          "default": "User"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ApplyForceInteraction": {
      "type": "object",
      "title": "ApplyForceInteraction",
      "description": "Applies a force to the user, optionally waiting for a condition to met before continuing.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ApplyForce\" to function as this type.",
          "const": "ApplyForce"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ApplyForceInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ApplyForceInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ApplyForce"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Direction": {
          "description": "The direction of the force to apply.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "AdjustVertical": {
          "type": "boolean",
          "description": "Whether the force should be adjusted based on the vertical look of the user."
        },
        "Force": {
          "type": "number",
          "description": "The size of the force to apply."
        },
        "Forces": {
          "type": [
            "array",
            "null"
          ],
          "description": "A collection of forces to apply to the user.\nReplaces `Direction`, `AdjustVertical` and `Force` if used.",
          "items": {
            "$ref": "common.schema.json#/$defs/Force"
          }
        },
        "Duration": {
          "description": "The duration for which force should be continuously applied. If 0, force is applied on first run.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "VerticalClamp": {
          "type": [
            "array",
            "null"
          ],
          "title": "FloatRange",
          "description": "The angles in degrees to clamp the look angle to when adjusting the force",
          "items": [
            {
              "$ref": "base.schema.json#/$defs/NumberOrSpecial"
            },
            {
              "$ref": "base.schema.json#/$defs/NumberOrSpecial"
            }
          ],
          "minItems": 2,
          "maxItems": 2
        },
        "WaitForGround": {
          "type": "boolean",
          "description": "Determines whether or not on ground should be checked",
          "default": true
        },
        "WaitForCollision": {
          "type": "boolean",
          "description": "Determines whether or not collision should be checked",
          "default": false
        },
        "RaycastDistance": {
          "description": "The distance of the raycast for the collision check",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RaycastHeightOffset": {
          "description": "The height offset of the raycast for the collision check (default 0)",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RaycastMode": {
          "type": [
            "string",
            "null"
          ],
          "title": "RaycastMode",
          "description": "The type of raycast performed for the collision check",
          "enum": [
            "FollowMotion",
            "FollowLook"
          ],
          "default": "FollowMotion"
        },
        "GroundCheckDelay": {
          "description": "The delay in seconds before checking if on ground",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CollisionCheckDelay": {
          "description": "The delay in seconds before checking entity collision",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ChangeVelocityType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ChangeVelocityType",
          "description": "Configures how the velocity gets applied to the user.",
          "enumDescriptions": [
            "Adds the velocity to any existing velocity",
            "Changes the velocity to the given value. Overriding existing values."
          ],
          "markdownEnumDescriptions": [
            "Adds the velocity to any existing velocity",
            "Changes the velocity to the given value. Overriding existing values."
          ],
          "enum": [
            "Add",
            "Set"
          ],
          "default": "Set"
        },
        "VelocityConfig": {
          "description": "Specific configuration options that control how the velocity is affected.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/VelocityConfig"
            },
            {
              "type": "null"
            }
          ]
        },
        "GroundNext": {
          "description": "The interaction to run if on-ground is apparent.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "CollisionNext": {
          "description": "The interaction to run if collision is apparent.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Force": {
      "type": "object",
      "title": "Force",
      "properties": {
        "Direction": {
          "description": "The direction of the force to apply.",
          "default": {
            "X": 0,
            "Y": 1,
            "Z": 0
          },
          "$ref": "common.schema.json#/$defs/Vector3d"
        },
        "AdjustVertical": {
          "type": "boolean",
          "description": "Whether the force should be adjusted based on the vertical look of the user.",
          "default": false
        },
        "Force": {
          "type": "number",
          "description": "The size of the force to apply.",
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "BedInteraction": {
      "type": "object",
      "title": "BedInteraction",
      "description": "Interact with a bed block, ostensibly to sleep in it.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Bed\" to function as this type.",
          "const": "Bed"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BedInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BedInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Bed"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BlockConditionInteraction": {
      "type": "object",
      "title": "BlockConditionInteraction",
      "description": "Tests the target block and executes `Next` if it matches all the conditions, otherwise `Failed` is run.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BlockCondition\" to function as this type.",
          "const": "BlockCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BlockConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BlockConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "BlockCondition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Matchers": {
          "type": [
            "array",
            "null"
          ],
          "description": "The matchers to test the block against.",
          "items": {
            "$ref": "common.schema.json#/$defs/BlockMatcher"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BlockMatcher": {
      "type": "object",
      "title": "BlockMatcher",
      "properties": {
        "Block": {
          "description": "Match against block values",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BlockIdMatcher"
            },
            {
              "type": "null"
            }
          ]
        },
        "Face": {
          "type": [
            "string",
            "null"
          ],
          "title": "BlockFace",
          "description": "Match against a specific block face.",
          "enum": [
            "Up",
            "Down",
            "North",
            "East",
            "South",
            "West",
            "UpNorth",
            "UpSouth",
            "UpEast",
            "UpWest",
            "DownNorth",
            "DownSouth",
            "DownEast",
            "DownWest",
            "NorthEast",
            "SouthEast",
            "SouthWest",
            "NorthWest",
            "UpNorthEast",
            "UpSouthEast",
            "UpSouthWest",
            "UpNorthWest",
            "DownNorthEast",
            "DownSouthEast",
            "DownSouthWest",
            "DownNorthWest"
          ]
        },
        "StaticFace": {
          "type": "boolean",
          "description": "Whether the face matching is unaffected by the block rotation or not.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "BlockIdMatcher": {
      "type": "object",
      "title": "BlockIdMatcher",
      "properties": {
        "Id": {
          "type": [
            "string",
            "null"
          ],
          "description": "Match against a specific block id."
        },
        "State": {
          "type": [
            "string",
            "null"
          ],
          "description": "Match against specific block state."
        },
        "Tag": {
          "type": [
            "string",
            "null"
          ],
          "description": "Match against specific block tag."
        }
      },
      "additionalProperties": false
    },
    "BreakBlockInteraction": {
      "type": "object",
      "title": "BreakBlockInteraction",
      "description": "Attempts to break the target block.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BreakBlock\" to function as this type.",
          "const": "BreakBlock"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BreakBlockInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BreakBlockInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "BreakBlock"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Harvest": {
          "type": "boolean",
          "description": "Whether this should trigger as a harvest gather vs a break gather.",
          "default": false
        },
        "Tool": {
          "type": [
            "string",
            "null"
          ],
          "description": "Tool to break as."
        },
        "MatchTool": {
          "type": "boolean",
          "description": "Whether to require an match to `Tool` to work.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BuilderToolInteraction": {
      "type": "object",
      "title": "BuilderToolInteraction",
      "description": "Runs a builder tool",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BuilderTool\" to function as this type.",
          "const": "BuilderTool"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BuilderToolInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BuilderToolInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "BuilderTool"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CameraInteraction": {
      "type": "object",
      "title": "CameraInteraction",
      "description": "Adjusts the camera of the user.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Camera\" to function as this type.",
          "const": "Camera"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CameraInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CameraInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Camera"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "PersistCameraState": {
          "type": "boolean",
          "description": "Should the camera state from this interaction persist to the next camera interaction. If the next interaction is null or not a camera interaction then this field does nothing.",
          "default": false
        },
        "Action": {
          "type": [
            "string",
            "null"
          ],
          "title": "CameraActionType",
          "description": "What kind of camera action should we take",
          "enum": [
            "ForcePerspective",
            "Orbit",
            "Transition"
          ]
        },
        "Perspective": {
          "type": [
            "string",
            "null"
          ],
          "title": "CameraPerspectiveType",
          "description": "What camera perspective we want this interaction to take place in",
          "enum": [
            "First",
            "Third"
          ]
        },
        "CameraInteractionTime": {
          "description": "How long this camera action lasts for",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CameraShakeInteraction": {
      "type": "object",
      "title": "CameraShakeInteraction",
      "description": "Triggers a camera shake effect on use.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CameraShake\" to function as this type.",
          "const": "CameraShake"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CameraShakeInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CameraShakeInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "CameraShake"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "CameraEffect": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to CameraEffect"
            },
            {
              "$ref": "CameraEffect.json#"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CanBreakRespawnPointInteraction": {
      "type": "object",
      "title": "CanBreakRespawnPointInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CanBreakRespawnPoint\" to function as this type.",
          "const": "CanBreakRespawnPoint"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CanBreakRespawnPointInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CanBreakRespawnPointInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "CanBreakRespawnPoint"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CancelChainInteraction": {
      "type": "object",
      "title": "CancelChainInteraction",
      "description": "Cancels an active chaining state for the given chain id.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CancelChain\" to function as this type.",
          "const": "CancelChain"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CancelChainInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CancelChainInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "CancelChain"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ChainId": {
          "type": "string",
          "description": "The ID of the chain to cancel."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChainFlagInteraction": {
      "type": "object",
      "title": "ChainFlagInteraction",
      "description": "Sets a flag on the given chain id that a Chaining interaction can optionally use to adjust what it'll execute.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ChainFlag\" to function as this type.",
          "const": "ChainFlag"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChainFlagInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChainFlagInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ChainFlag"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ChainId": {
          "type": "string"
        },
        "Flag": {
          "type": "string"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChainingInteraction": {
      "type": "object",
      "title": "ChainingInteraction",
      "description": "Runs one of the entries in `Next` based on how many times this interaction was run before the `ChainingAllowance` timer was reset.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Chaining\" to function as this type.",
          "const": "Chaining"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChainingInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChainingInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Chaining"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "ChainingAllowance": {
          "type": "number",
          "description": "Time in seconds that the user has to run this interaction again in order to hit the next chain entry.\nResets the timer each time the interaction is reached.",
          "default": 0
        },
        "Next": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Interaction"
              },
              {
                "$ref": "Interaction.json#"
              }
            ]
          }
        },
        "ChainId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Flags": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Interaction"
              },
              {
                "$ref": "Interaction.json#"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChangeActiveSlotInteraction": {
      "type": "object",
      "title": "ChangeActiveSlotInteraction",
      "description": "Changes the active hotbar slot for the user of the interaction.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ChangeActiveSlot\" to function as this type.",
          "const": "ChangeActiveSlot"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChangeActiveSlotInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChangeActiveSlotInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ChangeActiveSlot"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "TargetSlot": {
          "type": "integer",
          "minimum": 0,
          "maximum": 8
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChangeBlockInteraction": {
      "type": "object",
      "title": "ChangeBlockInteraction",
      "description": "Changes the target block to another block based on the block types provided.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ChangeBlock\" to function as this type.",
          "const": "ChangeBlock"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChangeBlockInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChangeBlockInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ChangeBlock"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Changes": {
          "type": [
            "object",
            "null"
          ],
          "description": "A map of the target block to the new block.\n\nWhen the interaction runs it will look for the block that was interacted with in this map and if found it will replace it with specified block",
          "additionalProperties": {
            "type": "string"
          }
        },
        "WorldSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "Sound event to play at the block location on block change."
        },
        "RequireNotBroken": {
          "type": "boolean",
          "description": "If true, the interaction will fail if the held item is broken (durability = 0).",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChangeFarmingStageInteraction": {
      "type": "object",
      "title": "ChangeFarmingStageInteraction",
      "description": "Changes the farming stage of the target block.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ChangeFarmingStage\" to function as this type.",
          "const": "ChangeFarmingStage"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChangeFarmingStageInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChangeFarmingStageInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ChangeFarmingStage"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Stage": {
          "type": "integer",
          "description": "The stage index to set (0, 1, 2, etc.). Use -1 for the final stage. Ignored if Increase is set.",
          "default": -1
        },
        "Increase": {
          "type": "integer",
          "description": "Add this amount to the current stage (e.g., 1 = advance one stage, 2 = advance two stages). Takes priority over Decrease and Stage."
        },
        "Decrease": {
          "type": "integer",
          "description": "Subtract this amount from the current stage (e.g., 1 = go back one stage). Takes priority over Stage."
        },
        "StageSet": {
          "type": [
            "string",
            "null"
          ],
          "description": "Optional. The stage set to switch to (e.g., 'Default', 'Harvested'). If not provided, uses current stage set."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChangeStatInteraction": {
      "type": "object",
      "title": "ChangeStatInteraction",
      "description": "Changes the given stats.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ChangeStat\" to function as this type.",
          "const": "ChangeStat"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChangeStatInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChangeStatInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ChangeStat"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "StatModifiers": {
          "type": "object",
          "title": "Map of string to float",
          "description": "Modifiers to apply to EntityStats.",
          "additionalProperties": {
            "type": "number"
          }
        },
        "ValueType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ValueType",
          "description": "Enum to specify if the StatModifiers must be considered as absolute values or percent. Default value is Absolute. When using ValueType.Absolute, '100' matches the max value.",
          "enum": [
            "Percent",
            "Absolute"
          ],
          "default": "Absolute"
        },
        "Behaviour": {
          "type": [
            "string",
            "null"
          ],
          "title": "ChangeStatBehaviour",
          "description": "Specifies how StatModifiers should be applied to the stats.",
          "enumDescriptions": [
            "Adds the value to the stat",
            "Changes the stat to the given value"
          ],
          "markdownEnumDescriptions": [
            "Adds the value to the stat",
            "Changes the stat to the given value"
          ],
          "enum": [
            "Add",
            "Set"
          ],
          "default": "Add"
        },
        "Entity": {
          "type": "string",
          "title": "InteractionTarget",
          "description": "The entity to target for this interaction.",
          "enumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "markdownEnumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "enum": [
            "User",
            "Owner",
            "Target"
          ],
          "default": "User"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChangeStatWithModifierInteraction": {
      "type": "object",
      "title": "ChangeStatWithModifierInteraction",
      "description": "Changes the given stats.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ChangeStatWithModifier\" to function as this type.",
          "const": "ChangeStatWithModifier"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChangeStatWithModifierInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChangeStatWithModifierInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ChangeStatWithModifier"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "StatModifiers": {
          "type": "object",
          "title": "Map of string to float",
          "description": "Modifiers to apply to EntityStats.",
          "additionalProperties": {
            "type": "number"
          }
        },
        "ValueType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ValueType",
          "description": "Enum to specify if the StatModifiers must be considered as absolute values or percent. Default value is Absolute. When using ValueType.Absolute, '100' matches the max value.",
          "enum": [
            "Percent",
            "Absolute"
          ],
          "default": "Absolute"
        },
        "Behaviour": {
          "type": [
            "string",
            "null"
          ],
          "title": "ChangeStatBehaviour",
          "description": "Specifies how StatModifiers should be applied to the stats.",
          "enumDescriptions": [
            "Adds the value to the stat",
            "Changes the stat to the given value"
          ],
          "markdownEnumDescriptions": [
            "Adds the value to the stat",
            "Changes the stat to the given value"
          ],
          "enum": [
            "Add",
            "Set"
          ],
          "default": "Add"
        },
        "Entity": {
          "type": "string",
          "title": "InteractionTarget",
          "description": "The entity to target for this interaction.",
          "enumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "markdownEnumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "enum": [
            "User",
            "Owner",
            "Target"
          ],
          "default": "User"
        },
        "InteractionModifierId": {
          "type": "string",
          "title": "InteractionModifierId",
          "enum": [
            "Dodge"
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChangeStateInteraction": {
      "type": "object",
      "title": "ChangeStateInteraction",
      "description": "Changes the state of the target block to another state based on the mapping provided.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ChangeState\" to function as this type.",
          "const": "ChangeState"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChangeStateInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChangeStateInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ChangeState"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Changes": {
          "type": [
            "object",
            "null"
          ],
          "description": "The map of state changes to execute. `\"default\"` can be used for the initial state of a block.",
          "additionalProperties": {
            "type": "string"
          }
        },
        "UpdateBlockState": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChargingInteraction": {
      "type": "object",
      "title": "ChargingInteraction",
      "description": "An interaction that holds until the key is released (or a time limit is reached) and executes different interactions based on how long the key was pressed.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Charging\" to function as this type.",
          "const": "Charging"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ChargingInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ChargingInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Charging"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "FailOnDamage": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled and the item removed when the entity takes damage",
          "default": false
        },
        "CancelOnOtherClick": {
          "type": "boolean",
          "default": true
        },
        "Forks": {
          "type": [
            "object",
            "null"
          ],
          "description": "A collection of interactions to fork into when the input associated with the interaction type is used.\n\nFor example listing a `Primary` interaction type here with interactions will allow the user to press the input tied to the `Primary` interaction type whilst holding the input used to run the current interaction to run the specified interactions. e.g. Having a shield that you can hold `Secondary` to block and whilst blocking press `Primary` to shield bash.\n\nThis does not cancel the current interaction when triggered but the `CancelOnOtherClick` check will still run and may cancel the interaction.\n\nThe existing forks will continue to run even if this interaction ends.",
          "properties": {
            "Primary": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Secondary": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability1": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability2": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability3": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Use": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Pick": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Pickup": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "CollisionEnter": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "CollisionLeave": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Collision": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "EntityStatEffect": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "SwapTo": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "SwapFrom": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Death": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Wielding": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileSpawn": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileHit": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileMiss": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileBounce": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Held": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "HeldOffhand": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Equipped": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Dodge": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "GameModeSwap": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            }
          },
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to RootInteraction"
              },
              {
                "$ref": "RootInteraction.json#"
              }
            ]
          },
          "propertyNames": {
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          }
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "AllowIndefiniteHold": {
          "type": "boolean",
          "default": false
        },
        "DisplayProgress": {
          "type": "boolean",
          "default": true
        },
        "Next": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Interaction"
              },
              {
                "$ref": "Interaction.json#"
              }
            ]
          },
          "propertyNames": {
            "description": "A string that contains any floating point number",
            "pattern": "^[-+]?[0-9]+(.[0-9]+)?$"
          }
        },
        "MouseSensitivityAdjustmentTarget": {
          "description": "What is the target modifier to apply to mouse sensitivity while this interaction is active.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "MouseSensitivityAdjustmentDuration": {
          "description": "Override the global linear modifier adjustment with this as the time to go from 1.0 to 0.0.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Delay": {
          "description": "Settings that allow for delaying the charging interaction on damage.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ChargingDelay"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ChargingDelay": {
      "type": "object",
      "title": "ChargingDelay",
      "description": "Configuration for delay when the user is attacked.\nThe delay will be between MinDelay when the incoming at MinHealth and MaxDelay when the incoming damage is at or above MaxHealth.",
      "markdownDescription": "Configuration for delay when the user is attacked.\nThe delay will be between **MinDelay** when the incoming at **MinHealth** and **MaxDelay** when the incoming damage is at or above **MaxHealth**.",
      "properties": {
        "MinDelay": {
          "description": "The smallest amount of delay that can be applied.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "MaxDelay": {
          "description": "The largest amount of delay that can be applied.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "MaxTotalDelay": {
          "description": "The max amount of delay applied during this interaction before any additional delay is ignored.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "MinHealth": {
          "description": "The amount of health (as a percentage between 1.0 and 0.0) where if the user's health is below the value then the delay wont be applied.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        },
        "MaxHealth": {
          "description": "The amount of health (as a percentage between 1.0 and 0.0) where if the user's health is above the value then the delay will be capped.",
          "$ref": "base.schema.json#/$defs/NumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "CheckUniqueItemUsageInteraction": {
      "type": "object",
      "title": "CheckUniqueItemUsageInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CheckUniqueItemUsage\" to function as this type.",
          "const": "CheckUniqueItemUsage"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CheckUniqueItemUsageInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CheckUniqueItemUsageInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "CheckUniqueItemUsage"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ClearEntityEffectInteraction": {
      "type": "object",
      "title": "ClearEntityEffectInteraction",
      "description": "Removes the given entity effect from the given entity.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ClearEntityEffect\" to function as this type.",
          "const": "ClearEntityEffect"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ClearEntityEffectInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ClearEntityEffectInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ClearEntityEffect"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "EntityEffectId": {
          "type": "string"
        },
        "Entity": {
          "type": "string",
          "title": "InteractionTarget",
          "description": "The entity to target for this interaction.",
          "enumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "markdownEnumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "enum": [
            "User",
            "Owner",
            "Target"
          ],
          "default": "User"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConditionInteraction": {
      "type": "object",
      "title": "ConditionInteraction",
      "description": "An interaction that is successful if the given conditions are met.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Condition\" to function as this type.",
          "const": "Condition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Condition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "RequiredGameMode": {
          "type": [
            "string",
            "null"
          ],
          "title": "GameMode",
          "enumDescriptions": [
            "The normal gamemode for players playing the game.",
            "Makes the player invulnerable and grants them the ability to fly."
          ],
          "markdownEnumDescriptions": [
            "The normal gamemode for players playing the game.",
            "Makes the player invulnerable and grants them the ability to fly."
          ],
          "enum": [
            "Adventure",
            "Creative"
          ]
        },
        "Jumping": {
          "type": "boolean"
        },
        "Swimming": {
          "type": "boolean"
        },
        "Crouching": {
          "type": "boolean"
        },
        "Running": {
          "type": "boolean"
        },
        "Flying": {
          "type": "boolean",
          "description": "Whether the entity can be flying."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ContextualUseNPCInteraction": {
      "type": "object",
      "title": "ContextualUseNPCInteraction",
      "description": "Interacts with the target NPC passing in context for it to use.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ContextualUseNPC\" to function as this type.",
          "const": "ContextualUseNPC"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ContextualUseNPCInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ContextualUseNPCInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ContextualUseNPC"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Context": {
          "type": "string",
          "description": "The provided context for the use action."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CooldownConditionInteraction": {
      "type": "object",
      "title": "CooldownConditionInteraction",
      "description": "Checks if a given cooldown is complete.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CooldownCondition\" to function as this type.",
          "const": "CooldownCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CooldownConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CooldownConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "CooldownCondition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Id": {
          "type": "string",
          "description": "The ID of the cooldown to check for in this condition."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "CycleBlockGroupInteraction": {
      "type": "object",
      "title": "CycleBlockGroupInteraction",
      "description": "Attempts to cycle the target block through its block set.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CycleBlockGroup\" to function as this type.",
          "const": "CycleBlockGroup"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another CycleBlockGroupInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **CycleBlockGroupInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "CycleBlockGroup"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DamageEntityInteraction": {
      "type": "object",
      "title": "DamageEntityInteraction",
      "description": "Damages the target entity.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DamageEntity\" to function as this type.",
          "const": "DamageEntity"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DamageEntityInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DamageEntityInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "DamageEntity"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "DamageCalculator": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DamageCalculator"
            },
            {
              "type": "null"
            }
          ]
        },
        "DamageEffects": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DamageEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "AngledDamage": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/AngledDamage"
          }
        },
        "TargetedDamage": {
          "type": "object",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/TargetedDamage"
          }
        },
        "EntityStatsOnHit": {
          "type": [
            "array",
            "null"
          ],
          "description": "EntityStats to apply based on the hits resulting from this interaction.",
          "items": {
            "$ref": "common.schema.json#/$defs/EntityStatOnHit"
          }
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Blocked": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AngledDamage": {
      "type": "object",
      "title": "AngledDamage",
      "properties": {
        "DamageCalculator": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DamageCalculator"
            },
            {
              "type": "null"
            }
          ]
        },
        "TargetEntityEffects": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/TargetEntityEffect"
          }
        },
        "DamageEffects": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DamageEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Angle": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "AngleDistance": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "TargetEntityEffect": {
      "type": "object",
      "title": "TargetEntityEffect",
      "properties": {
        "Duration": {
          "type": "number",
          "default": 0
        },
        "Chance": {
          "type": "number",
          "default": 1
        },
        "EntityTypeDurationModifiers": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of string to double",
          "additionalProperties": {
            "type": "number"
          }
        },
        "OverlapBehavior": {
          "type": [
            "string",
            "null"
          ],
          "title": "OverlapBehavior",
          "enum": [
            "Extend",
            "Overwrite",
            "Ignore"
          ],
          "default": "Ignore"
        }
      },
      "additionalProperties": false
    },
    "TargetedDamage": {
      "type": "object",
      "title": "TargetedDamage",
      "properties": {
        "DamageCalculator": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DamageCalculator"
            },
            {
              "type": "null"
            }
          ]
        },
        "TargetEntityEffects": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/TargetEntityEffect"
          }
        },
        "DamageEffects": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DamageEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "EntityStatOnHit": {
      "type": "object",
      "title": "EntityStatOnHit",
      "properties": {
        "EntityStatId": {
          "type": "string",
          "description": "The id of the EntityStat that will be affected by the interaction."
        },
        "Amount": {
          "description": "The base amount for a single entity hit.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "MultipliersPerEntitiesHit": {
          "type": [
            "array",
            "null"
          ],
          "description": "An array of multipliers corresponding to how much the amount should be multiplied by for each entity hit.",
          "items": {
            "type": "number"
          },
          "minItems": 1
        },
        "MultiplierPerExtraEntityHit": {
          "description": "When the number of entity hit is higher than the number of multipliers defined, the amount will be multiplied by this multiplier for each extra entity hit.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "DestroyBlockInteraction": {
      "type": "object",
      "title": "DestroyBlockInteraction",
      "description": "Destroys the target block.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DestroyBlock\" to function as this type.",
          "const": "DestroyBlock"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DestroyBlockInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DestroyBlockInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "DestroyBlock"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DestroyConditionInteraction": {
      "type": "object",
      "title": "DestroyConditionInteraction",
      "description": "Checks if the target block is destroyable",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"DestroyCondition\" to function as this type.",
          "const": "DestroyCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DestroyConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DestroyConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "DestroyCondition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "DoorInteraction": {
      "type": "object",
      "title": "DoorInteraction",
      "description": "Opens/Closes a door",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Door\" to function as this type.",
          "const": "Door"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another DoorInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **DoorInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Door"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Horizontal": {
          "type": "boolean",
          "description": "Whether the door is horizontal (e.g. gates) or vertical (e.g. regular doors).",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EffectConditionInteraction": {
      "type": "object",
      "title": "EffectConditionInteraction",
      "description": "An interaction that is successful if the given effects exist (or don't) on the target entity.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"EffectCondition\" to function as this type.",
          "const": "EffectCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EffectConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EffectConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "EffectCondition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "EntityEffectIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "Match": {
          "type": [
            "string",
            "null"
          ],
          "title": "Match",
          "description": "Field to specify whether the entity must have the specified effects (All), or must not have the specified effects (None). Default value is: All.",
          "enum": [
            "All",
            "None"
          ],
          "default": "All"
        },
        "Entity": {
          "type": "string",
          "title": "InteractionTarget",
          "description": "The entity to target for this interaction.",
          "enumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "markdownEnumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "enum": [
            "User",
            "Owner",
            "Target"
          ],
          "default": "User"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EquipItemInteraction": {
      "type": "object",
      "title": "EquipItemInteraction",
      "description": "Equips the item being held.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"EquipItem\" to function as this type.",
          "const": "EquipItem"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EquipItemInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EquipItemInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "EquipItem"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ExitInstanceInteraction": {
      "type": "object",
      "title": "ExitInstanceInteraction",
      "description": "Teleports the Entity out of the current Instance and places them at their set return point.",
      "markdownDescription": "Teleports the **Entity** out of the current **Instance** and places them at their set return point.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ExitInstance\" to function as this type.",
          "const": "ExitInstance"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ExitInstanceInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ExitInstanceInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ExitInstance"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ExplodeInteraction": {
      "type": "object",
      "title": "ExplodeInteraction",
      "description": "Performs an explosion using the provided config.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Explode\" to function as this type.",
          "const": "Explode"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ExplodeInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ExplodeInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Explode"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Config": {
          "description": "The explosion config associated with this projectile.",
          "$ref": "common.schema.json#/$defs/ExplosionConfig"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ExplosionConfig": {
      "type": "object",
      "title": "ExplosionConfig",
      "properties": {
        "DamageEntities": {
          "type": "boolean",
          "description": "Determines whether the explosion should damage entities.",
          "default": true
        },
        "DamageBlocks": {
          "type": "boolean",
          "description": "Determines whether the explosion should damage blocks.",
          "default": true
        },
        "BlockDamageRadius": {
          "type": "integer",
          "description": "The radius in which blocks should be damaged by the explosion.",
          "default": 3
        },
        "BlockDamageFalloff": {
          "description": "The falloff applied to the block damage.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "BlockDropChance": {
          "description": "The chance in which a block drops its loot after breaking.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "EntityDamageRadius": {
          "description": "The radius in which entities should be damaged by the explosion.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "EntityDamage": {
          "description": "The amount of damage to be applied to entities within range.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "EntityDamageFalloff": {
          "description": "The falloff applied to the entity damage.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Knockback": {
          "description": "Determines the knockback effect applied to damaged entities.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DirectionalKnockback"
            },
            {
              "$ref": "common.schema.json#/$defs/ForceKnockback"
            },
            {
              "$ref": "common.schema.json#/$defs/PointKnockback"
            },
            {
              "type": "null"
            }
          ]
        },
        "ItemTool": {
          "description": "The item tool to reference when applying damage to blocks.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ItemTool"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ItemTool": {
      "type": "object",
      "title": "ItemTool",
      "properties": {
        "Specs": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "ItemToolSpec.json#"
          }
        },
        "Speed": {
          "type": "number",
          "default": 0
        },
        "DurabilityLossBlockTypes": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/DurabilityLossBlockTypes"
          }
        },
        "HitSoundLayer": {
          "type": [
            "string",
            "null"
          ],
          "description": "Sound to play in addition to the block breaking sound when hitting a block this tool is designed to break."
        },
        "IncorrectMaterialSoundLayer": {
          "type": [
            "string",
            "null"
          ],
          "description": "Sound to play in addition to the block breaking sound when hitting a block this tool cannot break."
        }
      },
      "additionalProperties": false
    },
    "DurabilityLossBlockTypes": {
      "type": "object",
      "title": "DurabilityLossBlockTypes",
      "properties": {
        "BlockTypes": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "BlockSets": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "DurabilityLossOnHit": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "FertilizeSoilInteraction": {
      "type": "object",
      "title": "FertilizeSoilInteraction",
      "description": "If the target block is farmable then set it to fertilized.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FertilizeSoil\" to function as this type.",
          "const": "FertilizeSoil"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FertilizeSoilInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FertilizeSoilInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "FertilizeSoil"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "RefreshModifiers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FirstClickInteraction": {
      "type": "object",
      "title": "FirstClickInteraction",
      "description": "An interaction that runs a different interaction based on if this chain was from a click or due to the key being held down.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FirstClick\" to function as this type.",
          "const": "FirstClick"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another FirstClickInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **FirstClickInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "FirstClick"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Click": {
          "description": "The interaction to run if this chain was initiated by a click.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Held": {
          "description": "The interaction to run if this chain was initiated by holding down the key.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "HarvestCropInteraction": {
      "type": "object",
      "title": "HarvestCropInteraction",
      "description": "Harvests the resources from the target farmable block.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"HarvestCrop\" to function as this type.",
          "const": "HarvestCrop"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another HarvestCropInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **HarvestCropInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "HarvestCrop"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "HubPortalInteraction": {
      "type": "object",
      "title": "HubPortalInteraction",
      "description": "Teleports the Player to a permanent world, creating it if required.",
      "markdownDescription": "Teleports the **Player** to a permanent world, creating it if required.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"HubPortal\" to function as this type.",
          "const": "HubPortal"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another HubPortalInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **HubPortalInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "HubPortal"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "WorldName": {
          "type": "string",
          "description": "The name of the permanent world to teleport to."
        },
        "WorldGenType": {
          "type": [
            "string",
            "null"
          ],
          "description": "The world generator type to use when creating the world (e.g., 'Flat', 'Hytale'). Mutually exclusive with InstanceTemplate."
        },
        "InstanceTemplate": {
          "type": [
            "string",
            "null"
          ],
          "description": "Instance asset to use as template for creating the permanent world. Mutually exclusive with WorldGenType."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "IncreaseBackpackCapacityInteraction": {
      "type": "object",
      "title": "IncreaseBackpackCapacityInteraction",
      "description": "Increase the player's backpack capacity.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"IncreaseBackpackCapacity\" to function as this type.",
          "const": "IncreaseBackpackCapacity"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another IncreaseBackpackCapacityInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **IncreaseBackpackCapacityInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "IncreaseBackpackCapacity"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Capacity": {
          "type": "integer",
          "description": "Defines the amount by which the backpack capacity needs to be increased.",
          "minimum": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "IncrementCooldownInteraction": {
      "type": "object",
      "title": "IncrementCooldownInteraction",
      "description": "Increase the given cooldown.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"IncrementCooldown\" to function as this type.",
          "const": "IncrementCooldown"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another IncrementCooldownInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **IncrementCooldownInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "IncrementCooldown"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Id": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the cooldown to increment"
        },
        "Time": {
          "description": "The amount of time to increase the current cooldown time by",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "ChargeTime": {
          "description": "The amount of time to increase the current charge time by",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Charge": {
          "type": "integer",
          "description": "The amount of empty charges to recharge",
          "default": 0
        },
        "InterruptRecharge": {
          "type": "boolean",
          "description": "Determines whether the recharge of this cooldown should be interrupted",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "InterruptInteraction": {
      "type": "object",
      "title": "InterruptInteraction",
      "description": "Interrupts interactions on the target entity.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Interrupt\" to function as this type.",
          "const": "Interrupt"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another InterruptInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **InterruptInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Interrupt"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Entity": {
          "type": "string",
          "title": "InteractionTarget",
          "description": "The entity to target for this interaction.",
          "enumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "markdownEnumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "enum": [
            "User",
            "Owner",
            "Target"
          ],
          "default": "User"
        },
        "InterruptTypes": {
          "type": [
            "array",
            "null"
          ],
          "title": "Set",
          "description": "A set of interaction types that this interrupt will cancel",
          "items": {
            "type": "string",
            "title": "InteractionType",
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          },
          "uniqueItems": true
        },
        "RequiredTag": {
          "type": [
            "string",
            "null"
          ],
          "description": "The tag that the root interaction of an active interaction chain must have to be interrupted.\nIf not set then no tag is required."
        },
        "ExcludedTag": {
          "type": [
            "string",
            "null"
          ],
          "description": "The tag that if the root interaction of an active interaction chain has then it will not be interrupted."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "LaunchPadInteraction": {
      "type": "object",
      "title": "LaunchPadInteraction",
      "description": "Applies the launchpad forces.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LaunchPad\" to function as this type.",
          "const": "LaunchPad"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another LaunchPadInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **LaunchPadInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "LaunchPad"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "LaunchProjectileInteraction": {
      "type": "object",
      "title": "LaunchProjectileInteraction",
      "description": "Launches a projectile.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LaunchProjectile\" to function as this type.",
          "const": "LaunchProjectile"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another LaunchProjectileInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **LaunchProjectileInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "LaunchProjectile"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ProjectileId": {
          "type": "string"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "LearnRecipeInteraction": {
      "type": "object",
      "title": "LearnRecipeInteraction",
      "description": "Causes the user to learn the given recipe.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LearnRecipe\" to function as this type.",
          "const": "LearnRecipe"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another LearnRecipeInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **LearnRecipeInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "LearnRecipe"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MemoriesConditionInteraction": {
      "type": "object",
      "title": "MemoriesConditionInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"MemoriesCondition\" to function as this type.",
          "const": "MemoriesCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MemoriesConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MemoriesConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "MemoriesCondition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "type": "object",
          "description": "The interaction to run if the player's memories level matches the key.",
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Interaction"
              },
              {
                "$ref": "Interaction.json#"
              }
            ]
          },
          "propertyNames": {
            "description": "A string that contains any integer",
            "pattern": "^[0-9]+$"
          }
        },
        "Failed": {
          "description": "The interaction to run if the player's memories level does not match any key.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ModifyInventoryInteraction": {
      "type": "object",
      "title": "ModifyInventoryInteraction",
      "description": "Modifies an item in the inventory.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ModifyInventory\" to function as this type.",
          "const": "ModifyInventory"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ModifyInventoryInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ModifyInventoryInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ModifyInventory"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "RequiredGameMode": {
          "type": [
            "string",
            "null"
          ],
          "title": "GameMode",
          "enumDescriptions": [
            "The normal gamemode for players playing the game.",
            "Makes the player invulnerable and grants them the ability to fly."
          ],
          "markdownEnumDescriptions": [
            "The normal gamemode for players playing the game.",
            "Makes the player invulnerable and grants them the ability to fly."
          ],
          "enum": [
            "Adventure",
            "Creative"
          ]
        },
        "ItemToRemove": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ItemStack"
            },
            {
              "type": "null"
            }
          ]
        },
        "AdjustHeldItemQuantity": {
          "type": "integer",
          "default": 0
        },
        "ItemToAdd": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ItemStack"
            },
            {
              "type": "null"
            }
          ]
        },
        "AdjustHeldItemDurability": {
          "type": "number",
          "default": 0
        },
        "BrokenItem": {
          "type": [
            "string",
            "null"
          ]
        },
        "NotifyOnBreak": {
          "type": "boolean",
          "description": "If true, shows the 'item broken' message and plays the break sound when durability reaches 0. Defaults to true for tools (no BrokenItem or same item), false for transformations (different BrokenItem)."
        },
        "NotifyOnBreakMessage": {
          "type": [
            "string",
            "null"
          ],
          "description": "Custom translation key for the break notification message. Supports {itemName} parameter. Defaults to 'server.general.repair.itemBroken' if not specified."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MountInteraction": {
      "type": "object",
      "title": "MountInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Mount\" to function as this type.",
          "const": "Mount"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MountInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MountInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Mount"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "AttachmentOffset": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "Controller": {
          "type": "string",
          "title": "MountController",
          "enum": [
            "Minecart",
            "BlockMount"
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "MovementConditionInteraction": {
      "type": "object",
      "title": "MovementConditionInteraction",
      "description": "An interaction that runs different interactions based on the movement the user is current performing.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"MovementCondition\" to function as this type.",
          "const": "MovementCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another MovementConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **MovementConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "MovementCondition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Forward": {
          "description": "The interaction to run if the player is moving forward.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Back": {
          "description": "The interaction to run if the player is moving backwards.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Left": {
          "description": "The interaction to run if the player is moving left.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Right": {
          "description": "The interaction to run if the player is moving right.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ForwardLeft": {
          "description": "The interaction to run if the player is moving forward and left.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ForwardRight": {
          "description": "The interaction to run if the player is moving forward and right.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "BackLeft": {
          "description": "The interaction to run if the player is moving backwards and left.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "BackRight": {
          "description": "The interaction to run if the player is moving backwards and right.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OpenBenchPageInteraction": {
      "type": "object",
      "title": "OpenBenchPageInteraction",
      "description": "Opens the given crafting bench page.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OpenBenchPage\" to function as this type.",
          "const": "OpenBenchPage"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OpenBenchPageInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OpenBenchPageInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "OpenBenchPage"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Page": {
          "type": "string",
          "title": "PageType",
          "enum": [
            "SimpleCrafting",
            "DiagramCrafting",
            "StructuralCrafting"
          ],
          "default": "SimpleCrafting"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OpenContainerInteraction": {
      "type": "object",
      "title": "OpenContainerInteraction",
      "description": "Opens the container of the block currently being interacted with.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OpenContainer\" to function as this type.",
          "const": "OpenContainer"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OpenContainerInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OpenContainerInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "OpenContainer"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OpenCustomUIInteraction": {
      "type": "object",
      "title": "OpenCustomUIInteraction",
      "description": "Opens a custom ui page.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OpenCustomUI\" to function as this type.",
          "const": "OpenCustomUI"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OpenCustomUIInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OpenCustomUIInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "OpenCustomUI"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Page": {
          "title": "Type Selector",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ConfigureInstanceBlockPage"
            },
            {
              "$ref": "common.schema.json#/$defs/ItemRepairPageSupplier"
            },
            {
              "$ref": "common.schema.json#/$defs/LaunchPadSettingsPage"
            },
            {
              "$ref": "common.schema.json#/$defs/MemoriesPage"
            },
            {
              "$ref": "common.schema.json#/$defs/MemoriesUnlockedPage"
            },
            {
              "$ref": "common.schema.json#/$defs/PortalDevicePageSupplier"
            },
            {
              "$ref": "common.schema.json#/$defs/PrefabSpawnerSettingsPage"
            },
            {
              "$ref": "common.schema.json#/$defs/ShopPageSupplier"
            },
            {
              "$ref": "common.schema.json#/$defs/TeleporterSettingsPageSupplier"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ConfigureInstanceBlockPage": {
      "type": "object",
      "title": "ConfigureInstanceBlockPage",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ConfigInstanceBlock\" to function as this type.",
          "const": "ConfigInstanceBlock"
        }
      },
      "additionalProperties": false
    },
    "ItemRepairPageSupplier": {
      "type": "object",
      "title": "ItemRepairPageSupplier",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ItemRepair\" to function as this type.",
          "const": "ItemRepair"
        },
        "RepairPenalty": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "LaunchPadSettingsPage": {
      "type": "object",
      "title": "LaunchPadSettingsPage",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LaunchPad\" to function as this type.",
          "const": "LaunchPad"
        }
      },
      "additionalProperties": false
    },
    "MemoriesPage": {
      "type": "object",
      "title": "MemoriesPage",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Memories\" to function as this type.",
          "const": "Memories"
        }
      },
      "additionalProperties": false
    },
    "MemoriesUnlockedPage": {
      "type": "object",
      "title": "MemoriesUnlockedPage",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"MemoriesUnlocked\" to function as this type.",
          "const": "MemoriesUnlocked"
        }
      },
      "additionalProperties": false
    },
    "PortalDevicePageSupplier": {
      "type": "object",
      "title": "PortalDevicePageSupplier",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PortalDevice\" to function as this type.",
          "const": "PortalDevice"
        },
        "Config": {
          "description": "The portal device's config.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/PortalDeviceConfig"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "PrefabSpawnerSettingsPage": {
      "type": "object",
      "title": "PrefabSpawnerSettingsPage",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PrefabSpawner\" to function as this type.",
          "const": "PrefabSpawner"
        }
      },
      "additionalProperties": false
    },
    "ShopPageSupplier": {
      "type": "object",
      "title": "ShopPageSupplier",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Shop\" to function as this type.",
          "const": "Shop"
        },
        "ShopId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "TeleporterSettingsPageSupplier": {
      "type": "object",
      "title": "TeleporterSettingsPageSupplier",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Teleporter\" to function as this type.",
          "const": "Teleporter"
        },
        "Create": {
          "type": "boolean",
          "default": true
        },
        "Mode": {
          "type": [
            "string",
            "null"
          ],
          "title": "Mode",
          "enum": [
            "Full",
            "Warp"
          ],
          "default": "Full"
        },
        "ActiveState": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "OpenItemStackContainerInteraction": {
      "type": "object",
      "title": "OpenItemStackContainerInteraction",
      "description": "Opens a container contained within the current held item.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OpenItemStackContainer\" to function as this type.",
          "const": "OpenItemStackContainer"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OpenItemStackContainerInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OpenItemStackContainerInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "OpenItemStackContainer"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OpenPageInteraction": {
      "type": "object",
      "title": "OpenPageInteraction",
      "description": "Opens a predefined page.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OpenPage\" to function as this type.",
          "const": "OpenPage"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OpenPageInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OpenPageInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "OpenPage"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Page": {
          "type": "string",
          "title": "Page",
          "enum": [
            "None",
            "Bench",
            "Inventory",
            "ToolsSettings",
            "Map",
            "MachinimaEditor",
            "ContentCreation",
            "Custom"
          ]
        },
        "CanCloseThroughInteraction": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OpenProcessingBenchInteraction": {
      "type": "object",
      "title": "OpenProcessingBenchInteraction",
      "description": "Opens the processing bench page.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"OpenProcessingBench\" to function as this type.",
          "const": "OpenProcessingBench"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OpenProcessingBenchInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OpenProcessingBenchInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "OpenProcessingBench"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ParallelInteraction": {
      "type": "object",
      "title": "ParallelInteraction",
      "description": "Runs the provided interactions in parallel to this interaction chain.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Parallel\" to function as this type.",
          "const": "Parallel"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ParallelInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ParallelInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Parallel"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Interactions": {
          "type": "array",
          "description": "The collection of interaction roots to run in parallel via forks.",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to RootInteraction"
              },
              {
                "$ref": "RootInteraction.json#"
              }
            ]
          },
          "minItems": 2,
          "maxItems": 2147483647
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PickBlockInteraction": {
      "type": "object",
      "title": "PickBlockInteraction",
      "description": "Performs a 'block pick', moving a the target block to the user's hand if they have it in their inventory or are in creative.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PickBlock\" to function as this type.",
          "const": "PickBlock"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PickBlockInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PickBlockInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "PickBlock"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PickupItemInteraction": {
      "type": "object",
      "title": "PickupItemInteraction",
      "description": "Picks up an item entity and adds it to the player's inventory.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PickupItem\" to function as this type.",
          "const": "PickupItem"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PickupItemInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PickupItemInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "PickupItem"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PlaceBlockInteraction": {
      "type": "object",
      "title": "PlaceBlockInteraction",
      "description": "Places the current or given block.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PlaceBlock\" to function as this type.",
          "const": "PlaceBlock"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PlaceBlockInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PlaceBlockInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "PlaceBlock"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "BlockTypeToPlace": {
          "type": [
            "string",
            "null"
          ],
          "description": "Overrides the placed block type of the held item with the provided block type."
        },
        "RemoveItemInHand": {
          "type": "boolean",
          "description": "Determines whether to remove the item that is in the instigating entities hand.",
          "default": true
        },
        "AllowDragPlacement": {
          "type": "boolean",
          "description": "If drag placement should be used when click is held for this interaction.",
          "default": true
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PlaceFluidInteraction": {
      "type": "object",
      "title": "PlaceFluidInteraction",
      "description": "Places the current or given block.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PlaceFluid\" to function as this type.",
          "const": "PlaceFluid"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PlaceFluidInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PlaceFluidInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "PlaceFluid"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "FluidToPlace": {
          "type": [
            "string",
            "null"
          ]
        },
        "RemoveItemInHand": {
          "type": "boolean",
          "default": true
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PlacementCountConditionInteraction": {
      "type": "object",
      "title": "PlacementCountConditionInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PlacementCountCondition\" to function as this type.",
          "const": "PlacementCountCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PlacementCountConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PlacementCountConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "PlacementCountCondition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Block": {
          "type": "string"
        },
        "Value": {
          "type": "integer",
          "default": 0
        },
        "LessThan": {
          "type": "boolean",
          "default": true
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EnterPortalInteraction": {
      "type": "object",
      "title": "EnterPortalInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Portal\" to function as this type.",
          "const": "Portal"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EnterPortalInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EnterPortalInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Portal"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ReturnPortalInteraction": {
      "type": "object",
      "title": "ReturnPortalInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PortalReturn\" to function as this type.",
          "const": "PortalReturn"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ReturnPortalInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ReturnPortalInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "PortalReturn"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PrefabSelectionInteraction": {
      "type": "object",
      "title": "PrefabSelectionInteraction",
      "description": "Interaction that handles the selection functionally for the prefab selection tool.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PrefabSelectionInteraction\" to function as this type.",
          "const": "PrefabSelectionInteraction"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PrefabSelectionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PrefabSelectionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "PrefabSelectionInteraction"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "PrefabSetAnchorInteraction": {
      "type": "object",
      "title": "PrefabSetAnchorInteraction",
      "description": "Sets the prefab anchor.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"PrefabSetAnchorInteraction\" to function as this type.",
          "const": "PrefabSetAnchorInteraction"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another PrefabSetAnchorInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **PrefabSetAnchorInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "PrefabSetAnchorInteraction"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ProjectileInteraction": {
      "type": "object",
      "title": "ProjectileInteraction",
      "description": "Fires a projectile.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Projectile\" to function as this type.",
          "const": "Projectile"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ProjectileInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ProjectileInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Projectile"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Config": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the projectile config asset to use for the projectile."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RefillContainerInteraction": {
      "type": "object",
      "title": "RefillContainerInteraction",
      "description": "Refills a container item that is currently held.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"RefillContainer\" to function as this type.",
          "const": "RefillContainer"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RefillContainerInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RefillContainerInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "RefillContainer"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "States": {
          "type": "object",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/RefillState"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RefillState": {
      "type": "object",
      "title": "RefillState",
      "properties": {
        "AllowedFluids": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "TransformFluid": {
          "type": [
            "string",
            "null"
          ]
        },
        "Durability": {
          "type": "number",
          "default": -1
        }
      },
      "additionalProperties": false
    },
    "RemoveEntityInteraction": {
      "type": "object",
      "title": "RemoveEntityInteraction",
      "description": "Despawns the given entity.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"RemoveEntity\" to function as this type.",
          "const": "RemoveEntity"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RemoveEntityInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RemoveEntityInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "RemoveEntity"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Entity": {
          "type": "string",
          "title": "InteractionTarget",
          "description": "The entity to target for this interaction.",
          "enumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "markdownEnumDescriptions": [
            "Causes the interaction to target the entity that triggered/owns the interaction chain.",
            "Causes the interaction to target the entity that owns the interaction chain.",
            "Causes the interaction to target the entity that is the target of the interaction chain."
          ],
          "enum": [
            "User",
            "Owner",
            "Target"
          ],
          "default": "User"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RepeatInteraction": {
      "type": "object",
      "title": "RepeatInteraction",
      "description": "Forks from the current interaction into one or more chains that run the specified interactions.\n\nWhen run this will create a new chain that will run the interactions specified in `ForkInteractions`. This will then wait until that chain completes. If the chain completes successfully it will then check the `Repeat` field to see if it needs to run again, if not then the interactions `Next` are run otherwise this repeats with the next fork. If the chain fails then any repeating is ignored and the interactions `Failed` are run instead.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Repeat\" to function as this type.",
          "const": "Repeat"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RepeatInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RepeatInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Repeat"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "ForkInteractions": {
          "description": "The interactions to run in the forks created by this interaction.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            }
          ]
        },
        "Repeat": {
          "type": "integer",
          "description": "The number of times to repeat. -1 is considered as infinite, be careful when using this value.",
          "anyOf": [
            {
              "type": "integer",
              "minimum": 1
            },
            {
              "type": "integer",
              "const": -1
            }
          ],
          "default": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ReplaceInteraction": {
      "type": "object",
      "title": "ReplaceInteraction",
      "description": "Runs the interaction defined by the interaction variables if defined.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Replace\" to function as this type.",
          "const": "Replace"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ReplaceInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ReplaceInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Replace"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "DefaultValue": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Var": {
          "type": "string"
        },
        "DefaultOk": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ResetCooldownInteraction": {
      "type": "object",
      "title": "ResetCooldownInteraction",
      "description": "Resets the cooldown.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ResetCooldown\" to function as this type.",
          "const": "ResetCooldown"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ResetCooldownInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ResetCooldownInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ResetCooldown"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Cooldown": {
          "description": "The cooldown concerning this interaction, defaulting to the root cooldown if none presented",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCooldown"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "InteractionCooldown": {
      "type": "object",
      "title": "InteractionCooldown",
      "properties": {
        "Id": {
          "type": [
            "string",
            "null"
          ],
          "description": "The Id for the cooldown.\n\nCooldowns can be used on different interactions but share a cooldown."
        },
        "Cooldown": {
          "description": "The time in seconds this cooldown should last for.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Charges": {
          "type": [
            "array",
            "null"
          ],
          "description": "The charge times available for this interaction.",
          "items": {
            "type": "number",
            "minimum": 0
          }
        },
        "SkipCooldownReset": {
          "type": "boolean",
          "description": "Determines whether resetting cooldown should be skipped.",
          "default": false
        },
        "InterruptRecharge": {
          "type": "boolean",
          "description": "Determines whether recharge is interrupted by use.",
          "default": false
        },
        "ClickBypass": {
          "type": "boolean",
          "description": "Whether this cooldown can be bypassed by clicking.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "RunOnBlockTypesInteraction": {
      "type": "object",
      "title": "RunOnBlockTypesInteraction",
      "description": "Searches for matching block types within a radius and runs interactions on each found block up to a configured maximum number of blocks.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"RunOnBlockTypes\" to function as this type.",
          "const": "RunOnBlockTypes"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RunOnBlockTypesInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RunOnBlockTypesInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "RunOnBlockTypes"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Range": {
          "type": "integer",
          "description": "The spherical radius to search for matching block types.",
          "exclusiveMinimum": 0,
          "default": 0
        },
        "BlockSets": {
          "type": "array",
          "description": "Array of BlockSet IDs to match within the search radius.",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "MaxCount": {
          "type": "integer",
          "description": "Maximum number of block positions to select for running interactions (uses reservoir sampling).",
          "exclusiveMinimum": 0,
          "default": 0
        },
        "Interactions": {
          "description": "The interaction chain to run on each found block. Can be defined inline or as a reference.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RunRootInteraction": {
      "type": "object",
      "title": "RunRootInteraction",
      "description": "Runs the given interaction root.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"RunRootInteraction\" to function as this type.",
          "const": "RunRootInteraction"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another RunRootInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **RunRootInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "RunRootInteraction"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "RootInteraction": {
          "type": "string",
          "description": "A reference to a root interaction to run"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SeatingInteraction": {
      "type": "object",
      "title": "SeatingInteraction",
      "description": "Arranges perfect seating accommodations",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Seating\" to function as this type.",
          "const": "Seating"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SeatingInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SeatingInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Seating"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SelectInteraction": {
      "type": "object",
      "title": "SelectInteraction",
      "description": "An interaction that can be used to find entities/blocks within a given area.\n\nThis runs the given `Selector` every tick this interactions runs for, the selector may change the search area over time (based on `RunTime`). e.g. to trace out an arc of a sword swing.\n\nWhen an entity/block is found this interaction will run a set of interactions (as defined by `HitEntity`/`HitBlock`) per a entity/block, this will not interrupt the selector and it will continue searching until the select interaction completes.\n\nThis interaction does not wait for any forked interaction chains from `HitEntity`/`HitBlock` to complete before finishing itself.",
      "markdownDescription": "An interaction that can be used to find entities/blocks within a given area.\n\nThis runs the given `Selector` every tick this interactions runs for, the selector may change the search area over time (based on `RunTime`). e.g. to trace out an arc of a sword swing.\n\nWhen an entity/block is found this interaction will run a set of interactions (as defined by `HitEntity`/`HitBlock`) **per a entity/block**, this will not interrupt the selector and it will continue searching until the select interaction completes.\n\nThis interaction does not wait for any forked interaction chains from `HitEntity`/`HitBlock` to complete before finishing itself.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Selector\" to function as this type.",
          "const": "Selector"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SelectInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SelectInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Selector"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Selector": {
          "title": "Type Selector",
          "description": "The selector to use to find entities and blocks in an area.\nThe selector may be spread over the duration `RunTime`.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AOECircleSelector"
            },
            {
              "$ref": "common.schema.json#/$defs/AOECylinderSelector"
            },
            {
              "$ref": "common.schema.json#/$defs/HorizontalSelector"
            },
            {
              "$ref": "common.schema.json#/$defs/RaycastSelector"
            },
            {
              "$ref": "common.schema.json#/$defs/StabSelector"
            }
          ]
        },
        "HitEntity": {
          "description": "The interactions to fork into when an entity is hit by the selector.\nThe hit entity will be the target of the interaction chain.\n\nAn entity cannot be hit multiple times by a single selector.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "HitEntityRules": {
          "type": [
            "array",
            "null"
          ],
          "description": "Tests any hit entity with the given rules, running a fork for the last one matched.\nThis overrides `HitEntity` if any match.",
          "items": {
            "$ref": "common.schema.json#/$defs/HitEntity"
          }
        },
        "HitBlock": {
          "description": "The interactions to fork into when a block is hit by the selector.\nThe hit block will be the target of the interaction chain.\n\nA block cannot be hit multiple times by a single selector.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "FailOn": {
          "type": [
            "string",
            "null"
          ],
          "title": "FailOnType",
          "description": "Changes what causes the Failed case to run",
          "enum": [
            "Neither",
            "Entity",
            "Block",
            "Either"
          ],
          "default": "Neither"
        },
        "IgnoreOwner": {
          "type": "boolean",
          "description": "Determines whether the owner of the affiliated entity should be ignored in the selection.\n\nFor example, ignoring the thrower of a projectile.",
          "default": true
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AOECircleSelector": {
      "type": "object",
      "title": "AOECircleSelector",
      "description": "A selector that selects all entities within a given range.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"AOECircle\" to function as this type.",
          "const": "AOECircle"
        },
        "Range": {
          "description": "The range of the area to search for targets in.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Offset": {
          "description": "The offset of the area to search for targets in.",
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AOECylinderSelector": {
      "type": "object",
      "title": "AOECylinderSelector",
      "description": "A selector that selects all entities within a given range and height.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"AOECylinder\" to function as this type.",
          "const": "AOECylinder"
        },
        "Range": {
          "description": "The range of the area to search for targets in.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Offset": {
          "description": "The offset of the area to search for targets in.",
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Height": {
          "description": "The height of the area to search for targets in from the entity position.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "HorizontalSelector": {
      "type": "object",
      "title": "HorizontalSelector",
      "description": "A selector that swings in a horizontal arc over a given period of time.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Horizontal\" to function as this type.",
          "const": "Horizontal"
        },
        "Length": {
          "type": "number",
          "description": "The angle length in degrees that the arc will cover.",
          "default": 0
        },
        "Direction": {
          "type": "string",
          "title": "Direction",
          "description": "The direction the swing should travel in.",
          "enumDescriptions": [
            "A arc that starts at the left and moves towards the right.",
            "A arc that starts at the right and moves towards the left."
          ],
          "markdownEnumDescriptions": [
            "A arc that starts at the left and moves towards the right.",
            "A arc that starts at the right and moves towards the left."
          ],
          "enum": [
            "ToRight",
            "ToLeft"
          ]
        },
        "StartDistance": {
          "type": "number",
          "description": "The distance from the entity that the selector starts its search from.",
          "default": 0.01
        },
        "EndDistance": {
          "type": "number",
          "description": "The distance from the entity that the selector ends its search at.",
          "default": 0
        },
        "ExtendTop": {
          "type": "number",
          "description": "The amount to extend the top of the selector by.",
          "default": 1
        },
        "ExtendBottom": {
          "type": "number",
          "description": "The amount to extend the bottom of the selector by.",
          "default": 1
        },
        "YawStartOffset": {
          "type": "number",
          "description": "The yaw rotation offset in degrees for this selector",
          "default": 0
        },
        "PitchOffset": {
          "type": "number",
          "description": "The pitch rotation offset in degrees for this selector",
          "default": 0
        },
        "RollOffset": {
          "type": "number",
          "description": "The roll rotation offset in degrees for this selector",
          "default": 0
        },
        "TestLineOfSight": {
          "type": "boolean",
          "description": "Whether to test for line of sight between the user and the target before counting a hit",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "RaycastSelector": {
      "type": "object",
      "title": "RaycastSelector",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Raycast\" to function as this type.",
          "const": "Raycast"
        },
        "Offset": {
          "description": "The offset of the area to search for targets in.",
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Distance": {
          "type": "integer",
          "description": "The max search distance for the raycast",
          "default": 30
        },
        "IgnoreFluids": {
          "type": "boolean",
          "default": false
        },
        "IgnoreEmptyCollisionMaterial": {
          "type": "boolean",
          "default": false
        },
        "BlockTag": {
          "type": [
            "string",
            "null"
          ],
          "description": "The required tag for the block to have to match for the raycast to hit them"
        }
      },
      "additionalProperties": false
    },
    "StabSelector": {
      "type": "object",
      "title": "StabSelector",
      "description": "A selector  that stabs in a straight line over a given period of time.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Stab\" to function as this type.",
          "const": "Stab"
        },
        "StartDistance": {
          "type": "number",
          "description": "The distance from the entity that the selector starts its search from.",
          "default": 0.01
        },
        "EndDistance": {
          "type": "number",
          "description": "The distance from the entity that the selector ends its search at.",
          "default": 0
        },
        "ExtendTop": {
          "type": "number",
          "description": "The amount to extend the top of the selector by.",
          "default": 1
        },
        "ExtendBottom": {
          "type": "number",
          "description": "The amount to extend the bottom of the selector by.",
          "default": 1
        },
        "ExtendLeft": {
          "type": "number",
          "description": "The amount to extend the left side of the selector by.",
          "default": 1
        },
        "ExtendRight": {
          "type": "number",
          "description": "The amount to extend the right side of the selector by.",
          "default": 1
        },
        "YawOffset": {
          "type": "number",
          "description": "The yaw rotation offset in degrees for this selector",
          "default": 0
        },
        "PitchOffset": {
          "type": "number",
          "description": "The pitch rotation offset in degrees for this selector",
          "default": 0
        },
        "RollOffset": {
          "type": "number",
          "description": "The roll rotation offset in degrees for this selector",
          "default": 0
        },
        "TestLineOfSight": {
          "type": "boolean",
          "description": "Whether to test for line of sight between the user and the target before counting a hit",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "HitEntity": {
      "type": "object",
      "title": "HitEntity",
      "properties": {
        "Next": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            }
          ]
        },
        "Matchers": {
          "type": "array",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/PlayerMatcher"
              },
              {
                "$ref": "common.schema.json#/$defs/VulnerableMatcher"
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "PlayerMatcher": {
      "type": "object",
      "title": "PlayerMatcher",
      "description": "Matches only players",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Player\" to function as this type.",
          "const": "Player"
        },
        "Invert": {
          "type": "boolean",
          "description": "Inverts the result of the matcher",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "VulnerableMatcher": {
      "type": "object",
      "title": "VulnerableMatcher",
      "description": "Used to match any entity that is attackable",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Vulnerable\" to function as this type.",
          "const": "Vulnerable"
        },
        "Invert": {
          "type": "boolean",
          "description": "Inverts the result of the matcher",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "SendMessageInteraction": {
      "type": "object",
      "title": "SendMessageInteraction",
      "description": "Debug interaction that sends a message on use.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SendMessage\" to function as this type.",
          "const": "SendMessage"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SendMessageInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SendMessageInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "SendMessage"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Message": {
          "type": [
            "string",
            "null"
          ]
        },
        "Key": {
          "type": [
            "string",
            "null"
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SerialInteraction": {
      "type": "object",
      "title": "SerialInteraction",
      "description": "Runs the given interactions in order.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Serial\" to function as this type.",
          "const": "Serial"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SerialInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SerialInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Serial"
          }
        },
        "Interactions": {
          "type": "array",
          "description": "A list of interactions to run. They will be executed in the order specified sequentially.",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Interaction"
              },
              {
                "$ref": "Interaction.json#"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SetMemoriesCapacityInteraction": {
      "type": "object",
      "title": "SetMemoriesCapacityInteraction",
      "description": "Sets how many memories a player can store.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SetMemoriesCapacity\" to function as this type.",
          "const": "SetMemoriesCapacity"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SetMemoriesCapacityInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SetMemoriesCapacityInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "SetMemoriesCapacity"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Capacity": {
          "type": "integer",
          "description": "Defines the amount of memories that a player can store.",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SimpleInteraction": {
      "type": "object",
      "title": "SimpleInteraction",
      "description": "A interaction that does nothing other than base interaction features. Can be used for simple delays or triggering animations in between other interactions.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Simple\" to function as this type.",
          "const": "Simple"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SimpleInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SimpleInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Simple"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SpawnDeployableAtHitLocationInteraction": {
      "type": "object",
      "title": "SpawnDeployableAtHitLocationInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SpawnDeployableAtHitLocation\" to function as this type.",
          "const": "SpawnDeployableAtHitLocation"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SpawnDeployableAtHitLocationInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SpawnDeployableAtHitLocationInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "SpawnDeployableAtHitLocation"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Config": {
          "title": "Type Selector",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DeployableAoeConfig"
            },
            {
              "$ref": "common.schema.json#/$defs/DeployableTrapConfig"
            },
            {
              "$ref": "common.schema.json#/$defs/DeployableTrapSpawnerConfig"
            },
            {
              "$ref": "common.schema.json#/$defs/DeployableTurretConfig"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SpawnDeployableFromRaycastInteraction": {
      "type": "object",
      "title": "SpawnDeployableFromRaycastInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SpawnDeployableFromRaycast\" to function as this type.",
          "const": "SpawnDeployableFromRaycast"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SpawnDeployableFromRaycastInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SpawnDeployableFromRaycastInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "SpawnDeployableFromRaycast"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Config": {
          "title": "Type Selector",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DeployableAoeConfig"
            },
            {
              "$ref": "common.schema.json#/$defs/DeployableTrapConfig"
            },
            {
              "$ref": "common.schema.json#/$defs/DeployableTrapSpawnerConfig"
            },
            {
              "$ref": "common.schema.json#/$defs/DeployableTurretConfig"
            }
          ]
        },
        "PreviewStatConditions": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of string to float",
          "description": "Modifiers to apply to EntityStats.",
          "additionalProperties": {
            "type": "number"
          }
        },
        "MaxPlacementDistance": {
          "description": "The max distance at which the player can deploy the deployable.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SpawnMinecartInteraction": {
      "type": "object",
      "title": "SpawnMinecartInteraction",
      "description": "Spawns a minecart at the target block",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SpawnMinecart\" to function as this type.",
          "const": "SpawnMinecart"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SpawnMinecartInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SpawnMinecartInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "SpawnMinecart"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Model": {
          "type": [
            "string",
            "null"
          ]
        },
        "CartInteractions": {
          "type": [
            "object",
            "null"
          ],
          "properties": {
            "Primary": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Secondary": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability1": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability2": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability3": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Use": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Pick": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Pickup": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "CollisionEnter": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "CollisionLeave": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Collision": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "EntityStatEffect": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "SwapTo": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "SwapFrom": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Death": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Wielding": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileSpawn": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileHit": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileMiss": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileBounce": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Held": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "HeldOffhand": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Equipped": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Dodge": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "GameModeSwap": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            }
          },
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to RootInteraction"
              },
              {
                "$ref": "RootInteraction.json#"
              }
            ]
          },
          "propertyNames": {
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SpawnNPCInteraction": {
      "type": "object",
      "title": "SpawnNPCInteraction",
      "description": "Spawns an NPC on the block that is being interacted with.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SpawnNPC\" to function as this type.",
          "const": "SpawnNPC"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SpawnNPCInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SpawnNPCInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "SpawnNPC"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "EntityId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the entity asset to spawn."
        },
        "SpawnOffset": {
          "description": "The offset to apply to the spawn position of the NPC, relative to the block's rotation and center.",
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "SpawnYawOffset": {
          "description": "The yaw rotation offset in radians to apply to the NPC rotation, relative to the block's yaw.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SpawnChance": {
          "description": "The chance of the NPC spawning when the interaction is triggered.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SpawnPrefabInteraction": {
      "type": "object",
      "title": "SpawnPrefabInteraction",
      "description": "Spawns a prefab at the current location.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SpawnPrefab\" to function as this type.",
          "const": "SpawnPrefab"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SpawnPrefabInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SpawnPrefabInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "SpawnPrefab"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "PrefabPath": {
          "type": [
            "string",
            "null"
          ]
        },
        "Offset": {
          "default": {
            "X": 0,
            "Y": 0,
            "Z": 0
          },
          "$ref": "common.schema.json#/$defs/Vector3i"
        },
        "RotationYaw": {
          "type": "string",
          "title": "Rotation",
          "enum": [
            "None",
            "Ninety",
            "OneEighty",
            "TwoSeventy"
          ],
          "default": "None"
        },
        "OriginSource": {
          "type": "string",
          "title": "OriginSource",
          "enum": [
            "Entity",
            "Block"
          ],
          "default": "Entity"
        },
        "Force": {
          "type": "boolean",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "StartObjectiveInteraction": {
      "type": "object",
      "title": "StartObjectiveInteraction",
      "description": "Starts the given objective or adds the player to an existing one.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"StartObjective\" to function as this type.",
          "const": "StartObjective"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another StartObjectiveInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **StartObjectiveInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "StartObjective"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Setup": {
          "title": "Type Selector",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/SetupObjective"
            },
            {
              "$ref": "common.schema.json#/$defs/SetupObjectiveLine"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SetupObjective": {
      "type": "object",
      "title": "SetupObjective",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Objective\" to function as this type.",
          "const": "Objective"
        },
        "ObjectiveId": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "SetupObjectiveLine": {
      "type": "object",
      "title": "SetupObjectiveLine",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ObjectiveLine\" to function as this type.",
          "const": "ObjectiveLine"
        },
        "ObjectiveLineId": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "StatsConditionInteraction": {
      "type": "object",
      "title": "StatsConditionInteraction",
      "description": "Interaction that is successful if the given stat conditions match.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"StatsCondition\" to function as this type.",
          "const": "StatsCondition"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another StatsConditionInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **StatsConditionInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "StatsCondition"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Costs": {
          "type": "object",
          "title": "Map of string to float",
          "additionalProperties": {
            "type": "number"
          }
        },
        "LessThan": {
          "type": "boolean",
          "default": false
        },
        "Lenient": {
          "type": "boolean",
          "description": "Specifies that the interaction can run even if the stat cost is not met, providing that the value is greater than zero.",
          "default": false
        },
        "ValueType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ValueType",
          "description": "Enum to specify if the Costs must be considered as absolute values or percent. Default value is Absolute. When using ValueType.Absolute, '100' matches the max value.",
          "enum": [
            "Percent",
            "Absolute"
          ],
          "default": "Absolute"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "StatsConditionWithModifierInteraction": {
      "type": "object",
      "title": "StatsConditionWithModifierInteraction",
      "description": "Interaction that is successful if the given stat conditions match.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"StatsConditionWithModifier\" to function as this type.",
          "const": "StatsConditionWithModifier"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another StatsConditionWithModifierInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **StatsConditionWithModifierInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "StatsConditionWithModifier"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Costs": {
          "type": "object",
          "title": "Map of string to float",
          "additionalProperties": {
            "type": "number"
          }
        },
        "LessThan": {
          "type": "boolean",
          "default": false
        },
        "Lenient": {
          "type": "boolean",
          "description": "Specifies that the interaction can run even if the stat cost is not met, providing that the value is greater than zero.",
          "default": false
        },
        "ValueType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ValueType",
          "description": "Enum to specify if the Costs must be considered as absolute values or percent. Default value is Absolute. When using ValueType.Absolute, '100' matches the max value.",
          "enum": [
            "Percent",
            "Absolute"
          ],
          "default": "Absolute"
        },
        "InteractionModifierId": {
          "type": "string",
          "title": "InteractionModifierId",
          "enum": [
            "Dodge"
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TeleportConfigInstanceInteraction": {
      "type": "object",
      "title": "TeleportConfigInstanceInteraction",
      "description": "Teleports the Player to the named instance, creating it if required.\n\nThis is configured via a UI instead of inside the interaction. This interaction just executes that set configuration.",
      "markdownDescription": "Teleports the **Player** to the named instance, creating it if required.\n\nThis is configured via a UI instead of inside the interaction. This interaction just executes that set configuration.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TeleportConfigInstance\" to function as this type.",
          "const": "TeleportConfigInstance"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TeleportConfigInstanceInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TeleportConfigInstanceInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "TeleportConfigInstance"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TeleportInstanceInteraction": {
      "type": "object",
      "title": "TeleportInstanceInteraction",
      "description": "Teleports the Player to the named instance, creating it if required.",
      "markdownDescription": "Teleports the **Player** to the named instance, creating it if required.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TeleportInstance\" to function as this type.",
          "const": "TeleportInstance"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TeleportInstanceInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TeleportInstanceInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "TeleportInstance"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "InstanceName": {
          "type": "string",
          "description": "The name of the instance to teleport to.",
          "markdownDescription": "The name of the **instance** to teleport to.",
          "hytaleCustomAssetRef": "Instance"
        },
        "InstanceKey": {
          "type": [
            "string",
            "null"
          ],
          "description": "The key to name the world. Random if not provided"
        },
        "PositionOffset": {
          "description": "The offset to apply to the return point.\n\nUsed to prevent repeated interactions when returning from the instance.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Rotation": {
          "description": "The rotation to set the player to when returning from an instance.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f@1"
            },
            {
              "type": "null"
            }
          ]
        },
        "OriginSource": {
          "type": "string",
          "title": "OriginSource",
          "description": "The source to use for the return position.\n\nDefaults to the player's position.",
          "enumDescriptions": [
            "The origin of operations will be based on the player's current position.",
            "The origin of operations will be based on the middle of the block's hitbox."
          ],
          "markdownEnumDescriptions": [
            "The origin of operations will be based on the player's current position.",
            "The origin of operations will be based on the middle of the block's hitbox."
          ],
          "enum": [
            "Player",
            "Block"
          ],
          "default": "Player"
        },
        "PersonalReturnPoint": {
          "type": "boolean",
          "description": "Whether the player entering the instance will have their own return point\nset to the current location. Overriding the world's return point.",
          "default": false
        },
        "CloseOnBlockRemove": {
          "type": "boolean",
          "description": "Whether to delete the instance when the portal block is removed.",
          "default": true
        },
        "RemoveBlockAfter": {
          "type": "number",
          "description": "The number of seconds to wait before removing the block that triggered\nthe interaction. A negative value disables this.\n\nThis is needed instead of using another interaction due to all interactions\nbeing stopped once teleporting to another world.",
          "default": -1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TeleporterInteraction": {
      "type": "object",
      "title": "TeleporterInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Teleporter\" to function as this type.",
          "const": "Teleporter"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TeleporterInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TeleporterInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Teleporter"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Particle": {
          "type": [
            "string",
            "null"
          ],
          "description": "The particle to play on the entity when teleporting."
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "ToggleGliderInteraction": {
      "type": "object",
      "title": "ToggleGliderInteraction",
      "description": "Toggles Glider movement for the player.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ToggleGlider\" to function as this type.",
          "const": "ToggleGlider"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ToggleGliderInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ToggleGliderInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "ToggleGlider"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TriggerCooldownInteraction": {
      "type": "object",
      "title": "TriggerCooldownInteraction",
      "description": "Triggers the cooldown as if it was triggered normally.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TriggerCooldown\" to function as this type.",
          "const": "TriggerCooldown"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TriggerCooldownInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TriggerCooldownInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "TriggerCooldown"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Cooldown": {
          "description": "The cooldown concerning this interaction, defaulting to the root cooldown if none presented",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCooldown"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "TriggerSpawnMarkersInteraction": {
      "type": "object",
      "title": "TriggerSpawnMarkersInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TriggerSpawnMarkers\" to function as this type.",
          "const": "TriggerSpawnMarkers"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another TriggerSpawnMarkersInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **TriggerSpawnMarkersInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "TriggerSpawnMarkers"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "MarkerType": {
          "type": [
            "string",
            "null"
          ],
          "description": "The manual spawn marker type to trigger. If omitted, will trigger all manual spawners."
        },
        "Range": {
          "type": "number",
          "description": "Range within which to trigger spawn markers.",
          "exclusiveMinimum": 0,
          "default": 10
        },
        "Count": {
          "type": "integer",
          "description": "Max number of spawn markers to activate. Set to 0 to activate all spawn markers.",
          "minimum": 0,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UseBlockInteraction": {
      "type": "object",
      "title": "UseBlockInteraction",
      "description": "Attempts to use the target block, executing interactions on it if any.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UseBlock\" to function as this type.",
          "const": "UseBlock"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UseBlockInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UseBlockInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "UseBlock"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UseCaptureCrateInteraction": {
      "type": "object",
      "title": "UseCaptureCrateInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UseCaptureCrate\" to function as this type.",
          "const": "UseCaptureCrate"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UseCaptureCrateInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UseCaptureCrateInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "UseCaptureCrate"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "AcceptedNpcGroups": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to NPCGroup"
              },
              {
                "$ref": "NPCGroup.json#"
              }
            ]
          }
        },
        "FullIcon": {
          "type": [
            "string",
            "null"
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UseCoopInteraction": {
      "type": "object",
      "title": "UseCoopInteraction",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UseCoop\" to function as this type.",
          "const": "UseCoop"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UseCoopInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UseCoopInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "UseCoop"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UseEntityInteraction": {
      "type": "object",
      "title": "UseEntityInteraction",
      "description": "Attempts to use the target entity, executing interactions on it if any.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UseEntity\" to function as this type.",
          "const": "UseEntity"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UseEntityInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UseEntityInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "UseEntity"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UseNPCInteraction": {
      "type": "object",
      "title": "UseNPCInteraction",
      "description": "Interacts with a target NPC.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UseNPC\" to function as this type.",
          "const": "UseNPC"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UseNPCInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UseNPCInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "UseNPC"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "UseWateringCanInteraction": {
      "type": "object",
      "title": "UseWateringCanInteraction",
      "description": "Waters the target farmable block.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UseWateringCan\" to function as this type.",
          "const": "UseWateringCan"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another UseWateringCanInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **UseWateringCanInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "UseWateringCan"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "description": "The interactions to run when this interaction succeeds.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "UseLatestTarget": {
          "type": "boolean",
          "description": "Determines whether to use the clients latest target block position for this interaction.",
          "default": false
        },
        "Duration": {
          "type": "integer",
          "default": 0
        },
        "RefreshModifiers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "WieldingInteraction": {
      "type": "object",
      "title": "WieldingInteraction",
      "description": "Interaction that blocks while the key is held and applies various modifiers while active.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Wielding\" to function as this type.",
          "const": "Wielding"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another WieldingInteraction most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **WieldingInteraction** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "Interaction",
            "mapKey": "Type",
            "mapKeyValue": "Wielding"
          }
        },
        "ViewDistance": {
          "type": "number",
          "description": "Configures the distance in which other players will be able to see the effects of this interaction.",
          "default": 96
        },
        "Effects": {
          "description": "Sets effects that will be applied whilst the interaction is running.",
          "anyOf": [
            {
              "default": {
                "WaitForAnimationToFinish": false,
                "ClearAnimationOnFinish": false,
                "ClearSoundEventOnFinish": false,
                "StartDelay": 0
              },
              "$ref": "common.schema.json#/$defs/InteractionEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "HorizontalSpeedMultiplier": {
          "description": "The multiplier to apply to the horizontal speed of the entity whilst this interaction is running.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RunTime": {
          "description": "The time in seconds this interaction should run for. \n\nIf Effects.WaitForAnimationToFinish is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "markdownDescription": "The time in seconds this interaction should run for. \n\nIf *Effects.WaitForAnimationToFinish* is set and the length of the animation is longer than the runtime then the interaction will run for longer than the set time.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "CancelOnItemChange": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled when the entity's held item changes.",
          "default": true
        },
        "Rules": {
          "description": "A set of rules that control when this interaction can run.",
          "default": {
            "Blocking": []
          },
          "$ref": "common.schema.json#/$defs/InteractionRules"
        },
        "Settings": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of GameMode",
          "description": "Per a gamemode settings.",
          "properties": {
            "Adventure": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            },
            "Creative": {
              "$ref": "common.schema.json#/$defs/InteractionSettings"
            }
          },
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/InteractionSettings"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "Camera": {
          "description": "Configures the camera behaviour for this interaction.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCameraSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "FailOnDamage": {
          "type": "boolean",
          "description": "Whether the interaction will be cancelled and the item removed when the entity takes damage",
          "default": false
        },
        "CancelOnOtherClick": {
          "type": "boolean",
          "default": true
        },
        "Forks": {
          "type": [
            "object",
            "null"
          ],
          "description": "A collection of interactions to fork into when the input associated with the interaction type is used.\n\nFor example listing a `Primary` interaction type here with interactions will allow the user to press the input tied to the `Primary` interaction type whilst holding the input used to run the current interaction to run the specified interactions. e.g. Having a shield that you can hold `Secondary` to block and whilst blocking press `Primary` to shield bash.\n\nThis does not cancel the current interaction when triggered but the `CancelOnOtherClick` check will still run and may cancel the interaction.\n\nThe existing forks will continue to run even if this interaction ends.",
          "properties": {
            "Primary": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Secondary": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability1": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability2": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Ability3": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Use": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Pick": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Pickup": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "CollisionEnter": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "CollisionLeave": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Collision": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "EntityStatEffect": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "SwapTo": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "SwapFrom": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Death": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Wielding": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileSpawn": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileHit": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileMiss": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "ProjectileBounce": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Held": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "HeldOffhand": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Equipped": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "Dodge": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            },
            "GameModeSwap": {
              "anyOf": [
                {
                  "type": "string",
                  "title": "Reference to RootInteraction"
                },
                {
                  "$ref": "RootInteraction.json#"
                }
              ]
            }
          },
          "additionalProperties": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to RootInteraction"
              },
              {
                "$ref": "RootInteraction.json#"
              }
            ]
          },
          "propertyNames": {
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          }
        },
        "Failed": {
          "description": "The interactions to run when this interaction fails.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "KnockbackModifiers": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of string to double",
          "additionalProperties": {
            "type": "number"
          }
        },
        "DamageModifiers": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of string to float",
          "additionalProperties": {
            "type": "number"
          }
        },
        "AngledWielding": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/AngledWielding"
            },
            {
              "type": "null"
            }
          ]
        },
        "Next": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to Interaction"
            },
            {
              "$ref": "Interaction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "StaminaCost": {
          "description": "Configuration to define how stamina loss is computed.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/StaminaCost"
            },
            {
              "type": "null"
            }
          ]
        },
        "BlockedEffects": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DamageEffects"
            },
            {
              "type": "null"
            }
          ]
        },
        "BlockedInteractions": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to RootInteraction"
            },
            {
              "$ref": "RootInteraction.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "AngledWielding": {
      "type": "object",
      "title": "AngledWielding",
      "properties": {
        "Angle": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "AngleDistance": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "KnockbackModifiers": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of string to double",
          "additionalProperties": {
            "type": "number"
          }
        },
        "DamageModifiers": {
          "type": [
            "object",
            "null"
          ],
          "title": "Map of string to float",
          "additionalProperties": {
            "type": "number"
          }
        }
      },
      "additionalProperties": false
    },
    "StaminaCost": {
      "type": "object",
      "title": "StaminaCost",
      "properties": {
        "CostType": {
          "type": [
            "string",
            "null"
          ],
          "title": "CostType",
          "description": "Define how the stamina loss is computed. Use MAX_HEALTH_PERCENTAGE to define how many % of the player's max health 1 stamina point is worth. Use DAMAGE define how much damage 1 stamina point is worth. Default value is MAX_HEALTH_PERCENTAGE.",
          "enum": [
            "MaxHealthPercentage",
            "Damage"
          ],
          "default": "MaxHealthPercentage"
        },
        "Value": {
          "description": "The value to define how much a stamina point is worth. When CostType.MAX_HEALTH_PERCENTAGE, a ratio is expected, so for 4% of max health, the value expected here is 0.04. Default value is 0.04f",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "AssetIconProperties": {
      "type": "object",
      "title": "AssetIconProperties",
      "properties": {
        "Scale": {
          "type": "number",
          "default": 0
        },
        "Translation": {
          "type": [
            "array",
            "null"
          ],
          "title": "Vector2d",
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ],
          "minItems": 2,
          "maxItems": 2
        },
        "Rotation": {
          "type": [
            "array",
            "null"
          ],
          "title": "Vector3d",
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ],
          "minItems": 3,
          "maxItems": 3
        }
      },
      "additionalProperties": false
    },
    "ItemTranslationProperties": {
      "type": "object",
      "title": "ItemTranslationProperties",
      "properties": {
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "description": "The translation key for the name of this item."
        },
        "Description": {
          "type": [
            "string",
            "null"
          ],
          "description": "The translation key for the description of this item."
        }
      },
      "additionalProperties": false
    },
    "ItemResourceType": {
      "type": "object",
      "title": "ItemResourceType",
      "properties": {
        "Id": {
          "type": "string"
        },
        "Quantity": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "BlockSelectorToolData": {
      "type": "object",
      "title": "BlockSelectorToolData",
      "properties": {
        "DurabilityLossOnUse": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "BuilderToolData": {
      "type": "object",
      "title": "BuilderToolData",
      "properties": {
        "UI": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "Tools": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/BuilderTool"
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "BuilderTool": {
      "type": "object",
      "title": "BuilderTool",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BuilderTool most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BuilderTool** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "BuilderTool"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Id": {
          "type": [
            "string",
            "null"
          ]
        },
        "IsBrush": {
          "type": "boolean",
          "default": false
        },
        "BrushConfigurationCommand": {
          "type": [
            "string",
            "null"
          ]
        },
        "Args": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/BlockArg"
              },
              {
                "$ref": "common.schema.json#/$defs/BoolArg"
              },
              {
                "$ref": "common.schema.json#/$defs/BrushOriginArg"
              },
              {
                "$ref": "common.schema.json#/$defs/BrushShapeArg"
              },
              {
                "$ref": "common.schema.json#/$defs/FloatArg"
              },
              {
                "$ref": "common.schema.json#/$defs/IntArg"
              },
              {
                "$ref": "common.schema.json#/$defs/MaskArg"
              },
              {
                "$ref": "common.schema.json#/$defs/OptionArg"
              },
              {
                "$ref": "common.schema.json#/$defs/StringArg"
              }
            ]
          }
        },
        "BrushData": {
          "anyOf": [
            {
              "default": {
                "Width": {
                  "Required": true,
                  "Default": 5,
                  "Min": 1,
                  "Max": 100
                },
                "Height": {
                  "Required": true,
                  "Default": 5,
                  "Min": 1,
                  "Max": 100
                },
                "Thickness": {
                  "Required": true,
                  "Default": 0,
                  "Min": 0,
                  "Max": 100
                },
                "Capped": {
                  "Required": true,
                  "Default": false
                },
                "Shape": {
                  "Required": true,
                  "Default": "Cube"
                },
                "Origin": {
                  "Required": true,
                  "Default": "Center"
                },
                "OriginRotation": {
                  "Required": true,
                  "Default": false
                },
                "RotationAxis": {
                  "Required": true,
                  "Default": "None"
                },
                "RotationAngle": {
                  "Required": true,
                  "Default": "None"
                },
                "MirrorAxis": {
                  "Required": true,
                  "Default": "None"
                },
                "Material": {
                  "Required": true,
                  "Default": "Empty",
                  "AllowPattern": true
                },
                "FavoriteMaterials": [],
                "Mask": {
                  "Required": false,
                  "Default": "-"
                },
                "MaskAbove": {
                  "Required": false,
                  "Default": "-"
                },
                "MaskNot": {
                  "Required": false,
                  "Default": "-"
                },
                "MaskBelow": {
                  "Required": false,
                  "Default": "-"
                },
                "MaskAdjacent": {
                  "Required": false,
                  "Default": "-"
                },
                "MaskNeighbor": {
                  "Required": false,
                  "Default": "-"
                },
                "MaskCommands": [],
                "UseMaskCommands": {
                  "Required": true,
                  "Default": false
                },
                "InvertMask": {
                  "Required": true,
                  "Default": false
                }
              },
              "$ref": "common.schema.json#/$defs/BrushData"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BlockArg": {
      "type": "object",
      "title": "BlockArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Block\" to function as this type.",
          "const": "Block"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": [
            "string",
            "null"
          ]
        },
        "AllowPattern": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "BoolArg": {
      "type": "object",
      "title": "BoolArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Bool\" to function as this type.",
          "const": "Bool"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "BrushOriginArg": {
      "type": "object",
      "title": "BrushOriginArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BrushOrigin\" to function as this type.",
          "const": "BrushOrigin"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": [
            "string",
            "null"
          ],
          "title": "BrushOrigin",
          "enum": [
            "Center",
            "Bottom",
            "Top"
          ]
        }
      },
      "additionalProperties": false
    },
    "BrushShapeArg": {
      "type": "object",
      "title": "BrushShapeArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BrushShape\" to function as this type.",
          "const": "BrushShape"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": [
            "string",
            "null"
          ],
          "title": "BrushShape",
          "enum": [
            "Cube",
            "Sphere",
            "Cylinder",
            "Cone",
            "InvertedCone",
            "Pyramid",
            "InvertedPyramid",
            "Dome",
            "InvertedDome",
            "Diamond",
            "Torus"
          ]
        }
      },
      "additionalProperties": false
    },
    "FloatArg": {
      "type": "object",
      "title": "FloatArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Float\" to function as this type.",
          "const": "Float"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": "number",
          "default": 0
        },
        "Min": {
          "type": "number",
          "default": 0
        },
        "Max": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "IntArg": {
      "type": "object",
      "title": "IntArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Int\" to function as this type.",
          "const": "Int"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": "integer"
        },
        "Min": {
          "type": "integer",
          "default": 0
        },
        "Max": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "MaskArg": {
      "type": "object",
      "title": "MaskArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Mask\" to function as this type.",
          "const": "Mask"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "OptionArg": {
      "type": "object",
      "title": "OptionArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Option\" to function as this type.",
          "const": "Option"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": [
            "string",
            "null"
          ]
        },
        "Options": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "StringArg": {
      "type": "object",
      "title": "StringArg",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"String\" to function as this type.",
          "const": "String"
        },
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "BrushData": {
      "type": "object",
      "title": "BrushData",
      "properties": {
        "Width": {
          "description": "The width of the brush shape",
          "default": {
            "Required": true,
            "Default": 5,
            "Min": 1,
            "Max": 100
          },
          "$ref": "common.schema.json#/$defs/IntArg"
        },
        "Height": {
          "description": "The height of the brush shape",
          "default": {
            "Required": true,
            "Default": 5,
            "Min": 1,
            "Max": 100
          },
          "$ref": "common.schema.json#/$defs/IntArg"
        },
        "Thickness": {
          "description": "The number of blocks thick the walls of the brush shape should be",
          "default": {
            "Required": true,
            "Default": 0,
            "Min": 0,
            "Max": 100
          },
          "$ref": "common.schema.json#/$defs/IntArg"
        },
        "Capped": {
          "description": "Controls whether the end(s) of hollow brush shapes are closed or open",
          "default": {
            "Required": true,
            "Default": false
          },
          "$ref": "common.schema.json#/$defs/BoolArg"
        },
        "Shape": {
          "description": "The brush shape",
          "default": {
            "Required": true,
            "Default": "Cube"
          },
          "$ref": "common.schema.json#/$defs/BrushShapeArg"
        },
        "Origin": {
          "description": "The origin of the brush shape",
          "default": {
            "Required": true,
            "Default": "Center"
          },
          "$ref": "common.schema.json#/$defs/BrushOriginArg"
        },
        "OriginRotation": {
          "description": "Toggles the vertical offset for shapes rotated about the x/z axis",
          "default": {
            "Required": true,
            "Default": false
          },
          "$ref": "common.schema.json#/$defs/BoolArg"
        },
        "RotationAxis": {
          "description": "The axis that the brush shape should rotate around",
          "default": {
            "Required": true,
            "Default": "None"
          },
          "$ref": "common.schema.json#/$defs/BrushAxisArg"
        },
        "RotationAngle": {
          "description": "The angle that the brush shape should be rotated by",
          "default": {
            "Required": true,
            "Default": "None"
          },
          "$ref": "common.schema.json#/$defs/BrushRotationArg"
        },
        "MirrorAxis": {
          "description": "The axis that the brush shape should mirror in",
          "default": {
            "Required": true,
            "Default": "None"
          },
          "$ref": "common.schema.json#/$defs/BrushAxisArg"
        },
        "Material": {
          "description": "The material to apply when the brush is used",
          "default": {
            "Required": true,
            "Default": "Empty",
            "AllowPattern": true
          },
          "$ref": "common.schema.json#/$defs/BlockArg"
        },
        "FavoriteMaterials": {
          "type": [
            "array",
            "null"
          ],
          "description": "Materials available for quick selection.\n\nWhen a material is selected from here, it is set on the Material key.",
          "items": {
            "$ref": "common.schema.json#/$defs/BlockArg"
          }
        },
        "Mask": {
          "description": "Limits the selection to blocks matching materials in this mask",
          "anyOf": [
            {
              "default": {
                "Required": false,
                "Default": "-"
              },
              "$ref": "common.schema.json#/$defs/MaskArg"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaskAbove": {
          "description": "Limits the selection to blocks above ones matching materials in this mask",
          "anyOf": [
            {
              "default": {
                "Required": false,
                "Default": "-"
              },
              "$ref": "common.schema.json#/$defs/MaskArg"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaskNot": {
          "description": "Limits the selection to any blocks except ones matching materials in this mask",
          "anyOf": [
            {
              "default": {
                "Required": false,
                "Default": "-"
              },
              "$ref": "common.schema.json#/$defs/MaskArg"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaskBelow": {
          "description": "Limits the selection to blocks below ones matching materials in this mask",
          "anyOf": [
            {
              "default": {
                "Required": false,
                "Default": "-"
              },
              "$ref": "common.schema.json#/$defs/MaskArg"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaskAdjacent": {
          "description": "Limits the selection to blocks horizontally adjacent to ones matching materials in this mask",
          "anyOf": [
            {
              "default": {
                "Required": false,
                "Default": "-"
              },
              "$ref": "common.schema.json#/$defs/MaskArg"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaskNeighbor": {
          "description": "Limits the selection to blocks neighboring (in any direction) ones matching materials in this mask",
          "anyOf": [
            {
              "default": {
                "Required": false,
                "Default": "-"
              },
              "$ref": "common.schema.json#/$defs/MaskArg"
            },
            {
              "type": "null"
            }
          ]
        },
        "MaskCommands": {
          "type": [
            "array",
            "null"
          ],
          "description": "Custom mask commands to apply to the brush, based on /gmask syntax",
          "items": {
            "$ref": "common.schema.json#/$defs/StringArg"
          }
        },
        "UseMaskCommands": {
          "description": "Specifies whether to use the block selector mask values or custom mask commands",
          "anyOf": [
            {
              "default": {
                "Required": true,
                "Default": false
              },
              "$ref": "common.schema.json#/$defs/BoolArg"
            },
            {
              "type": "null"
            }
          ]
        },
        "InvertMask": {
          "description": "When enabled, inverts the entire combined mask result",
          "anyOf": [
            {
              "default": {
                "Required": true,
                "Default": false
              },
              "$ref": "common.schema.json#/$defs/BoolArg"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BrushAxisArg": {
      "type": "object",
      "title": "BrushAxisArg",
      "properties": {
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": "string",
          "title": "BrushAxis",
          "description": "Represents the type of axis to be used when performing transformations on brushes",
          "enum": [
            "None",
            "Auto",
            "X",
            "Y",
            "Z"
          ]
        }
      },
      "additionalProperties": false
    },
    "BrushRotationArg": {
      "type": "object",
      "title": "BrushRotationArg",
      "properties": {
        "Required": {
          "type": "boolean",
          "default": true
        },
        "Default": {
          "type": "string",
          "title": "Rotation",
          "description": "Represents the amount of rotation to be applied to a brush shape",
          "enum": [
            "None",
            "Ninety",
            "OneEighty",
            "TwoSeventy"
          ]
        }
      },
      "additionalProperties": false
    },
    "ItemWeapon": {
      "type": "object",
      "title": "ItemWeapon",
      "properties": {
        "StatModifiers": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "common.schema.json#/$defs/StaticModifier"
            }
          }
        },
        "EntityStatsToClear": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "RenderDualWielded": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "ItemArmor": {
      "type": "object",
      "title": "ItemArmor",
      "properties": {
        "ArmorSlot": {
          "type": "string",
          "title": "ItemArmorSlot",
          "enum": [
            "Head",
            "Chest",
            "Hands",
            "Legs"
          ],
          "default": "Head"
        },
        "DamageResistance": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "common.schema.json#/$defs/StaticModifier"
            }
          }
        },
        "DamageEnhancement": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "common.schema.json#/$defs/StaticModifier"
            }
          }
        },
        "DamageClassEnhancement": {
          "type": "object",
          "title": "Map of DamageClass",
          "properties": {
            "Unknown": {
              "type": "array",
              "items": {
                "$ref": "common.schema.json#/$defs/StaticModifier"
              }
            },
            "Light": {
              "type": "array",
              "items": {
                "$ref": "common.schema.json#/$defs/StaticModifier"
              }
            },
            "Charged": {
              "type": "array",
              "items": {
                "$ref": "common.schema.json#/$defs/StaticModifier"
              }
            },
            "Signature": {
              "type": "array",
              "items": {
                "$ref": "common.schema.json#/$defs/StaticModifier"
              }
            }
          },
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "common.schema.json#/$defs/StaticModifier"
            }
          },
          "propertyNames": {
            "enum": [
              "Unknown",
              "Light",
              "Charged",
              "Signature"
            ]
          }
        },
        "KnockbackResistances": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "base.schema.json#/$defs/NumberOrSpecial"
          }
        },
        "KnockbackEnhancements": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "base.schema.json#/$defs/NumberOrSpecial"
          }
        },
        "Regenerating": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "common.schema.json#/$defs/Regenerating"
            }
          }
        },
        "BaseDamageResistance": {
          "type": "number",
          "default": 0
        },
        "StatModifiers": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "common.schema.json#/$defs/StaticModifier"
            }
          }
        },
        "InteractionModifiers": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "object",
            "additionalProperties": {
              "$ref": "common.schema.json#/$defs/StaticModifier"
            }
          }
        },
        "CosmeticsToHide": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string",
            "title": "Cosmetic",
            "enum": [
              "Haircut",
              "FacialHair",
              "Undertop",
              "Overtop",
              "Pants",
              "Overpants",
              "Shoes",
              "Gloves",
              "Cape",
              "HeadAccessory",
              "FaceAccessory",
              "EarAccessory",
              "Ear"
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "ItemGlider": {
      "type": "object",
      "title": "ItemGlider",
      "properties": {
        "TerminalVelocity": {
          "description": "The maximum speed the player can fall while gliding.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "FallSpeedMultiplier": {
          "description": "The rate at which the fall speed is incremented.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "HorizontalSpeedMultiplier": {
          "description": "The rate at which the horizontal move speed is incremented.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Speed": {
          "description": "The horizontal movement speed of the glider.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "ItemUtility": {
      "type": "object",
      "title": "ItemUtility",
      "properties": {
        "Usable": {
          "type": "boolean",
          "default": false
        },
        "Compatible": {
          "type": "boolean",
          "default": false
        },
        "StatModifiers": {
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "type": "array",
            "items": {
              "$ref": "common.schema.json#/$defs/StaticModifier"
            }
          }
        },
        "EntityStatsToClear": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "PortalKey": {
      "type": "object",
      "title": "PortalKey",
      "properties": {
        "PortalType": {
          "type": "string",
          "description": "The ID of of the PortalType that this key opens."
        },
        "TimeLimitSeconds": {
          "type": "integer",
          "default": -1
        }
      },
      "additionalProperties": false
    },
    "ItemStackContainerConfig": {
      "type": "object",
      "title": "ItemStackContainerConfig",
      "properties": {
        "Capacity": {
          "type": "integer"
        },
        "GlobalFilter": {
          "type": [
            "string",
            "null"
          ],
          "title": "FilterType",
          "enum": [
            "AllowInputOnly",
            "AllowOutputOnly",
            "AllowAll",
            "DenyAll"
          ],
          "default": "AllowAll"
        },
        "ItemTag": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "InteractionConfiguration": {
      "type": "object",
      "title": "InteractionConfiguration",
      "properties": {
        "DisplayOutlines": {
          "type": "boolean",
          "default": true
        },
        "DebugOutlines": {
          "type": "boolean",
          "default": false
        },
        "UseDistance": {
          "type": "object",
          "title": "Map of GameMode",
          "properties": {
            "Adventure": {
              "$ref": "base.schema.json#/$defs/NumberOrSpecial"
            },
            "Creative": {
              "$ref": "base.schema.json#/$defs/NumberOrSpecial"
            }
          },
          "additionalProperties": {
            "$ref": "base.schema.json#/$defs/NumberOrSpecial"
          },
          "propertyNames": {
            "enum": [
              "Adventure",
              "Creative"
            ]
          }
        },
        "AllEntities": {
          "type": "boolean",
          "default": false
        },
        "Priorities": {
          "type": [
            "object",
            "null"
          ],
          "description": "Configures the priority values for given interaction types on this item when two or more items are equipped.",
          "properties": {
            "Primary": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Secondary": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Ability1": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Ability2": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Ability3": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Use": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Pick": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Pickup": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "CollisionEnter": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "CollisionLeave": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Collision": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "EntityStatEffect": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "SwapTo": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "SwapFrom": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Death": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Wielding": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "ProjectileSpawn": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "ProjectileHit": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "ProjectileMiss": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "ProjectileBounce": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Held": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "HeldOffhand": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Equipped": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "Dodge": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            },
            "GameModeSwap": {
              "type": "object",
              "title": "InteractionPriority",
              "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
              "properties": {
                "Default": {
                  "type": "integer"
                },
                "MainHand": {
                  "type": "integer"
                },
                "OffHand": {
                  "type": "integer"
                }
              },
              "additionalProperties": {
                "type": "integer"
              },
              "propertyNames": {
                "enum": [
                  "Default",
                  "MainHand",
                  "OffHand"
                ]
              }
            }
          },
          "additionalProperties": {
            "type": "object",
            "title": "InteractionPriority",
            "description": "Either an integer (default for all types) or an object with named priorities (e.g., 'MainHand', 'OffHand', 'Default').",
            "properties": {
              "Default": {
                "type": "integer"
              },
              "MainHand": {
                "type": "integer"
              },
              "OffHand": {
                "type": "integer"
              }
            },
            "additionalProperties": {
              "type": "integer"
            },
            "propertyNames": {
              "enum": [
                "Default",
                "MainHand",
                "OffHand"
              ]
            }
          },
          "propertyNames": {
            "enum": [
              "Primary",
              "Secondary",
              "Ability1",
              "Ability2",
              "Ability3",
              "Use",
              "Pick",
              "Pickup",
              "CollisionEnter",
              "CollisionLeave",
              "Collision",
              "EntityStatEffect",
              "SwapTo",
              "SwapFrom",
              "Death",
              "Wielding",
              "ProjectileSpawn",
              "ProjectileHit",
              "ProjectileMiss",
              "ProjectileBounce",
              "Held",
              "HeldOffhand",
              "Equipped",
              "Dodge",
              "GameModeSwap"
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "ItemAppearanceCondition": {
      "type": "object",
      "title": "ItemAppearanceCondition",
      "properties": {
        "Particles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "FirstPersonParticles": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ModelParticle"
          }
        },
        "Model": {
          "type": [
            "string",
            "null"
          ]
        },
        "Texture": {
          "type": [
            "string",
            "null"
          ]
        },
        "ModelVFXId": {
          "type": [
            "string",
            "null"
          ]
        },
        "WorldSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "3D sound to play in the world when applying this condition."
        },
        "LocalSoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "Local sound to play for the owner of this condition."
        },
        "Condition": {
          "type": "array",
          "title": "FloatRange",
          "description": "An array of 2 floats to define when the condition is active. 'Infinite' and '-Infinite' can be used to define bounds.",
          "items": [
            {
              "$ref": "base.schema.json#/$defs/NumberOrSpecial"
            },
            {
              "$ref": "base.schema.json#/$defs/NumberOrSpecial"
            }
          ],
          "minItems": 2,
          "maxItems": 2
        },
        "ConditionValueType": {
          "type": "string",
          "title": "ValueType",
          "description": "Enum to specify if the condition range must be considered as absolute values or percent. Default value is Absolute. When using ValueType.Absolute, '100' matches the max value.",
          "enum": [
            "Percent",
            "Absolute"
          ],
          "default": "Absolute"
        }
      },
      "additionalProperties": false
    },
    "ItemPullbackConfig": {
      "type": "object",
      "title": "ItemPullbackConfig",
      "properties": {
        "LeftOffsetOverride": {
          "type": [
            "array",
            "null"
          ],
          "title": "Vector3d",
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ],
          "minItems": 3,
          "maxItems": 3
        },
        "LeftRotationOverride": {
          "type": [
            "array",
            "null"
          ],
          "title": "Vector3d",
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ],
          "minItems": 3,
          "maxItems": 3
        },
        "RightOffsetOverride": {
          "type": [
            "array",
            "null"
          ],
          "title": "Vector3d",
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ],
          "minItems": 3,
          "maxItems": 3
        },
        "RightRotationOverride": {
          "type": [
            "array",
            "null"
          ],
          "title": "Vector3d",
          "items": [
            {
              "type": "number"
            },
            {
              "type": "number"
            },
            {
              "type": "number"
            }
          ],
          "minItems": 3,
          "maxItems": 3
        }
      },
      "additionalProperties": false
    },
    "ChoiceItemDropContainer": {
      "type": "object",
      "title": "ChoiceItemDropContainer",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Choice\" to function as this type.",
          "const": "Choice"
        },
        "Weight": {
          "type": "number",
          "default": 100
        },
        "Containers": {
          "type": [
            "array",
            "null"
          ],
          "title": "WeightedMap",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/ChoiceItemDropContainer"
              },
              {
                "$ref": "common.schema.json#/$defs/DroplistItemDropContainer"
              },
              {
                "$ref": "common.schema.json#/$defs/EmptyItemDropContainer"
              },
              {
                "$ref": "common.schema.json#/$defs/MultipleItemDropContainer"
              },
              {
                "$ref": "common.schema.json#/$defs/SingleItemDropContainer"
              }
            ]
          }
        },
        "RollsMin": {
          "type": "integer",
          "default": 1
        },
        "RollsMax": {
          "type": "integer",
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "DroplistItemDropContainer": {
      "type": "object",
      "title": "DroplistItemDropContainer",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Droplist\" to function as this type.",
          "const": "Droplist"
        },
        "Weight": {
          "type": "number",
          "default": 100
        },
        "DroplistId": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "EmptyItemDropContainer": {
      "type": "object",
      "title": "EmptyItemDropContainer",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Empty\" to function as this type.",
          "const": "Empty"
        },
        "Weight": {
          "type": "number",
          "default": 100
        }
      },
      "additionalProperties": false
    },
    "MultipleItemDropContainer": {
      "type": "object",
      "title": "MultipleItemDropContainer",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Multiple\" to function as this type.",
          "const": "Multiple"
        },
        "Weight": {
          "type": "number",
          "default": 100
        },
        "MinCount": {
          "type": "integer",
          "default": 1
        },
        "MaxCount": {
          "type": "integer",
          "default": 1
        },
        "Containers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/ChoiceItemDropContainer"
              },
              {
                "$ref": "common.schema.json#/$defs/DroplistItemDropContainer"
              },
              {
                "$ref": "common.schema.json#/$defs/EmptyItemDropContainer"
              },
              {
                "$ref": "common.schema.json#/$defs/MultipleItemDropContainer"
              },
              {
                "$ref": "common.schema.json#/$defs/SingleItemDropContainer"
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "SingleItemDropContainer": {
      "type": "object",
      "title": "SingleItemDropContainer",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Single\" to function as this type.",
          "const": "Single"
        },
        "Weight": {
          "type": "number",
          "default": 100
        },
        "Item": {
          "$ref": "common.schema.json#/$defs/ItemDrop"
        }
      },
      "additionalProperties": false
    },
    "ItemDrop": {
      "type": "object",
      "title": "ItemDrop",
      "properties": {
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Metadata": {
          "type": [
            "object",
            "null"
          ]
        },
        "QuantityMin": {
          "type": "integer",
          "maximum": {
            "$data": "1/QuantityMax"
          },
          "default": 1
        },
        "QuantityMax": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "ItemAnimation": {
      "type": "object",
      "title": "ItemAnimation",
      "properties": {
        "ThirdPerson": {
          "type": [
            "string",
            "null"
          ]
        },
        "ThirdPersonMoving": {
          "type": [
            "string",
            "null"
          ]
        },
        "ThirdPersonFace": {
          "type": [
            "string",
            "null"
          ]
        },
        "FirstPerson": {
          "type": [
            "string",
            "null"
          ]
        },
        "FirstPersonOverride": {
          "type": [
            "string",
            "null"
          ]
        },
        "KeepPreviousFirstPersonAnimation": {
          "type": "boolean",
          "default": false
        },
        "Speed": {
          "type": "number",
          "default": 0
        },
        "BlendingDuration": {
          "type": "number",
          "default": 0.20000000298023224
        },
        "Looping": {
          "type": "boolean",
          "default": false
        },
        "ClipsGeometry": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "WiggleWeights": {
      "type": "object",
      "title": "WiggleWeights",
      "properties": {
        "X": {
          "type": "number",
          "default": 0
        },
        "XDeceleration": {
          "type": "number",
          "default": 0
        },
        "Y": {
          "type": "number",
          "default": 0
        },
        "YDeceleration": {
          "type": "number",
          "default": 0
        },
        "Z": {
          "type": "number",
          "default": 0
        },
        "ZDeceleration": {
          "type": "number",
          "default": 0
        },
        "Roll": {
          "type": "number",
          "default": 0
        },
        "RollDeceleration": {
          "type": "number",
          "default": 0
        },
        "Pitch": {
          "type": "number",
          "default": 0
        },
        "PitchDeceleration": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "CameraSettings": {
      "type": "object",
      "title": "CameraSettings",
      "properties": {
        "PositionOffset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "Yaw": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CameraAxis"
            },
            {
              "type": "null"
            }
          ]
        },
        "Pitch": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/CameraAxis"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "CameraAxis": {
      "type": "object",
      "title": "CameraAxis",
      "properties": {
        "AngleRange": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "TargetNodes": {
          "type": "array",
          "items": {
            "type": "string",
            "title": "CameraNode",
            "enum": [
              "None",
              "Head",
              "LShoulder",
              "RShoulder",
              "Belly"
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "ItemReticleWithDuration": {
      "type": "object",
      "title": "ItemReticleWithDuration",
      "properties": {
        "HideBase": {
          "type": "boolean",
          "description": "Specifies whether the base reticle should be hidden while the configured parts are shown.",
          "default": false
        },
        "Parts": {
          "type": "array",
          "description": "A list of reticle parts that should be displayed for this configuration.",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "Duration": {
          "description": "The duration (in seconds) this reticle configuration should be displayed for.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "ItemReticle": {
      "type": "object",
      "title": "ItemReticle",
      "properties": {
        "HideBase": {
          "type": "boolean",
          "description": "Specifies whether the base reticle should be hidden while the configured parts are shown.",
          "default": false
        },
        "Parts": {
          "type": "array",
          "description": "A list of reticle parts that should be displayed for this configuration.",
          "items": {
            "type": "string"
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "MacroCommandParameter": {
      "type": "object",
      "title": "MacroCommandParameter",
      "properties": {
        "Name": {
          "type": [
            "string",
            "null"
          ]
        },
        "Description": {
          "type": [
            "string",
            "null"
          ]
        },
        "Requirement": {
          "type": [
            "string",
            "null"
          ],
          "title": "ParameterRequirement",
          "enum": [
            "Required",
            "Optional",
            "Default",
            "Flag"
          ]
        },
        "ArgType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ArgumentTypeEnum",
          "enum": [
            "Boolean",
            "Integer",
            "String",
            "Float",
            "Double",
            "Uuid",
            "RelativeDoubleCoord",
            "RelativeIntCoord",
            "RelativeInteger",
            "IntRange",
            "RelativeIntRange",
            "Vector3i",
            "RelativeVector3i",
            "BlockId",
            "WeightedBlockType",
            "BlockPattern",
            "BlockMask",
            "World",
            "RelativeBlockPosition",
            "RelativePosition",
            "Rotation",
            "ModelAsset",
            "WeatherAsset",
            "InteractionAsset",
            "EffectAsset",
            "EnvironmentAsset",
            "ItemAsset",
            "BlockTypeAsset",
            "BlockTypeKey"
          ]
        },
        "DefaultValue": {
          "type": [
            "string",
            "null"
          ]
        },
        "DefaultValueDescription": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "DetailBox": {
      "type": "object",
      "title": "DetailBox",
      "properties": {
        "Offset": {
          "default": {
            "X": 0,
            "Y": 0,
            "Z": 0
          },
          "$ref": "common.schema.json#/$defs/Vector3d"
        },
        "Box": {
          "default": {
            "Min": {
              "X": 0,
              "Y": 0,
              "Z": 0
            },
            "Max": {
              "X": 1,
              "Y": 1,
              "Z": 1
            }
          },
          "$ref": "common.schema.json#/$defs/Box"
        }
      },
      "additionalProperties": false
    },
    "ModelAttachment": {
      "type": "object",
      "title": "ModelAttachment",
      "properties": {
        "Model": {
          "type": [
            "string",
            "null"
          ]
        },
        "Texture": {
          "type": [
            "string",
            "null"
          ]
        },
        "GradientSet": {
          "type": [
            "string",
            "null"
          ],
          "hytaleCosmeticAsset": "GradientSets"
        },
        "GradientId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Weight": {
          "type": "number",
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "TaskSet": {
      "type": "object",
      "title": "TaskSet",
      "properties": {
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "Tasks": {
          "type": "array",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/BountyObjectiveTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/CraftObjectiveTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/GatherObjectiveTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/KillObjectiveTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/KillSpawnBeaconObjectiveTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/KillSpawnMarkerObjectiveTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/ReachLocationTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/TreasureMapObjectiveTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/UseBlockObjectiveTaskAsset"
              },
              {
                "$ref": "common.schema.json#/$defs/UseEntityObjectiveTaskAsset"
              }
            ]
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "BountyObjectiveTaskAsset": {
      "type": "object",
      "title": "BountyObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Bounty\" to function as this type.",
          "const": "Bounty"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "NpcId": {
          "type": [
            "string",
            "null"
          ]
        },
        "WorldLocationCondition": {
          "title": "Type Selector",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/LocationRadiusProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/LookBlocksBelowProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/CheckTagWorldHeightRadiusProvider"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "SoloInventoryCondition": {
      "type": "object",
      "title": "SoloInventoryCondition",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SoloInventory\" to function as this type.",
          "const": "SoloInventory"
        },
        "BlockTagOrItemId": {
          "$ref": "common.schema.json#/$defs/BlockTagOrItemIdField"
        },
        "Quantity": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ConsumeOnCompletion": {
          "type": "boolean",
          "default": false
        },
        "HoldInHand": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "BlockTagOrItemIdField": {
      "type": "object",
      "title": "BlockTagOrItemIdField",
      "properties": {
        "BlockTag": {
          "type": [
            "string",
            "null"
          ]
        },
        "ItemId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "LocationRadiusProvider": {
      "type": "object",
      "title": "LocationRadiusProvider",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LocationRadius\" to function as this type.",
          "const": "LocationRadius"
        },
        "MinRadius": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 10
        },
        "MaxRadius": {
          "type": "integer",
          "minimum": 1,
          "default": 50
        }
      },
      "additionalProperties": false
    },
    "LookBlocksBelowProvider": {
      "type": "object",
      "title": "LookBlocksBelowProvider",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"LookBlocksBelow\" to function as this type.",
          "const": "LookBlocksBelow"
        },
        "BlockTags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1,
          "uniqueItems": true
        },
        "Count": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "MinRange": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "MaxRange": {
          "type": "integer",
          "minimum": 1,
          "default": 10
        }
      },
      "additionalProperties": false
    },
    "CheckTagWorldHeightRadiusProvider": {
      "type": "object",
      "title": "CheckTagWorldHeightRadiusProvider",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TagBlockHeight\" to function as this type.",
          "const": "TagBlockHeight"
        },
        "BlockTags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1,
          "uniqueItems": true
        },
        "Radius": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 5
        }
      },
      "additionalProperties": false
    },
    "CraftObjectiveTaskAsset": {
      "type": "object",
      "title": "CraftObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Craft\" to function as this type.",
          "const": "Craft"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "Count": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "ItemId": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "GatherObjectiveTaskAsset": {
      "type": "object",
      "title": "GatherObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Gather\" to function as this type.",
          "const": "Gather"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "Count": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "BlockTagOrItemId": {
          "$ref": "common.schema.json#/$defs/BlockTagOrItemIdField"
        }
      },
      "additionalProperties": false
    },
    "KillObjectiveTaskAsset": {
      "type": "object",
      "title": "KillObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"KillNPC\" to function as this type.",
          "const": "KillNPC"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "Count": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "NPCGroupId": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "KillSpawnBeaconObjectiveTaskAsset": {
      "type": "object",
      "title": "KillSpawnBeaconObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"KillSpawnBeacon\" to function as this type.",
          "const": "KillSpawnBeacon"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "Count": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "NPCGroupId": {
          "type": "string"
        },
        "SpawnBeacons": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/ObjectiveSpawnBeacon"
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "ObjectiveSpawnBeacon": {
      "type": "object",
      "title": "ObjectiveSpawnBeacon",
      "properties": {
        "SpawnBeaconId": {
          "type": "string"
        },
        "Offset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3d"
            },
            {
              "type": "null"
            }
          ]
        },
        "WorldLocationCondition": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/LocationRadiusProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/LookBlocksBelowProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/CheckTagWorldHeightRadiusProvider"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "KillSpawnMarkerObjectiveTaskAsset": {
      "type": "object",
      "title": "KillSpawnMarkerObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"KillSpawnMarker\" to function as this type.",
          "const": "KillSpawnMarker"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "Count": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "NPCGroupId": {
          "type": "string"
        },
        "Radius": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SpawnMarkerIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "ReachLocationTaskAsset": {
      "type": "object",
      "title": "ReachLocationTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ReachLocation\" to function as this type.",
          "const": "ReachLocation"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "TargetLocation": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "TreasureMapObjectiveTaskAsset": {
      "type": "object",
      "title": "TreasureMapObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"TreasureMap\" to function as this type.",
          "const": "TreasureMap"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "Chests": {
          "type": "array",
          "items": {
            "$ref": "common.schema.json#/$defs/ChestConfig"
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "ChestConfig": {
      "type": "object",
      "title": "ChestConfig",
      "properties": {
        "MinRadius": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "MaxRadius": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "DropList": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to ItemDropList"
            },
            {
              "$ref": "ItemDropList.json#"
            }
          ]
        },
        "WorldLocationCondition": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/LocationRadiusProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/LookBlocksBelowProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/CheckTagWorldHeightRadiusProvider"
            },
            {
              "type": "null"
            }
          ]
        },
        "ChestBlockTypeKey": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "UseBlockObjectiveTaskAsset": {
      "type": "object",
      "title": "UseBlockObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UseBlock\" to function as this type.",
          "const": "UseBlock"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "Count": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "BlockTagOrItemId": {
          "$ref": "common.schema.json#/$defs/BlockTagOrItemIdField"
        }
      },
      "additionalProperties": false
    },
    "UseEntityObjectiveTaskAsset": {
      "type": "object",
      "title": "UseEntityObjectiveTaskAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"UseEntity\" to function as this type.",
          "const": "UseEntity"
        },
        "DescriptionId": {
          "type": [
            "string",
            "null"
          ]
        },
        "TaskConditions": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/SoloInventoryCondition"
              }
            ]
          }
        },
        "MapMarkers": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/Vector3i"
          }
        },
        "Count": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "TaskId": {
          "type": "string"
        },
        "AnimationIdToPlay": {
          "type": [
            "string",
            "null"
          ]
        },
        "Dialog": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/DialogOptions"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "DialogOptions": {
      "type": "object",
      "title": "DialogOptions",
      "properties": {
        "EntityNameKey": {
          "type": "string"
        },
        "DialogKey": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ClearObjectiveItemsCompletionAsset": {
      "type": "object",
      "title": "ClearObjectiveItemsCompletionAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ClearObjectiveItems\" to function as this type.",
          "const": "ClearObjectiveItems"
        }
      },
      "additionalProperties": false
    },
    "GiveItemsCompletionAsset": {
      "type": "object",
      "title": "GiveItemsCompletionAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"GiveItems\" to function as this type.",
          "const": "GiveItems"
        },
        "DropList": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to ItemDropList"
            },
            {
              "$ref": "ItemDropList.json#"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ReputationCompletionAsset": {
      "type": "object",
      "title": "ReputationCompletionAsset",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Reputation\" to function as this type.",
          "const": "Reputation"
        },
        "ReputationGroupId": {
          "type": "string"
        },
        "Amount": {
          "type": "integer",
          "allOf": [
            {
              "not": {
                "type": "integer",
                "const": 0
              }
            }
          ],
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "ObjectiveLocationAreaBox": {
      "type": "object",
      "title": "ObjectiveLocationAreaBox",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Box\" to function as this type.",
          "const": "Box"
        },
        "EntryBox": {
          "default": {
            "Min": {
              "X": -5,
              "Y": -5,
              "Z": -5
            },
            "Max": {
              "X": 5,
              "Y": 5,
              "Z": 5
            }
          },
          "$ref": "common.schema.json#/$defs/Box"
        },
        "ExitBox": {
          "default": {
            "Min": {
              "X": -10,
              "Y": -10,
              "Z": -10
            },
            "Max": {
              "X": 10,
              "Y": 10,
              "Z": 10
            }
          },
          "$ref": "common.schema.json#/$defs/Box"
        }
      },
      "additionalProperties": false
    },
    "ObjectiveLocationAreaRadius": {
      "type": "object",
      "title": "ObjectiveLocationAreaRadius",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Radius\" to function as this type.",
          "const": "Radius"
        },
        "EntryRadius": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 5
        },
        "ExitRadius": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 10
        }
      },
      "additionalProperties": false
    },
    "HourRangeTriggerCondition": {
      "type": "object",
      "title": "HourRangeTriggerCondition",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"HourRange\" to function as this type.",
          "const": "HourRange"
        },
        "MinHour": {
          "type": "integer",
          "default": 0
        },
        "MaxHour": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "WeatherTriggerCondition": {
      "type": "object",
      "title": "WeatherTriggerCondition",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Weather\" to function as this type.",
          "const": "Weather"
        },
        "WeatherIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        }
      },
      "additionalProperties": false
    },
    "RangeVector3f": {
      "type": "object",
      "title": "RangeVector3f",
      "properties": {
        "X": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "Y": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "Z": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "InitialVelocity": {
      "type": "object",
      "title": "InitialVelocity",
      "properties": {
        "Yaw": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "Pitch": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "Speed": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ParticleAttractor": {
      "type": "object",
      "title": "ParticleAttractor",
      "properties": {
        "Position": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "RadialAxis": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "TrailPositionMultiplier": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Radius": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RadialAcceleration": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RadialTangentAcceleration": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "LinearAcceleration": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "RadialImpulse": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RadialTangentImpulse": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "LinearImpulse": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "DampingMultiplier": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "IntersectionHighlight": {
      "type": "object",
      "title": "IntersectionHighlight",
      "properties": {
        "HighlightThreshold": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "HighlightColor": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "UVMotion": {
      "type": "object",
      "title": "UVMotion",
      "properties": {
        "Texture": {
          "type": [
            "string",
            "null"
          ]
        },
        "AddRandomUVOffset": {
          "type": "boolean",
          "default": false
        },
        "SpeedX": {
          "type": "number",
          "minimum": -10,
          "maximum": 10,
          "default": 0
        },
        "SpeedY": {
          "type": "number",
          "minimum": -10,
          "maximum": 10,
          "default": 0
        },
        "Strength": {
          "type": "number",
          "minimum": 0,
          "maximum": 50,
          "default": 0
        },
        "StrengthCurveType": {
          "type": [
            "string",
            "null"
          ],
          "title": "UVMotionCurveType",
          "enum": [
            "Constant",
            "IncreaseLinear",
            "IncreaseQuartIn",
            "IncreaseQuartInOut",
            "IncreaseQuartOut",
            "DecreaseLinear",
            "DecreaseQuartIn",
            "DecreaseQuartInOut",
            "DecreaseQuartOut"
          ],
          "default": "Constant"
        },
        "Scale": {
          "type": "number",
          "minimum": 0,
          "maximum": 10,
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ParticleCollision": {
      "type": "object",
      "title": "ParticleCollision",
      "properties": {
        "BlockType": {
          "type": "string",
          "title": "ParticleCollisionBlockType",
          "enum": [
            "None",
            "Air",
            "Solid",
            "All"
          ],
          "default": "None"
        },
        "Action": {
          "type": "string",
          "title": "ParticleCollisionAction",
          "enum": [
            "Expire",
            "LastFrame",
            "Linger"
          ],
          "default": "Expire"
        },
        "ParticleRotationInfluence": {
          "type": [
            "string",
            "null"
          ],
          "title": "ParticleRotationInfluence",
          "enum": [
            "None",
            "Billboard",
            "BillboardY",
            "BillboardVelocity",
            "Velocity"
          ]
        }
      },
      "additionalProperties": false
    },
    "Particle": {
      "type": "object",
      "title": "Particle",
      "properties": {
        "Texture": {
          "type": "string"
        },
        "FrameSize": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Size"
            },
            {
              "type": "null"
            }
          ]
        },
        "SoftParticles": {
          "type": "string",
          "title": "SoftParticle",
          "enum": [
            "Enable",
            "Disable",
            "Require"
          ],
          "default": "Enable"
        },
        "SoftParticlesFadeFactor": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "UseSpriteBlending": {
          "type": "boolean",
          "default": false
        },
        "Animation": {
          "type": "object",
          "additionalProperties": {
            "$ref": "common.schema.json#/$defs/ParticleAnimationFrame"
          },
          "propertyNames": {
            "description": "A string that contains any integer",
            "pattern": "^[0-9]+$"
          }
        },
        "CollisionAnimationFrame": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ParticleAnimationFrame"
            },
            {
              "type": "null"
            }
          ]
        },
        "UVOption": {
          "type": "string",
          "title": "ParticleUVOption",
          "enum": [
            "None",
            "RandomFlipU",
            "RandomFlipV",
            "RandomFlipUV",
            "FlipU",
            "FlipV",
            "FlipUV"
          ],
          "default": "None"
        },
        "ScaleRatioConstraint": {
          "type": "string",
          "title": "ParticleScaleRatioConstraint",
          "enum": [
            "OneToOne",
            "Preserved",
            "None"
          ],
          "default": "OneToOne"
        },
        "InitialAnimationFrame": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/ParticleAnimationFrame"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Size": {
      "type": "object",
      "title": "Size",
      "properties": {
        "Width": {
          "type": "integer",
          "default": 0
        },
        "Height": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ParticleAnimationFrame": {
      "type": "object",
      "title": "ParticleAnimationFrame",
      "properties": {
        "FrameIndex": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Range"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scale": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/RangeVector2f"
            },
            {
              "type": "null"
            }
          ]
        },
        "Rotation": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/RangeVector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "Color": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "Opacity": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "ParticleSpawnerGroup": {
      "type": "object",
      "title": "ParticleSpawnerGroup",
      "properties": {
        "SpawnerId": {
          "type": [
            "string",
            "null"
          ]
        },
        "PositionOffset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "RotationOffset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Direction"
            },
            {
              "type": "null"
            }
          ]
        },
        "FixedRotation": {
          "type": "boolean",
          "default": false
        },
        "SpawnRate": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "LifeSpan": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "StartDelay": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "WaveDelay": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Rangef"
            },
            {
              "type": "null"
            }
          ]
        },
        "TotalSpawners": {
          "type": "integer",
          "default": 1
        },
        "MaxConcurrent": {
          "type": "integer",
          "default": 0
        },
        "InitialVelocity": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InitialVelocity"
            },
            {
              "type": "null"
            }
          ]
        },
        "EmitOffset": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/RangeVector3f"
            },
            {
              "type": "null"
            }
          ]
        },
        "Attractors": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/ParticleAttractor"
          }
        }
      },
      "additionalProperties": false
    },
    "PortalDescription": {
      "type": "object",
      "title": "PortalDescription",
      "properties": {
        "DisplayName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The translation key for the name of this portal."
        },
        "FlavorText": {
          "type": [
            "string",
            "null"
          ],
          "description": "The translation key for the description of this portal."
        },
        "ThemeColor": {
          "description": "What color do you associate with this portal? May be used in many places.",
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "DescriptionTags": {
          "type": [
            "array",
            "null"
          ],
          "description": "Purely cosmetic list of tags for the UI.",
          "items": {
            "$ref": "common.schema.json#/$defs/PillTag"
          }
        },
        "Objectives": {
          "type": [
            "array",
            "null"
          ],
          "description": "List of translation keys for the objectives in this portal.",
          "items": {
            "type": "string"
          }
        },
        "Tips": {
          "type": [
            "array",
            "null"
          ],
          "description": "List of translation keys for the tips/wisdom offered for this portal.",
          "items": {
            "type": "string"
          }
        },
        "SplashImage": {
          "type": [
            "string",
            "null"
          ],
          "description": "The filename of the splash image for this portal. Your best bet to find the folder is to search for an existing portal's image in assets. Screenshots taken 60 fov."
        }
      },
      "additionalProperties": false
    },
    "PillTag": {
      "type": "object",
      "title": "PillTag",
      "properties": {
        "TranslationKey": {
          "type": [
            "string",
            "null"
          ],
          "description": "The translation key for the text of this tag."
        },
        "Color": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "PortalSpawn": {
      "type": "object",
      "title": "PortalSpawn",
      "properties": {
        "Y": {
          "type": "integer",
          "description": "The Y height where to start looking for X,Z candidate.",
          "default": 0
        },
        "ScanHeight": {
          "type": "integer",
          "description": "How many blocks to scan downwards after picking a X,Y,Z candidate.",
          "default": 16
        },
        "MinRadius": {
          "type": "integer",
          "description": "Picks a random X,Z point around center at [MinRadius]-[MaxRadius] radius to find chunks.",
          "default": 0
        },
        "MaxRadius": {
          "type": "integer",
          "description": "Picks a random X,Z point around center at [MinRadius]-[MaxRadius] radius to find chunks.",
          "default": 0
        },
        "Center": {
          "description": "Picks a random X,Z point around [Center] at Radius radius.",
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0,
                "Z": 0
              },
              "$ref": "common.schema.json#/$defs/Vector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "ChunkDartThrows": {
          "type": "integer",
          "description": "How many attempts at picking a spawn.",
          "default": 20
        },
        "ChecksPerChunk": {
          "type": "integer",
          "description": "For every chunk, how many random location checks are done within the chunk.",
          "default": 5
        }
      },
      "additionalProperties": false
    },
    "PrefabReference": {
      "type": "object",
      "title": "PrefabReference",
      "properties": {
        "RootDirectory": {
          "type": [
            "string",
            "null"
          ],
          "title": "PrefabRootDirectory",
          "enum": [
            "Server",
            "Asset",
            "Worldgen"
          ]
        },
        "Path": {
          "type": [
            "string",
            "null"
          ]
        },
        "Recursive": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "StandardPhysicsConfig": {
      "type": "object",
      "title": "StandardPhysicsConfig",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Standard\" to function as this type.",
          "const": "Standard"
        },
        "Density": {
          "type": "number",
          "default": 700
        },
        "Gravity": {
          "type": "number",
          "default": 0
        },
        "Bounciness": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "default": 0
        },
        "BounceLimit": {
          "type": "number",
          "default": 0.4
        },
        "BounceCount": {
          "type": "integer",
          "default": -1
        },
        "SticksVertically": {
          "type": "boolean",
          "default": false
        },
        "ComputeYaw": {
          "type": "boolean",
          "default": true
        },
        "ComputePitch": {
          "type": "boolean",
          "default": true
        },
        "RotationMode": {
          "type": [
            "string",
            "null"
          ],
          "title": "RotationMode",
          "enum": [
            "None",
            "Velocity",
            "VelocityDamped",
            "VelocityRoll"
          ],
          "default": "VelocityDamped"
        },
        "MoveOutOfSolidSpeed": {
          "type": "number",
          "default": 0
        },
        "TerminalVelocityAir": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "DensityAir": {
          "type": "number",
          "default": 1.2
        },
        "TerminalVelocityWater": {
          "type": "number",
          "exclusiveMinimum": 0,
          "default": 1
        },
        "DensityWater": {
          "type": "number",
          "default": 998
        },
        "HitWaterImpulseLoss": {
          "type": "number",
          "default": 0.2
        },
        "RotationForce": {
          "type": "number",
          "default": 3
        },
        "SpeedRotationFactor": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SwimmingDampingFactor": {
          "type": "number",
          "default": 1
        },
        "AllowRolling": {
          "type": "boolean",
          "default": false
        },
        "RollingFrictionFactor": {
          "type": "number",
          "default": 0.99
        },
        "RollingSpeed": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "ExponentialResponseCurve": {
      "type": "object",
      "title": "ExponentialResponseCurve",
      "description": "An response curve which changes at an exponential rate.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Exponential\" to function as this type.",
          "const": "Exponential"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another ExponentialResponseCurve most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **ExponentialResponseCurve** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ResponseCurve",
            "mapKey": "Type",
            "mapKeyValue": "Exponential"
          }
        },
        "Slope": {
          "type": "number",
          "description": "The slope of the curve.",
          "default": 1
        },
        "Exponent": {
          "type": "number",
          "description": "The exponent used to generate this curve. 1 is linear, 2 results in a quadratic parabola, and 3 in a cubic curve, etc.",
          "default": 1
        },
        "HorizontalShift": {
          "type": "number",
          "description": "The horizontal shift to apply to the curve. This decides how far the curve is shifted left or right along the x axis.",
          "minimum": -1,
          "maximum": 1,
          "default": 0
        },
        "VerticalShift": {
          "type": "number",
          "description": "The vertical shift to apply to the curve. This decides how far the curve is shifted up or down along the y axis.",
          "minimum": -1,
          "maximum": 1,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "LogisticResponseCurve": {
      "type": "object",
      "title": "LogisticResponseCurve",
      "description": "A response curve with a logistic rate of change.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Logistic\" to function as this type.",
          "const": "Logistic"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another LogisticResponseCurve most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **LogisticResponseCurve** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ResponseCurve",
            "mapKey": "Type",
            "mapKeyValue": "Logistic"
          }
        },
        "RateOfChange": {
          "type": "number",
          "description": "The rate of change of the curve - similar to Slope in the exponential curve.",
          "markdownDescription": "The rate of change of the curve - similar to **Slope** in the exponential curve.",
          "default": 1
        },
        "Ceiling": {
          "type": "number",
          "description": "The total height of the curve between its two plateaus. Using a negative value with vertical offsets allows the curve to act as a diminishing factor",
          "default": 1
        },
        "HorizontalShift": {
          "type": "number",
          "description": "The horizontal shift to apply to the curve. This decides how far the curve is shifted left or right along the x axis.",
          "default": 0.5
        },
        "VerticalShift": {
          "type": "number",
          "description": "The vertical shift to apply to the curve. This decides how far the curve is shifted up or down along the y axis.",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SineWaveResponseCurve": {
      "type": "object",
      "title": "SineWaveResponseCurve",
      "description": "A response curve with a sine wave shape.",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"SineWave\" to function as this type.",
          "const": "SineWave"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another SineWaveResponseCurve most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **SineWaveResponseCurve** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ResponseCurve",
            "mapKey": "Type",
            "mapKeyValue": "SineWave"
          }
        },
        "Amplitude": {
          "type": "number",
          "description": "The vertical distance between the horizontal axis and the max/min value of the function.",
          "default": 1
        },
        "Frequency": {
          "type": "number",
          "description": "The frequency of the sine wave's repetition (e.g. set to 1, the full pattern will appear once in the 0-1 range, twice with 2, etc).",
          "default": 0.5
        },
        "HorizontalShift": {
          "type": "number",
          "description": "The horizontal shift to apply to the curve,. This decides how far the curve is shifted left or right along the x axis.",
          "minimum": -1,
          "maximum": 1,
          "default": 0
        },
        "VerticalShift": {
          "type": "number",
          "description": "The vertical shift to apply to the curve. This decides how far the curve is shifted up or down along the y axis.",
          "minimum": -1,
          "maximum": 1,
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "RootInteractionSettings": {
      "type": "object",
      "title": "RootInteractionSettings",
      "properties": {
        "Cooldown": {
          "description": "Cooldowns are used to prevent an interaction from running repeatedly too quickly.\n\nDuring a cooldown attempting to run an interaction with the same cooldown id will fail.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/InteractionCooldown"
            },
            {
              "type": "null"
            }
          ]
        },
        "AllowSkipChainOnClick": {
          "type": "boolean",
          "description": "Whether to skip the whole interaction chain when another click is sent.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "AppendMaskOperation": {
      "type": "object",
      "title": "AppendMaskOperation",
      "description": "Append new masks to the current operation mask",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"appendmask\" to function as this type.",
          "const": "appendmask"
        },
        "AppendMask": {
          "type": [
            "string",
            "null"
          ],
          "description": "Combines the new mask with the current operation mask"
        }
      },
      "additionalProperties": false
    },
    "AppendMaskFromToolArgOperation": {
      "type": "object",
      "title": "AppendMaskFromToolArgOperation",
      "description": "Append a mask from a Block tool arg with configurable filter type and optional additional blocks",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"appendmaskfromtoolarg\" to function as this type.",
          "const": "appendmaskfromtoolarg"
        },
        "ArgName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the Block tool arg to read the material from",
          "default": ""
        },
        "FilterType": {
          "type": [
            "string",
            "null"
          ],
          "title": "FilterType",
          "description": "The type of block filter mask to apply (e.g., TARGET_BLOCK, ABOVE_BLOCK, BELOW_BLOCK)",
          "enum": [
            "TargetBlock",
            "AboveBlock",
            "BelowBlock",
            "AdjacentBlock",
            "NeighborBlock",
            "NorthBlock",
            "EastBlock",
            "SouthBlock",
            "WestBlock",
            "DiagonalXy",
            "DiagonalXz",
            "DiagonalZy",
            "Selection"
          ],
          "default": "TargetBlock"
        },
        "Invert": {
          "type": "boolean",
          "description": "Whether to invert the block filter mask or not",
          "default": false
        },
        "AdditionalBlocks": {
          "type": [
            "string",
            "null"
          ],
          "description": "Additional block names to append to the mask, comma separated (e.g., Rock_Stone,Rock_Granite)"
        }
      },
      "additionalProperties": false
    },
    "BreakpointOperation": {
      "type": "object",
      "title": "BreakpointOperation",
      "description": "Debug breakpoint for scripted brushes",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"breakpoint\" to function as this type.",
          "const": "breakpoint"
        },
        "Label": {
          "type": [
            "string",
            "null"
          ],
          "description": "Identifier for this breakpoint",
          "default": ""
        },
        "PrintMessage": {
          "type": "boolean",
          "description": "Print a message when breakpoint is reached",
          "default": false
        },
        "PrintState": {
          "type": "boolean",
          "description": "Print brush state when breakpoint is reached",
          "default": false
        },
        "EnterStepMode": {
          "type": "boolean",
          "description": "Enter step-through mode (use /sb step to continue)",
          "default": false
        },
        "Condition": {
          "description": "Optional condition - breakpoint only triggers if condition passes",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/BrushConfigIntegerComparison"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "BrushConfigIntegerComparison": {
      "type": "object",
      "title": "BrushConfigIntegerComparison",
      "properties": {
        "DataGettingFlag": {
          "type": [
            "string",
            "null"
          ],
          "title": "DataGettingFlags",
          "enum": [
            "OffsetX",
            "OffsetY",
            "OffsetZ",
            "Height",
            "Width",
            "Density"
          ]
        },
        "IntegerComparisonOperator": {
          "type": [
            "string",
            "null"
          ],
          "title": "IntegerComparisonOperator",
          "enum": [
            "GreaterThan",
            "GreaterThanEqualTo",
            "LessThan",
            "LessThanEqualTo",
            "ModEqualZero",
            "ModNotEqualZero",
            "EqualTo",
            "NotEqualTo"
          ]
        },
        "ValueToCompareTo": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ClearOperationMaskOperation": {
      "type": "object",
      "title": "ClearOperationMaskOperation",
      "description": "Reset the Brush-Config-provided mask to nothing, keeping the brush tool's mask",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"clearoperationmask\" to function as this type.",
          "const": "clearoperationmask"
        }
      },
      "additionalProperties": false
    },
    "DebugBrushOperation": {
      "type": "object",
      "title": "DebugBrushOperation",
      "description": "Debug options for scripted brushes",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"debug\" to function as this type.",
          "const": "debug"
        },
        "PrintOperations": {
          "type": "boolean",
          "description": "Prints the index and name of each operation as it executes",
          "default": false
        },
        "StepThrough": {
          "type": "boolean",
          "description": "Enables manual step-through mode (pause after each operation)",
          "default": false
        },
        "EnableBreakpoints": {
          "type": "boolean",
          "description": "Master toggle for breakpoint operations",
          "default": false
        },
        "OutputTarget": {
          "type": [
            "string",
            "null"
          ],
          "title": "DebugOutputTarget",
          "description": "Where debug messages are sent (Chat, Console, or Both)",
          "enum": [
            "Chat",
            "Console",
            "Both"
          ],
          "default": "Chat"
        },
        "BreakOnError": {
          "type": "boolean",
          "description": "Pause on error instead of terminating execution",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "DeleteOperation": {
      "type": "object",
      "title": "DeleteOperation",
      "description": "Remove all blocks and fluids in the area",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"delete\" to function as this type.",
          "const": "delete"
        }
      },
      "additionalProperties": false
    },
    "SetDensity": {
      "type": "object",
      "title": "SetDensity",
      "description": "Sets the random chance that any given block being set will actually get set, otherwise getting cancelled. Ex: a value of 30 is a 30% chance blocks will appear with a set operation.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"density\" to function as this type.",
          "const": "density"
        },
        "Density": {
          "type": "integer",
          "description": "Changes the likelyhood that a given block will be processed",
          "default": 100
        }
      },
      "additionalProperties": false
    },
    "DimensionsOperation": {
      "type": "object",
      "title": "DimensionsOperation",
      "description": "Set, add, or subtract from the dimensions of the brush area",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"dimensions\" to function as this type.",
          "const": "dimensions"
        },
        "Width": {
          "description": "Sets the width of the brush to the specified amount, optionally relative to the existing amount when using prefixing with tilde",
          "anyOf": [
            {
              "default": {
                "Value": 3,
                "Relative": false
              },
              "$ref": "common.schema.json#/$defs/RelativeInteger"
            },
            {
              "type": "null"
            }
          ]
        },
        "Height": {
          "description": "Sets the height of the brush to the specified amount, optionally relative to the existing amount when using prefixing with tilde",
          "anyOf": [
            {
              "default": {
                "Value": 3,
                "Relative": false
              },
              "$ref": "common.schema.json#/$defs/RelativeInteger"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "RelativeInteger": {
      "type": "object",
      "title": "RelativeInteger",
      "properties": {
        "Value": {
          "type": "integer",
          "default": 0
        },
        "Relative": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "DisableHoldInteractionOperation": {
      "type": "object",
      "title": "DisableHoldInteractionOperation",
      "description": "Disables the ability of the brush to activate multiple times on holding a button",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"disableonhold\" to function as this type.",
          "const": "disableonhold"
        }
      },
      "additionalProperties": false
    },
    "EchoOperation": {
      "type": "object",
      "title": "EchoOperation",
      "description": "Print some text to chat",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"echo\" to function as this type.",
          "const": "echo"
        },
        "Message": {
          "type": [
            "string",
            "null"
          ],
          "description": "A message to print to chat when this operation is ran",
          "default": "Default message"
        }
      },
      "additionalProperties": false
    },
    "EchoOnceOperation": {
      "type": "object",
      "title": "EchoOnceOperation",
      "description": "Print text to chat only on the first execution after brush load",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"echoonce\" to function as this type.",
          "const": "echoonce"
        },
        "Message": {
          "type": [
            "string",
            "null"
          ],
          "description": "A message to print to chat when this operation is first executed",
          "default": "Default message"
        }
      },
      "additionalProperties": false
    },
    "ErodeOperation": {
      "type": "object",
      "title": "ErodeOperation",
      "description": "Erodes blocks following a preset",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"erode\" to function as this type.",
          "const": "erode"
        },
        "ErodePreset": {
          "type": [
            "string",
            "null"
          ],
          "title": "ErodePreset",
          "description": "An erosion preset to use with the operation",
          "enum": [
            "Default",
            "Melt",
            "Fill",
            "Smooth",
            "Lift",
            "FloatClean"
          ],
          "default": "Default"
        }
      },
      "additionalProperties": false
    },
    "ExitOperation": {
      "type": "object",
      "title": "ExitOperation",
      "description": "Exit the execution of the stack",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"exit\" to function as this type.",
          "const": "exit"
        }
      },
      "additionalProperties": false
    },
    "HeightmapLayerOperation": {
      "type": "object",
      "title": "HeightmapLayerOperation",
      "description": "Replace blocks according to the specified layers in terms of their depth from the tallest block in its column",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"heightmaplayer\" to function as this type.",
          "const": "heightmaplayer"
        },
        "Layers": {
          "type": [
            "array",
            "null"
          ],
          "description": "The layers to set",
          "items": {
            "$ref": "common.schema.json#/$defs/LayerEntryCodec"
          }
        }
      },
      "additionalProperties": false
    },
    "LayerEntryCodec": {
      "type": "object",
      "title": "LayerEntryCodec",
      "properties": {
        "Left": {
          "type": "integer"
        },
        "Right": {
          "type": "string"
        },
        "UseToolArg": {
          "type": "boolean",
          "default": false
        },
        "Skip": {
          "type": "boolean",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "HistoryMaskOperation": {
      "type": "object",
      "title": "HistoryMaskOperation",
      "description": "Sets the history mask, allowing you to mask to previously edited or non-edited blocks",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"historymask\" to function as this type.",
          "const": "historymask"
        },
        "HistoryMask": {
          "type": [
            "string",
            "null"
          ],
          "title": "HistoryMask",
          "description": "Changes the mask to block history, enable only history, or ignore history",
          "enum": [
            "None",
            "Only",
            "Not"
          ],
          "default": "None"
        }
      },
      "additionalProperties": false
    },
    "IgnoreExistingBrushDataOperation": {
      "type": "object",
      "title": "IgnoreExistingBrushDataOperation",
      "description": "Ignores any existing brush settings specified on the tool",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ignorebrushsettings\" to function as this type.",
          "const": "ignorebrushsettings"
        }
      },
      "additionalProperties": false
    },
    "JumpToIndexOperation": {
      "type": "object",
      "title": "JumpToIndexOperation",
      "description": "Jump the stack execution to the point in the stack of the given saved index name",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"jump\" to function as this type.",
          "const": "jump"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The labeled index to jump to, previous or future",
          "default": "Undefined"
        }
      },
      "additionalProperties": false
    },
    "JumpIfBlockTypeOperation": {
      "type": "object",
      "title": "JumpIfBlockTypeOperation",
      "description": "Jump the execution of the stack based on a block type comparison",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"jumpifblocktype\" to function as this type.",
          "const": "jumpifblocktype"
        },
        "Mask": {
          "type": [
            "string",
            "null"
          ],
          "description": "The block mask for the comparison."
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The labeled index to jump to, previous or future",
          "default": "Undefined"
        }
      },
      "additionalProperties": false
    },
    "JumpIfClickType": {
      "type": "object",
      "title": "JumpIfClickType",
      "description": "Jump the execution of the stack based on the click type",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"jumpifclicktype\" to function as this type.",
          "const": "jumpifclicktype"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The labeled index to jump to, previous or future",
          "default": "Undefined"
        },
        "ClickType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ClickType",
          "description": "The click type (left or right) to compare with to jump",
          "enum": [
            "Left",
            "Right"
          ],
          "default": "Left"
        }
      },
      "additionalProperties": false
    },
    "JumpIfCompareOperation": {
      "type": "object",
      "title": "JumpIfCompareOperation",
      "description": "Jump stack execution to a stored index operation based on a specified conditional using the brush config data",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"jumpifcompare\" to function as this type.",
          "const": "jumpifcompare"
        },
        "Comparisons": {
          "type": [
            "array",
            "null"
          ],
          "description": "The comparison(s) that will be executed using AND between them to see if you should jump or not",
          "items": {
            "$ref": "common.schema.json#/$defs/BrushConfigIntegerComparison"
          }
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The labeled index to jump to, previous or future",
          "default": "Undefined"
        }
      },
      "additionalProperties": false
    },
    "JumpIfStringMatchOperation": {
      "type": "object",
      "title": "JumpIfStringMatchOperation",
      "description": "Jump the execution of the stack to the stored point if a string matches, useful for macro commands.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"jumpifequal\" to function as this type.",
          "const": "jumpifequal"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The labeled index to jump to, previous or future",
          "default": "Undefined"
        },
        "LeftSideOfStatement": {
          "type": [
            "string",
            "null"
          ],
          "description": "The left side of the statement for checking case-insensitive equals",
          "default": "Undefined"
        },
        "RightSideOfStatement": {
          "type": [
            "string",
            "null"
          ],
          "description": "The right side of the statement for checking case-insensitive equals",
          "default": "Undefined"
        }
      },
      "additionalProperties": false
    },
    "JumpIfToolArgOperation": {
      "type": "object",
      "title": "JumpIfToolArgOperation",
      "description": "Jump stack execution based on a builder tool argument comparison (supports checkbox/bool and dropdown/option types)",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"jumpiftoolarg\" to function as this type.",
          "const": "jumpiftoolarg"
        },
        "ArgName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the tool arg to compare",
          "default": ""
        },
        "ComparisonType": {
          "type": [
            "string",
            "null"
          ],
          "title": "ComparisonType",
          "description": "The type of comparison to perform",
          "enum": [
            "Equals",
            "NotEquals",
            "Contains"
          ],
          "default": "Equals"
        },
        "ComparisonValue": {
          "type": [
            "string",
            "null"
          ],
          "description": "The value to compare against (for boolean: 'true' or 'false', for string: the exact string or dropdown option)",
          "default": ""
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The labeled index to jump to, previous or future",
          "default": "Undefined"
        }
      },
      "additionalProperties": false
    },
    "JumpToRandomIndex": {
      "type": "object",
      "title": "JumpToRandomIndex",
      "description": "Jump the stack execution to a random location in the stack using the specified weights and saved index names",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"jumprandom\" to function as this type.",
          "const": "jumprandom"
        },
        "WeightedListOfIndexNames": {
          "type": [
            "array",
            "null"
          ],
          "description": "A weighted list of weights and their corresponding index names",
          "items": {
            "$ref": "common.schema.json#/$defs/IntegerStringPair"
          }
        }
      },
      "additionalProperties": false
    },
    "IntegerStringPair": {
      "type": "object",
      "title": "IntegerStringPair",
      "properties": {
        "Left": {
          "type": "integer"
        },
        "Right": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "LayerOperation": {
      "type": "object",
      "title": "LayerOperation",
      "description": "Replace blocks according to the specified layers in terms of their depth from the nearest air block",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"layer\" to function as this type.",
          "const": "layer"
        },
        "Layers": {
          "type": [
            "array",
            "null"
          ],
          "description": "The layers to set",
          "items": {
            "$ref": "common.schema.json#/$defs/LayerEntryCodec"
          }
        }
      },
      "additionalProperties": false
    },
    "LiftOperation": {
      "type": "object",
      "title": "LiftOperation",
      "description": "Lift all blocks up by one (duplicating the block) that are touching air, preserving the material",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"lift\" to function as this type.",
          "const": "lift"
        }
      },
      "additionalProperties": false
    },
    "LoadBrushConfigOperation": {
      "type": "object",
      "title": "LoadBrushConfigOperation",
      "description": "Restore a saved brush config snapshot",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"loadbrushconfig\" to function as this type.",
          "const": "loadbrushconfig"
        },
        "StoredName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name to store the snapshot of this brush config under",
          "default": "Undefined"
        },
        "ParametersToLoad": {
          "type": [
            "array",
            "null"
          ],
          "description": "A list of the different parameters to load from the stored config",
          "items": {
            "type": "string",
            "title": "DataSettingFlags",
            "enum": [
              "Offset",
              "Shape",
              "Dimensions",
              "Thickness",
              "Capped",
              "Pattern",
              "Density",
              "BrushMask",
              "OperationMask",
              "HistoryMask"
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "LoadIntFromToolArgOperation": {
      "type": "object",
      "title": "LoadIntFromToolArgOperation",
      "description": "Load an integer from an Int tool arg and apply it to a brush config field",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"loadint\" to function as this type.",
          "const": "loadint"
        },
        "ArgName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the Int tool arg to load the value from",
          "default": ""
        },
        "TargetField": {
          "type": [
            "string",
            "null"
          ],
          "title": "TargetField",
          "description": "The brush config field to set (Width, Height, Density, Thickness, OffsetX, OffsetY, OffsetZ)",
          "enum": [
            "None",
            "Width",
            "Height",
            "Density",
            "Thickness",
            "OffsetX",
            "OffsetY",
            "OffsetZ"
          ],
          "default": "Width"
        },
        "Relative": {
          "type": "boolean",
          "description": "When true, adds the loaded value to the current field value instead of replacing it",
          "default": false
        },
        "Negate": {
          "type": "boolean",
          "description": "When true, turns the sign of the value to negative",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "LoadLoopFromToolArgOperation": {
      "type": "object",
      "title": "LoadLoopFromToolArgOperation",
      "description": "Loop the execution of instructions a set amount of times",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"loadloop\" to function as this type.",
          "const": "loadloop"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the previously stored index to begin the loop at. Note: This can only be an index previous to the current.",
          "default": "Undefined"
        },
        "ArgName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The amount of additional times to repeat the loop after the initial, normal execution",
          "default": ""
        }
      },
      "additionalProperties": false
    },
    "LoadMaterialFromToolArgOperation": {
      "type": "object",
      "title": "LoadMaterialFromToolArgOperation",
      "description": "Load a block pattern from a Block tool arg and set it as the brush material",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"loadmaterial\" to function as this type.",
          "const": "loadmaterial"
        },
        "ArgName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the Block tool arg to load the material pattern from",
          "default": ""
        }
      },
      "additionalProperties": false
    },
    "LoadOperationsFromAssetOperation": {
      "type": "object",
      "title": "LoadOperationsFromAssetOperation",
      "description": "Load and inline operations from another ScriptedBrushAsset",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"loadoperationsfromasset\" to function as this type.",
          "const": "loadoperationsfromasset"
        },
        "AssetId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The ID of the ScriptedBrushAsset to load operations from",
          "default": ""
        }
      },
      "additionalProperties": false
    },
    "LoopOperation": {
      "type": "object",
      "title": "LoopOperation",
      "description": "Loop the execution of instructions a set amount of times",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"loop\" to function as this type.",
          "const": "loop"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the previously stored index to begin the loop at. Note: This can only be an index previous to the current.",
          "default": "Undefined"
        },
        "AdditionalRepetitions": {
          "type": "integer",
          "description": "The amount of additional times to repeat the loop after the initial, normal execution",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "CircleOffsetAndLoopOperation": {
      "type": "object",
      "title": "CircleOffsetAndLoopOperation",
      "description": "Loops specified instructions and changes the offset after each loop in order to execute around a circle",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"loopcircle\" to function as this type.",
          "const": "loopcircle"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the previously stored index to begin the loop at. Note: This can only be an index previous to the current.",
          "default": "Undefined"
        },
        "NumberOfCirclePoints": {
          "type": "integer",
          "description": "The amount of equidistant points on the circle to loop at",
          "default": 3
        },
        "CircleRadius": {
          "type": "integer",
          "description": "The radius of the circle",
          "default": 5
        },
        "FlipDirection": {
          "type": "boolean",
          "description": "Whether to invert the direction of the circle. Useful for non-zero offset modifiers.",
          "default": false
        },
        "RotateDirection": {
          "type": "boolean",
          "description": "Whether to invert the direction of the circle. Useful for non-zero offset modifiers.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "CircleOffsetFromArgOperation": {
      "type": "object",
      "title": "CircleOffsetFromArgOperation",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"loopcirclefromarg\" to function as this type.",
          "const": "loopcirclefromarg"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the previously stored index to begin the loop at. Note: This can only be an index previous to the current.",
          "default": "Undefined"
        },
        "NumberCirclePointsArg": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the Int tool arg to load the value from",
          "default": ""
        },
        "CircleRadiusArg": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the Int tool arg to load the value from",
          "default": ""
        },
        "FlipDirection": {
          "type": "boolean",
          "description": "Whether to invert the direction of the circle. Useful for non-zero offset modifiers.",
          "default": false
        },
        "RotateDirection": {
          "type": "boolean",
          "description": "Whether to invert the direction of the circle. Useful for non-zero offset modifiers.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "LoopRandomOperation": {
      "type": "object",
      "title": "LoopRandomOperation",
      "description": "Loop the execution of instructions a random amount of times",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"looprandom\" to function as this type.",
          "const": "looprandom"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the previously stored index to begin the loop at. Note: This can only be an index previous to the current.",
          "default": "Undefined"
        },
        "RangeOfAdditionalRepetitions": {
          "description": "The minimum and maximum of a range, randomly choosing the amount of additional times to repeat the loop after the initial, normal execution",
          "anyOf": [
            {
              "default": {
                "Left": 1,
                "Right": 1
              },
              "$ref": "common.schema.json#/$defs/IntegerPair"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "IntegerPair": {
      "type": "object",
      "title": "IntegerPair",
      "properties": {
        "Left": {
          "type": "integer"
        },
        "Right": {
          "type": "integer"
        }
      },
      "additionalProperties": false
    },
    "MaskOperation": {
      "type": "object",
      "title": "MaskOperation",
      "description": "Sets the operation mask to only modify blocks that match the mask",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"mask\" to function as this type.",
          "const": "mask"
        },
        "Mask": {
          "type": [
            "string",
            "null"
          ],
          "description": "Sets the operation mask"
        }
      },
      "additionalProperties": false
    },
    "MaterialOperation": {
      "type": "object",
      "title": "MaterialOperation",
      "description": "Change the brush's material",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"material\" to function as this type.",
          "const": "material"
        },
        "BlockType": {
          "type": [
            "string",
            "null"
          ],
          "description": "A single material to set the block type to. You can also use Block Pattern operation to set a pattern of blocks",
          "default": "Rock_Stone"
        }
      },
      "additionalProperties": false
    },
    "MeltOperation": {
      "type": "object",
      "title": "MeltOperation",
      "description": "Remove the top layer of blocks in the brush editing area",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"melt\" to function as this type.",
          "const": "melt"
        }
      },
      "additionalProperties": false
    },
    "OffsetOperation": {
      "type": "object",
      "title": "OffsetOperation",
      "description": "Offset the brush location by a specified amount from the clicked origin",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"offset\" to function as this type.",
          "const": "offset"
        },
        "Offset": {
          "description": "Sets the offset in 3 dimensions, each value is optionally relative by prefixing it with a tilde",
          "anyOf": [
            {
              "default": {
                "X": {
                  "Value": 0,
                  "Relative": false
                },
                "Y": {
                  "Value": 0,
                  "Relative": false
                },
                "Z": {
                  "Value": 0,
                  "Relative": false
                }
              },
              "$ref": "common.schema.json#/$defs/RelativeVector3i"
            },
            {
              "type": "null"
            }
          ]
        },
        "TargetField": {
          "type": [
            "string",
            "null"
          ],
          "title": "TargetField",
          "description": "The brush config field to set (Width, Height, Density, Thickness, OffsetX, OffsetY, OffsetZ)",
          "enum": [
            "None",
            "Width",
            "Height",
            "Density",
            "Thickness",
            "OffsetX",
            "OffsetY",
            "OffsetZ"
          ],
          "default": "None"
        },
        "Negate": {
          "type": "boolean",
          "description": "Whether to invert the sign of the relative field",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "RelativeVector3i": {
      "type": "object",
      "title": "RelativeVector3i",
      "properties": {
        "X": {
          "$ref": "common.schema.json#/$defs/RelativeInteger"
        },
        "Y": {
          "$ref": "common.schema.json#/$defs/RelativeInteger"
        },
        "Z": {
          "$ref": "common.schema.json#/$defs/RelativeInteger"
        }
      },
      "additionalProperties": false
    },
    "PastePrefabOperation": {
      "type": "object",
      "title": "PastePrefabOperation",
      "description": "Paste a prefab at the origin+offset point",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"pasteprefab\" to function as this type.",
          "const": "pasteprefab"
        },
        "PrefabListAssetName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of a PrefabList asset"
        }
      },
      "additionalProperties": false
    },
    "BlockPatternOperation": {
      "type": "object",
      "title": "BlockPatternOperation",
      "description": "Change the material of the brush to a pattern of blocks",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"pattern\" to function as this type.",
          "const": "pattern"
        },
        "BlockPattern": {
          "type": [
            "string",
            "null"
          ],
          "description": "The pattern of blocks to use in your set"
        }
      },
      "additionalProperties": false
    },
    "PersistentDataOperation": {
      "type": "object",
      "title": "PersistentDataOperation",
      "description": "Store and operate on data that sticks around between executions",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"persistentdata\" to function as this type.",
          "const": "persistentdata"
        },
        "StoredName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the variable to modify",
          "default": "Undefined"
        },
        "Operation": {
          "type": [
            "string",
            "null"
          ],
          "title": "IntegerOperation",
          "description": "The operation to perform on the variable using the modifier",
          "enum": [
            "Add",
            "Subtract",
            "Multiply",
            "Divide",
            "Modulus",
            "Set"
          ],
          "default": "Set"
        },
        "Modifier": {
          "type": "integer",
          "description": "The value to modify the variable by",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "RandomizeDimensionsOperation": {
      "type": "object",
      "title": "RandomizeDimensionsOperation",
      "description": "Randomize the dimensions of the brush area",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"randomdimensions\" to function as this type.",
          "const": "randomdimensions"
        },
        "WidthRange": {
          "description": "The range of values for the width, optionally relative using tilde",
          "anyOf": [
            {
              "default": {
                "Min": {
                  "Value": 1,
                  "Relative": false
                },
                "Max": {
                  "Value": 1,
                  "Relative": false
                }
              },
              "$ref": "common.schema.json#/$defs/RelativeIntegerRange"
            },
            {
              "type": "null"
            }
          ]
        },
        "HeightRange": {
          "description": "The range of values for the height, optionally relative using tilde",
          "anyOf": [
            {
              "default": {
                "Min": {
                  "Value": 1,
                  "Relative": false
                },
                "Max": {
                  "Value": 1,
                  "Relative": false
                }
              },
              "$ref": "common.schema.json#/$defs/RelativeIntegerRange"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "RelativeIntegerRange": {
      "type": "object",
      "title": "RelativeIntegerRange",
      "properties": {
        "Min": {
          "$ref": "common.schema.json#/$defs/RelativeInteger"
        },
        "Max": {
          "$ref": "common.schema.json#/$defs/RelativeInteger"
        }
      },
      "additionalProperties": false
    },
    "RandomOffsetOperation": {
      "type": "object",
      "title": "RandomOffsetOperation",
      "description": "Randomly offset the brush location from the clicked origin",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"randomoffset\" to function as this type.",
          "const": "randomoffset"
        },
        "XOffsetRange": {
          "description": "The range of allowed values for the X offset",
          "anyOf": [
            {
              "default": {
                "Min": {
                  "Value": 1,
                  "Relative": false
                },
                "Max": {
                  "Value": 1,
                  "Relative": false
                }
              },
              "$ref": "common.schema.json#/$defs/RelativeIntegerRange"
            },
            {
              "type": "null"
            }
          ]
        },
        "YOffsetRange": {
          "description": "The range of allowed values for the Z offset",
          "anyOf": [
            {
              "default": {
                "Min": {
                  "Value": 1,
                  "Relative": false
                },
                "Max": {
                  "Value": 1,
                  "Relative": false
                }
              },
              "$ref": "common.schema.json#/$defs/RelativeIntegerRange"
            },
            {
              "type": "null"
            }
          ]
        },
        "ZOffsetRange": {
          "description": "The range of allowed values for the Y offset",
          "anyOf": [
            {
              "default": {
                "Min": {
                  "Value": 1,
                  "Relative": false
                },
                "Max": {
                  "Value": 1,
                  "Relative": false
                }
              },
              "$ref": "common.schema.json#/$defs/RelativeIntegerRange"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ReplaceOperation": {
      "type": "object",
      "title": "ReplaceOperation",
      "description": "Replace one kind of block with another pattern of blocks within the current brush editing area",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"replace\" to function as this type.",
          "const": "replace"
        },
        "FromBlockType": {
          "type": [
            "string",
            "null"
          ],
          "description": "The block type to get replaced",
          "default": "Rock_Stone"
        },
        "ToBlockPattern": {
          "type": [
            "string",
            "null"
          ],
          "description": "The pattern of blocks set to"
        }
      },
      "additionalProperties": false
    },
    "RunCommandOperation": {
      "type": "object",
      "title": "RunCommandOperation",
      "description": "Runs a command, see help for argument replacements",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"runcommand\" to function as this type.",
          "const": "runcommand"
        },
        "CommandToRun": {
          "type": [
            "string",
            "null"
          ],
          "description": "Runs a command, substituting the strings... \n'{x}', '{y}', and '{z}' for the origin coordinates\n'{radius}' with width/2, '{width}' with width, and '{height}' with height\n'{var:<persistent variable name>} with the value of the persistent variable'",
          "default": ""
        }
      },
      "additionalProperties": false
    },
    "SaveBrushConfigOperation": {
      "type": "object",
      "title": "SaveBrushConfigOperation",
      "description": "Save a snapshot of the current brush config in order to restore it later",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"savebrushconfig\" to function as this type.",
          "const": "savebrushconfig"
        },
        "StoredName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name to store the snapshot of this brush config under",
          "default": "Undefined"
        }
      },
      "additionalProperties": false
    },
    "SaveIndexOperation": {
      "type": "object",
      "title": "SaveIndexOperation",
      "description": "Mark this spot in the stack in order to loop or jump to it",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"saveindex\" to function as this type.",
          "const": "saveindex"
        },
        "StoredIndexName": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name to store the current execution index at",
          "default": "Undefined"
        }
      },
      "additionalProperties": false
    },
    "SetOperation": {
      "type": "object",
      "title": "SetOperation",
      "description": "Runs a 'set' operation using the parameters of the brush configuration. Supports both blocks and fluids - if the pattern contains fluid items, it sets the fluid layer instead.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"set\" to function as this type.",
          "const": "set"
        }
      },
      "additionalProperties": false
    },
    "ShapeOperation": {
      "type": "object",
      "title": "ShapeOperation",
      "description": "Changes the shape of the brush editing area",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"shape\" to function as this type.",
          "const": "shape"
        },
        "Shape": {
          "type": [
            "string",
            "null"
          ],
          "title": "BrushShape",
          "description": "Changes the brush shape",
          "enum": [
            "Cube",
            "Sphere",
            "Cylinder",
            "Cone",
            "InvertedCone",
            "Pyramid",
            "InvertedPyramid",
            "Dome",
            "InvertedDome",
            "Diamond",
            "Torus"
          ],
          "default": "Cube"
        }
      },
      "additionalProperties": false
    },
    "SmoothOperation": {
      "type": "object",
      "title": "SmoothOperation",
      "description": "Smooths the blocks within the brush area as to make the area more natural looking",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"smooth\" to function as this type.",
          "const": "smooth"
        },
        "SmoothStrength": {
          "type": "integer",
          "description": "The strength of smoothing",
          "default": 2
        }
      },
      "additionalProperties": false
    },
    "UseBrushMaskOperation": {
      "type": "object",
      "title": "UseBrushMaskOperation",
      "description": "Enable the brush tool's mask (the mask placed on the tool)",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"usebrushmask\" to function as this type.",
          "const": "usebrushmask"
        },
        "UseBrushMask": {
          "type": "boolean",
          "description": "Enables or disables the brush's mask",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "UseOperationMaskOperation": {
      "type": "object",
      "title": "UseOperationMaskOperation",
      "description": "Enable or disable the use of the operation mask",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"useoperationmask\" to function as this type.",
          "const": "useoperationmask"
        },
        "UseOperationMask": {
          "type": "boolean",
          "description": "Enables or disables the operation mask",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "ShopElement": {
      "type": "object",
      "title": "ShopElement",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"ShopElement\" to function as this type.",
          "const": "ShopElement"
        },
        "DisplayNameKey": {
          "type": [
            "string",
            "null"
          ],
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "DescriptionKey": {
          "type": [
            "string",
            "null"
          ],
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "Interactions": {
          "type": "array",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/GiveItemInteraction"
              },
              {
                "$ref": "common.schema.json#/$defs/StartObjectiveInteraction@1"
              }
            ]
          },
          "minItems": 1
        },
        "Requirements": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/CanStartObjectiveRequirement"
              },
              {
                "$ref": "common.schema.json#/$defs/ReputationRequirement"
              }
            ]
          }
        },
        "Cost": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "Icon": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "GiveItemInteraction": {
      "type": "object",
      "title": "GiveItemInteraction",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"GiveItem\" to function as this type.",
          "const": "GiveItem"
        },
        "ItemId": {
          "type": "string"
        },
        "Quantity": {
          "type": "integer",
          "minimum": 1,
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "StartObjectiveInteraction@1": {
      "type": "object",
      "title": "StartObjectiveInteraction",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"StartObjective\" to function as this type.",
          "const": "StartObjective"
        },
        "ObjectiveId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "CanStartObjectiveRequirement": {
      "type": "object",
      "title": "CanStartObjectiveRequirement",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"CanStartObjective\" to function as this type.",
          "const": "CanStartObjective"
        },
        "ObjectiveId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "ReputationRequirement": {
      "type": "object",
      "title": "ReputationRequirement",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Reputation\" to function as this type.",
          "const": "Reputation"
        },
        "ReputationGroupId": {
          "type": [
            "string",
            "null"
          ]
        },
        "MinRequiredRankId": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "SoundEventLayer": {
      "type": "object",
      "title": "SoundEventLayer",
      "properties": {
        "Volume": {
          "description": "Volume offset for this layer in decibels.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "StartDelay": {
          "description": "A delay in seconds from when the sound event starts after which this layer should begin.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "Looping": {
          "type": "boolean",
          "description": "Whether this layer loops.",
          "default": false
        },
        "Probability": {
          "type": "integer",
          "description": "The probability of this layer being played when the sound event is triggered in percentage.",
          "default": 100
        },
        "ProbabilityRerollDelay": {
          "description": "A delay in seconds before the probability of this layer playing can be rerolled to see if it will now play (or not play) again.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "RandomSettings": {
          "description": "Randomization settings for parameters of this layer.",
          "anyOf": [
            {
              "default": {
                "MinVolume": 0,
                "MaxVolume": 0,
                "MinPitch": 0,
                "MaxPitch": 0,
                "MaxStartOffset": 0
              },
              "$ref": "common.schema.json#/$defs/RandomSettings"
            },
            {
              "type": "null"
            }
          ]
        },
        "Files": {
          "type": "array",
          "description": "The list of possible sound files for this layer. One will be chosen at random.",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "RoundRobinHistorySize": {
          "type": "integer",
          "description": "The same sound file will not repeat within this many plays. 0 disables round-robin behavior.",
          "minimum": 0,
          "maximum": 32,
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "RandomSettings": {
      "type": "object",
      "title": "RandomSettings",
      "properties": {
        "MinVolume": {
          "description": "Minimum additional random volume offset in decibels.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "MaxVolume": {
          "description": "Maximum additional random volume offset in decibels.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "MinPitch": {
          "description": "Minimum additional random pitch offset in semitones.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "MaxPitch": {
          "description": "Maximum additional random pitch offset in semitones.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "MaxStartOffset": {
          "description": "Maximum amount by which to offset the start of this sound event (e.g. start up to x seconds into the sound). This should only really be used for looping sounds to prevent phasing issues.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "SpawnConfiguration": {
      "type": "object",
      "title": "SpawnConfiguration",
      "description": "A configuration for an individual weighted NPC to spawn. Note: At least one of RealtimeRespawnTime and SpawnAfterGameTime must be set, matching the RealtimeRespawn flag on the marker.",
      "markdownDescription": "A configuration for an individual weighted NPC to spawn. **Note:** At least one of **RealtimeRespawnTime** and **SpawnAfterGameTime** must be set, matching the **RealtimeRespawn** flag on the marker.",
      "properties": {
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "description": "The role name of the NPC to spawn (omitting this results in a no-op spawn, i.e. a weighted chance of spawning nothing).",
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "Weight": {
          "type": "number",
          "description": "The spawn chance, relative to the total sum of all weights in this pool.",
          "exclusiveMinimum": 0,
          "default": 0
        },
        "RealtimeRespawnTime": {
          "type": "number",
          "description": "A value in seconds that specifies how long after the death of this mob a new mob will be spawned.",
          "default": 0
        },
        "SpawnAfterGameTime": {
          "type": [
            "string",
            "null"
          ],
          "description": "A Duration string e.g. of form P2DT3H4M (2 days, 3 hours, and 4 minutes) that specifies how long after the death of this mob a new mob will be spawned based on in-game time."
        },
        "Flock": {
          "description": "The optional flock definition to spawn around this NPC.",
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to FlockAsset"
            },
            {
              "$ref": "FlockAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "AndPatternOp": {
      "type": "object",
      "title": "AndPatternOp",
      "oneOf": [
        {
          "required": [
            "Op"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Op": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"And\" to function as this type.",
          "const": "And"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another AndPatternOp most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **AndPatternOp** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "TagPattern",
            "mapKey": "Op",
            "mapKeyValue": "And"
          }
        },
        "Patterns": {
          "type": "array",
          "items": {
            "$ref": "TagPattern.json#"
          },
          "minItems": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "EqualsTagOp": {
      "type": "object",
      "title": "EqualsTagOp",
      "oneOf": [
        {
          "required": [
            "Op"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Op": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Equals\" to function as this type.",
          "const": "Equals"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another EqualsTagOp most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **EqualsTagOp** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "TagPattern",
            "mapKey": "Op",
            "mapKeyValue": "Equals"
          }
        },
        "Tag": {
          "type": "string"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "NotPatternOp": {
      "type": "object",
      "title": "NotPatternOp",
      "oneOf": [
        {
          "required": [
            "Op"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Op": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Not\" to function as this type.",
          "const": "Not"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another NotPatternOp most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **NotPatternOp** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "TagPattern",
            "mapKey": "Op",
            "mapKeyValue": "Not"
          }
        },
        "Pattern": {
          "$ref": "TagPattern.json#"
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "OrPatternOp": {
      "type": "object",
      "title": "OrPatternOp",
      "oneOf": [
        {
          "required": [
            "Op"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Op": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Or\" to function as this type.",
          "const": "Or"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another OrPatternOp most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **OrPatternOp** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "TagPattern",
            "mapKey": "Op",
            "mapKeyValue": "Or"
          }
        },
        "Patterns": {
          "type": "array",
          "items": {
            "$ref": "TagPattern.json#"
          },
          "minItems": 1
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "Edge": {
      "type": "object",
      "title": "Edge",
      "properties": {
        "Width": {
          "type": "number",
          "default": 0
        },
        "Color": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{4}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgba\\(\\s*#([0-9a-fA-F]{3}){1,2}\\s*,\\s*[0,1](.[0-9]*)?\\s*\\)\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgba\\((\\s*[0-9]{1,3}\\s*,){3}\\s*[0,1](.[0-9]*)?\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Animation@1": {
      "type": "object",
      "title": "Animation",
      "properties": {
        "FrameSize": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Vector2i"
            },
            {
              "type": "null"
            }
          ]
        },
        "FrameRange": {
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Range"
            },
            {
              "type": "null"
            }
          ]
        },
        "FrameLifeSpan": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "Vector2i": {
      "type": "object",
      "title": "Vector2i",
      "properties": {
        "X": {
          "type": "integer",
          "default": 0
        },
        "Y": {
          "type": "integer",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "FogOptions": {
      "type": "object",
      "title": "FogOptions",
      "properties": {
        "IgnoreFogLimits": {
          "type": "boolean",
          "description": "The client has a default minimum AND maximum for \"FogFar\". Toggling this on will allow your FogDistance[1] to bypass those limits.",
          "default": false
        },
        "EffectiveViewDistanceMultiplier": {
          "description": "The client's default cap for FogDistance[1] (aka FogFar) is the effective view distance, meaning the farthest viewable chunk. This value (defaults 1.0) multiplies that cap. For example with high fog density, you can afford a fog multiplier of 1.3 as the cutoff of unloaded chunks may still be hidden.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "FogHeightCameraFixed": {
          "description": "By default, the client has e^(-FogHeightFalloff * ~Camera.Y) height-based fog. This adds significant fog near Camera.Y = 0. By setting this value (between 0.0 and 1.0), the Exp function is bypassed and there will be a fixed fog for height in the fog shader.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "FogHeightCameraOffset": {
          "description": "By default, the client has e^(-FogHeightFalloff * ~Camera.Y) height-based fog. This adds significant fog near Camera.Y = 0. The FogHeightCameraOffset is added to the Camera.Y.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "WeatherParticle": {
      "type": "object",
      "title": "WeatherParticle",
      "description": "Particle System that can be spawned in relation to a weather.",
      "properties": {
        "SystemId": {
          "type": "string"
        },
        "Color": {
          "description": "The colour used if none was specified in the particle settings.",
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "Scale": {
          "description": "The scale of the particle system.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "OvergroundOnly": {
          "type": "boolean",
          "description": "Sets if the particles can only spawn above the columns highest blocks.",
          "default": false
        },
        "PositionOffsetMultiplier": {
          "description": "The amount the system will move ahead of the camera.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "TimeColorAlpha": {
      "type": "object",
      "title": "TimeColorAlpha",
      "properties": {
        "Hour": {
          "type": "number",
          "minimum": 0,
          "maximum": 24,
          "default": 0
        },
        "Color": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{4}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgba\\(\\s*#([0-9a-fA-F]{3}){1,2}\\s*,\\s*[0,1](.[0-9]*)?\\s*\\)\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgba\\((\\s*[0-9]{1,3}\\s*,){3}\\s*[0,1](.[0-9]*)?\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "TimeFloat": {
      "type": "object",
      "title": "TimeFloat",
      "properties": {
        "Hour": {
          "type": "number",
          "minimum": 0,
          "maximum": 24,
          "default": 0
        },
        "Value": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "TimeColor": {
      "type": "object",
      "title": "TimeColor",
      "properties": {
        "Hour": {
          "type": "number",
          "minimum": 0,
          "maximum": 24,
          "default": 0
        },
        "Color": {
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "DayTexture": {
      "type": "object",
      "title": "DayTexture",
      "properties": {
        "Day": {
          "type": "integer",
          "default": 0
        },
        "Texture": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "Cloud": {
      "type": "object",
      "title": "Cloud",
      "properties": {
        "Texture": {
          "type": [
            "string",
            "null"
          ]
        },
        "Colors": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/TimeColorAlpha"
          }
        },
        "Speeds": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/TimeFloat"
          }
        }
      },
      "additionalProperties": false
    },
    "BasicWorldStructureAsset": {
      "type": "object",
      "title": "BasicWorldStructureAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"NoiseRange\" to function as this type.",
          "const": "NoiseRange"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BasicWorldStructureAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BasicWorldStructureAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "WorldStructureAsset",
            "mapKey": "Type",
            "mapKeyValue": "NoiseRange"
          }
        },
        "Biomes": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "common.schema.json#/$defs/BiomeRangeAsset"
          }
        },
        "Density": {
          "anyOf": [
            {
              "$ref": "DensityAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "DefaultBiome": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to BiomeAsset"
            },
            {
              "$ref": "BiomeAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "DefaultTransitionDistance": {
          "type": "integer",
          "exclusiveMinimum": 0,
          "default": 32
        },
        "MaxBiomeEdgeDistance": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        },
        "ContentFields": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/BaseHeightContentFieldAsset"
              }
            ]
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "BiomeRangeAsset": {
      "type": "object",
      "title": "BiomeRangeAsset",
      "properties": {
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BiomeRangeAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BiomeRangeAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "BiomeRangeAsset"
          }
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "Biome": {
          "anyOf": [
            {
              "type": "string",
              "title": "Reference to BiomeAsset"
            },
            {
              "$ref": "BiomeAsset.json#"
            },
            {
              "type": "null"
            }
          ]
        },
        "Min": {
          "type": "number",
          "default": -1
        },
        "Max": {
          "type": "number",
          "default": 1
        }
      },
      "additionalProperties": false
    },
    "BaseHeightContentFieldAsset": {
      "type": "object",
      "title": "BaseHeightContentFieldAsset",
      "oneOf": [
        {
          "required": [
            "Type"
          ]
        },
        {
          "required": [
            "Parent"
          ]
        }
      ],
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"BaseHeight\" to function as this type.",
          "const": "BaseHeight"
        },
        "Parent": {
          "type": "string",
          "description": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another BaseHeightContentFieldAsset most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "markdownDescription": "When set this asset will inherit properties from the named asset.\n\nWhen inheriting from another **BaseHeightContentFieldAsset** most properties will simply be copied from the parent asset to this asset. In the case where both child and parent provide a field the child field will simply replace the value provided by the parent, in the case of nested structures this will apply to the fields within the structure. In some cases the field may decide to act differently, for example: by merging the parent and child fields together.",
          "hytaleParent": {
            "type": "ContentFieldAsset",
            "mapKey": "Type",
            "mapKeyValue": "BaseHeight"
          }
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "default": ""
        },
        "Y": {
          "type": "number",
          "default": 0
        },
        "Tags": {
          "type": [
            "object",
            "null"
          ],
          "description": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a Material tag with the values Solid and Stone, And another single tag Ore.\n\nTags will be expanded into a single list of tags automatically. Using the above example with Material and Ore the end result would be the following list of tags: Ore, Material, Solid, Stone, Material=Solid and Material=Stone.",
          "markdownDescription": "Tags are a general way to describe an asset that can be interpreted by other systems in a way they see fit.\n\nFor example you could tag something with a **Material** tag with the values **Solid** and **Stone**, And another single tag **Ore**.\n\nTags will be expanded into a single list of tags automatically. Using the above example with **Material** and **Ore** the end result would be the following list of tags: **Ore**, **Material**, **Solid**, **Stone**, **Material=Solid** and **Material=Stone**.",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "FitToHeightMapSpawnProvider": {
      "type": "object",
      "title": "FitToHeightMapSpawnProvider",
      "description": "A spawn provider that takes a spawn point from another provider and attempts to fit it to the heightmap of the world whenever the spawn point would place the player out of bounds.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"FitToHeightMap\" to function as this type.",
          "const": "FitToHeightMap"
        },
        "SpawnProvider": {
          "description": "The target spawn provider to take the initial spawn point from.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/FitToHeightMapSpawnProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/GlobalSpawnProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/IndividualSpawnProvider"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "GlobalSpawnProvider": {
      "type": "object",
      "title": "GlobalSpawnProvider",
      "description": "A spawn provider that provides a single static spawn point for all players.",
      "properties": {
        "Id": {
          "description": "This field controls the type, it must be set to the constant value \"Global\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "FitToHeightMap",
                  "Individual"
                ]
              }
            }
          ]
        },
        "SpawnPoint": {
          "description": "The spawn point for all players to spawn at",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Transform"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "IndividualSpawnProvider": {
      "type": "object",
      "title": "IndividualSpawnProvider",
      "description": "A spawn provider that selects a spawn point from a list based on the player being spawned in. This gives random but consistent spawn points for players.",
      "properties": {
        "Id": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Individual\" to function as this type.",
          "const": "Individual"
        },
        "SpawnPoints": {
          "type": [
            "array",
            "null"
          ],
          "description": "The list of spawn points to select from.",
          "items": {
            "$ref": "common.schema.json#/$defs/Transform"
          }
        }
      },
      "additionalProperties": false
    },
    "DummyWorldGenProvider": {
      "type": "object",
      "title": "DummyWorldGenProvider",
      "description": "A dummy world generation provider that places a single layer of unknown blocks in each chunk.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Dummy\" to function as this type.",
          "const": "Dummy"
        }
      },
      "additionalProperties": false
    },
    "FlatWorldGenProvider": {
      "type": "object",
      "title": "FlatWorldGenProvider",
      "description": "A world generation provider that generates a flat world with defined layers.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Flat\" to function as this type.",
          "const": "Flat"
        },
        "Tint": {
          "description": "The tint to set for all chunks that are generated.",
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "Layers": {
          "type": "array",
          "description": "The list of layers to add to the world.",
          "items": {
            "$ref": "common.schema.json#/$defs/Layer"
          }
        }
      },
      "additionalProperties": false
    },
    "Layer": {
      "type": "object",
      "title": "Layer",
      "description": "A layer of blocks for a given range.",
      "properties": {
        "From": {
          "type": "integer",
          "description": "The Y coordinate (inclusive) to start placing blocks at.",
          "default": -2147483648
        },
        "To": {
          "type": "integer",
          "description": "The Y coordinate (exclusive) to stop placing blocks at.",
          "exclusiveMinimum": {
            "$data": "1/From"
          },
          "default": 2147483647
        },
        "BlockType": {
          "type": [
            "string",
            "null"
          ],
          "description": "The type of block that will be used for all blocks placed at this layer."
        },
        "Environment": {
          "type": [
            "string",
            "null"
          ],
          "description": "The environment to set for every block placed."
        }
      },
      "additionalProperties": false
    },
    "HytaleWorldGenProvider": {
      "type": "object",
      "title": "HytaleWorldGenProvider",
      "description": "The standard generator for Hytale.",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"Hytale\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "HytaleGenerator",
                  "Flat",
                  "Void",
                  "Dummy"
                ]
              }
            }
          ]
        },
        "Name": {
          "type": [
            "string",
            "null"
          ],
          "description": "The name of the generator to use. \"*Default*\" if not provided.",
          "default": "Default"
        },
        "Path": {
          "type": [
            "string",
            "null"
          ],
          "description": "The path to the world generation configuration. \n\nDefaults to the server provided world generation folder if not set."
        }
      },
      "additionalProperties": false
    },
    "HandleProvider": {
      "type": "object",
      "title": "HandleProvider",
      "description": "The standard generator for Hytale.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"HytaleGenerator\" to function as this type.",
          "const": "HytaleGenerator"
        },
        "WorldStructure": {
          "type": [
            "string",
            "null"
          ],
          "description": "The world structure to be used for this world.",
          "default": "Default"
        }
      },
      "additionalProperties": false
    },
    "VoidWorldGenProvider": {
      "type": "object",
      "title": "VoidWorldGenProvider",
      "description": "A world generation provider that does not generate any blocks.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Void\" to function as this type.",
          "const": "Void"
        },
        "Tint": {
          "description": "The tint to set for all chunks that are generated.",
          "anyOf": [
            {
              "type": "string",
              "pattern": "^\\s*#([0-9a-fA-F]{3}){1,2}\\s*$"
            },
            {
              "type": "string",
              "pattern": "^\\s*rgb\\((\\s*[0-9]{1,3}\\s*,){2}\\s*[0-9]{1,3}\\s*\\)\\s*$"
            },
            {
              "type": "null"
            }
          ]
        },
        "Environment": {
          "type": [
            "string",
            "null"
          ],
          "description": "The environment to set for every column in generated chunks."
        }
      },
      "additionalProperties": false
    },
    "DisabledWorldMapProvider": {
      "type": "object",
      "title": "DisabledWorldMapProvider",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Disabled\" to function as this type.",
          "const": "Disabled"
        }
      },
      "additionalProperties": false
    },
    "WorldGenWorldMapProvider": {
      "type": "object",
      "title": "WorldGenWorldMapProvider",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"WorldGen\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "Disabled"
                ]
              }
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "EmptyChunkStorageProvider": {
      "type": "object",
      "title": "EmptyChunkStorageProvider",
      "description": "A chunk storage provider that discards any chunks to save and will always fail to find chunks.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Empty\" to function as this type.",
          "const": "Empty"
        }
      },
      "additionalProperties": false
    },
    "DefaultChunkStorageProvider": {
      "type": "object",
      "title": "DefaultChunkStorageProvider",
      "description": "Selects the default recommended storage as decided by the server.",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"Hytale\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "Empty",
                  "Migration",
                  "IndexedStorage"
                ]
              }
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "IndexedStorageChunkStorageProvider": {
      "type": "object",
      "title": "IndexedStorageChunkStorageProvider",
      "description": "Uses the indexed storage file format to store chunks.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"IndexedStorage\" to function as this type.",
          "const": "IndexedStorage"
        },
        "FlushOnWrite": {
          "type": "boolean",
          "description": "Controls whether the indexed storage flushes during writes.\nRecommended to be enabled to prevent corruption of chunks during unclean shutdowns.",
          "default": true
        }
      },
      "additionalProperties": false
    },
    "MigrationChunkStorageProvider": {
      "type": "object",
      "title": "MigrationChunkStorageProvider",
      "description": "A provider that combines multiple storage providers in a chain to assist with migrating worlds between storage formats.\n\nCan also be used to set storage to load chunks but block saving them if combined with the Empty storage provider",
      "markdownDescription": "A provider that combines multiple storage providers in a chain to assist with migrating worlds between storage formats.\n\nCan also be used to set storage to load chunks but block saving them if combined with the **Empty** storage provider",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Migration\" to function as this type.",
          "const": "Migration"
        },
        "Loaders": {
          "type": [
            "array",
            "null"
          ],
          "description": "A list of storage providers to use as chunk loaders.\n\nEach loader will be tried in order to load a chunk, returning the chunk if found otherwise trying the next loaded until found or none are left.",
          "items": {
            "title": "Type Selector",
            "anyOf": [
              {
                "$ref": "common.schema.json#/$defs/EmptyChunkStorageProvider"
              },
              {
                "$ref": "common.schema.json#/$defs/DefaultChunkStorageProvider"
              },
              {
                "$ref": "common.schema.json#/$defs/IndexedStorageChunkStorageProvider"
              },
              {
                "$ref": "common.schema.json#/$defs/MigrationChunkStorageProvider"
              }
            ]
          }
        },
        "Saver": {
          "description": "The storage provider to use to save chunks.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/EmptyChunkStorageProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/DefaultChunkStorageProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/IndexedStorageChunkStorageProvider"
            },
            {
              "$ref": "common.schema.json#/$defs/MigrationChunkStorageProvider"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "ChunkConfig": {
      "type": "object",
      "title": "ChunkConfig",
      "properties": {
        "PregenerateRegion": {
          "description": "Sets the region that will be pregenerated for the world.\n\nIf set, the specified region will be pregenerated when the world starts.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Box2D"
            },
            {
              "type": "null"
            }
          ]
        },
        "KeepLoadedRegion": {
          "description": "Sets a region of chunks that will never be unloaded.",
          "anyOf": [
            {
              "$ref": "common.schema.json#/$defs/Box2D"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Box2D": {
      "type": "object",
      "title": "Box2D",
      "properties": {
        "Min": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0
              },
              "$ref": "common.schema.json#/$defs/Vector2d"
            },
            {
              "type": "null"
            }
          ]
        },
        "Max": {
          "anyOf": [
            {
              "default": {
                "X": 0,
                "Y": 0
              },
              "$ref": "common.schema.json#/$defs/Vector2d"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Vector2d": {
      "type": "object",
      "title": "Vector2d",
      "properties": {
        "X": {
          "type": "number",
          "default": 0
        },
        "Y": {
          "type": "number",
          "default": 0
        }
      },
      "additionalProperties": false
    },
    "ClientEffectWorldSettings": {
      "type": "object",
      "title": "ClientEffectWorldSettings",
      "properties": {
        "SunHeightPercent": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SunAngleDegrees": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "BloomIntensity": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "BloomPower": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SunIntensity": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SunshaftIntensity": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "SunshaftScaleFactor": {
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "DiskResourceStorageProvider": {
      "type": "object",
      "title": "DiskResourceStorageProvider",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Disk\" to function as this type.",
          "const": "Disk"
        },
        "Path": {
          "type": [
            "string",
            "null"
          ],
          "default": "resources"
        }
      },
      "additionalProperties": false
    },
    "EmptyResourceStorageProvider": {
      "type": "object",
      "title": "EmptyResourceStorageProvider",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Empty\" to function as this type.",
          "const": "Empty"
        }
      },
      "additionalProperties": false
    },
    "DefaultResourceStorageProvider": {
      "type": "object",
      "title": "DefaultResourceStorageProvider",
      "properties": {
        "Type": {
          "description": "This field controls the type, it must be set to the constant value \"Hytale\" to function as this type.",
          "allOf": [
            {
              "type": [
                "null",
                "string"
              ]
            },
            {
              "not": {
                "type": "string",
                "enum": [
                  "Empty",
                  "Disk"
                ]
              }
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "IdleTimeoutCondition": {
      "type": "object",
      "title": "IdleTimeoutCondition",
      "description": "A condition that triggers after the world has be idle (without players) for a set time.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"IdleTimeout\" to function as this type.",
          "const": "IdleTimeout"
        },
        "TimeoutSeconds": {
          "type": "number",
          "description": "How long (in seconds) the world has to be idle (without players) for before triggering.",
          "default": 300
        }
      },
      "additionalProperties": false
    },
    "PortalRemovalCondition": {
      "type": "object",
      "title": "PortalRemovalCondition",
      "description": "A condition for temporary portal worlds.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Portal\" to function as this type.",
          "const": "Portal"
        },
        "TimeoutSeconds": {
          "type": "number",
          "description": "How long the portal world will stay open (in seconds) after being joined.",
          "default": 60
        }
      },
      "additionalProperties": false
    },
    "TimeoutCondition": {
      "type": "object",
      "title": "TimeoutCondition",
      "description": "A condition that triggers after a set time limit.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"Timeout\" to function as this type.",
          "const": "Timeout"
        },
        "TimeoutSeconds": {
          "type": "number",
          "description": "How long to wait (in seconds) before closing the world.",
          "default": 300
        }
      },
      "additionalProperties": false
    },
    "WorldEmptyCondition": {
      "type": "object",
      "title": "WorldEmptyCondition",
      "description": "A condition that triggers when the world is empty.\n\nIt will only trigger after at least one player has joined. As a safety measure it provides a timeout for waiting for a player to join in case the player disconnected before entering the world.",
      "properties": {
        "Type": {
          "type": "string",
          "description": "This field controls the type, it must be set to the constant value \"WorldEmpty\" to function as this type.",
          "const": "WorldEmpty"
        },
        "TimeoutSeconds": {
          "type": "number",
          "description": "How long to wait (in seconds) for a player to join before closing the world.",
          "default": 300
        }
      },
      "additionalProperties": false
    },
    "WorldReturnPoint": {
      "type": "object",
      "title": "WorldReturnPoint",
      "description": "A world/location pair that is used as a place to return players to.",
      "properties": {
        "World": {
          "type": "string",
          "title": "UUID Binary",
          "description": "The UUID of the world to return the player to.",
          "pattern": "^[0-9a-zA-Z+/]+$",
          "minLength": 24,
          "maxLength": 24
        },
        "ReturnPoint": {
          "description": "The location to send the player to.",
          "$ref": "common.schema.json#/$defs/Transform"
        },
        "ReturnOnReconnect": {
          "type": "boolean",
          "description": "Whether this point should be triggered when a player reconnects into a world.",
          "default": false
        }
      },
      "additionalProperties": false
    },
    "InstanceDiscoveryConfig": {
      "type": "object",
      "title": "InstanceDiscoveryConfig",
      "description": "Configuration for displaying an event title when a player discovers an instance.",
      "properties": {
        "TitleKey": {
          "type": "string",
          "description": "The translation key for the primary title (e.g., \"server.instances.gaia_temple.title\")."
        },
        "SubtitleKey": {
          "type": [
            "string",
            "null"
          ],
          "description": "The translation key for the subtitle (e.g., \"server.instances.gaia_temple.subtitle\")."
        },
        "Display": {
          "type": "boolean",
          "description": "Whether to display the discovery title and play the discovery sound.",
          "default": true
        },
        "AlwaysDisplay": {
          "type": "boolean",
          "description": "Whether to always display the discovery title, even if already discovered.",
          "default": false
        },
        "DiscoverySoundEventId": {
          "type": [
            "string",
            "null"
          ],
          "description": "The sound event ID to play when discovering this instance."
        },
        "Icon": {
          "type": [
            "string",
            "null"
          ],
          "description": "The icon to display with the event title."
        },
        "Major": {
          "type": "boolean",
          "description": "Whether this is a major discovery (affects visual presentation).",
          "default": false
        },
        "Duration": {
          "description": "The duration to display the event title for, in seconds.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "FadeInDuration": {
          "description": "The fade-in duration for the event title, in seconds.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        },
        "FadeOutDuration": {
          "description": "The fade-out duration for the event title, in seconds.",
          "$ref": "base.schema.json#/$defs/NullableNumberOrSpecial"
        }
      },
      "additionalProperties": false
    },
    "StateEvaluator": {
      "type": "object",
      "title": "StateEvaluator",
      "properties": {
        "Options": {
          "type": "array",
          "description": "The list of state options to evaluate.",
          "items": {
            "$ref": "common.schema.json#/$defs/StateOption"
          },
          "minItems": 1
        },
        "ExecutionFrequency": {
          "type": "number",
          "description": "The frequency with which the state evaluator should be run.",
          "exclusiveMinimum": 0,
          "default": 0.1
        },
        "StateChangeCooldown": {
          "type": "number",
          "description": "The delay before performing the next state evaluation after a successful switch to another state.",
          "exclusiveMinimum": 0,
          "default": 2
        },
        "MinimumConsideredUtility": {
          "type": "number",
          "description": "The minimum utility value to consider when selecting from evaluated options.",
          "minimum": 0,
          "default": 0.1
        }
      },
      "additionalProperties": false
    },
    "StateOption": {
      "type": "object",
      "title": "StateOption",
      "properties": {
        "Description": {
          "type": [
            "string",
            "null"
          ],
          "description": "A friendly description of this option's outcome."
        },
        "Conditions": {
          "type": "array",
          "description": "The list of conditions for evaluating this option's utility.",
          "items": {
            "anyOf": [
              {
                "type": "string",
                "title": "Reference to Condition"
              },
              {
                "$ref": "Condition.json#"
              }
            ]
          },
          "minItems": 1
        },
        "WeightCoefficient": {
          "type": "number",
          "description": "An additional weighted ranking that can be used to greatly increase the utility of this option.",
          "minimum": 1,
          "default": 1
        },
        "State": {
          "type": "string",
          "description": "The main state name.",
          "pattern": "[^\\s]",
          "minLength": 1
        },
        "SubState": {
          "type": [
            "string",
            "null"
          ],
          "description": "The (optional) substate name."
        }
      },
      "additionalProperties": false
    }
  }
}